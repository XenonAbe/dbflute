${database.allClassCopyright}package ${myDBMetaPackageName};
#set ($myClassName = "${myDBMetaClassName}")

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Collections;

import ${glPackageBaseCommon}.${glEntityInterfaceName};
import ${glPackageBaseCommonDBMeta}.${glDBMetaAbstractName};
import ${myExtendedEntityPackageName}.${myExtendedObjectClassName};
import ${glPackageBaseCommonDBMetaInfo}.*;

/**
 * The DB meta of ${table.Name}. (Singleton)
 * <pre>
 * [primary-key]
 *     ${table.primaryKeyNameCommaString}
 * 
 * [column]
 *     ${table.columnNameCommaString}
 * 
 * [sequence]
 *     ${table.definedSequenceName}
 * 
 * [identity]
 *     ${table.identityColumnName}
 * 
 * [version-no]
 *     ${table.versionNoColumnName}
 * 
 * [foreign-table]
 *     ${table.foreignTableNameCommaString}
 * 
 * [referrer-table]
 *     ${table.referrerTableNameCommaString}
 * 
 * [foreign-property]
 *     ${table.foreignPropertyNameCommaString}
 * 
 * [referrer-property]
 *     ${table.referrerPropertyNameCommaString}
 * </pre>
 * @author ${database.ClassAuthor}
 */${database.outputSuppressWarningsAfterLineSeparator()}
public class ${myClassName} extends ${glDBMetaAbstractName} {

    // ===================================================================================
    //                                                                          Definition
    //                                                                          ==========
    protected static final Class<${myExtendedObjectClassName}> ENTITY_TYPE = ${myExtendedObjectClassName}.class;
    private static final ${myClassName} _instance = new ${myClassName}();

    // ===================================================================================
    //                                                                         Constructor
    //                                                                         ===========
    private ${myClassName}() {
    }

    // ===================================================================================
    //                                                                           Singleton
    //                                                                           =========
    public static ${myClassName} getInstance() {
        return _instance;
    }

    // ===================================================================================
    //                                                                     Name Definition
    //                                                                     ===============
    // -----------------------------------------------------
    //                                                 Table
    //                                                 -----
    /** Table DB name. */
    public static final String TABLE_DB_NAME = "$table.name";

    /** Table property name(JavaBeansRule). */
    public static final String TABLE_PROPERTY_NAME = "$table.javaBeansRulePropertyName";

    // -----------------------------------------------------
    //                                        Column DB Name
    //                                        --------------
#foreach ($col in $table.columns)
    public static final String DB_NAME_${col.name} = "$col.name";
#end

    // -----------------------------------------------------
    //                                  Column Property Name
    //                                  (JavaBeansRule)
    //                                  --------------------
#foreach ($col in $table.columns)
    public static final String PROPERTY_NAME_${col.javaBeansRulePropertyName} = "$col.javaBeansRulePropertyName";
#end

    // -----------------------------------------------------
    //                                 Foreign Property Name
    //                                 (JavaBeansRule)
    //                                 ---------------------
#foreach ($foreignKeys in $table.foreignKeys)
    public static final String FOREIGN_PROPERTY_NAME_${foreignKeys.foreignJavaBeansRulePropertyName} = "$foreignKeys.foreignJavaBeansRulePropertyName";
#end

#foreach ($referrer in $table.referrers)
#if ($referrer.isOneToOne())
    public static final String FOREIGN_PROPERTY_NAME_${referrer.referrerJavaBeansRulePropertyNameAsOne} = "$referrer.referrerJavaBeansRulePropertyNameAsOne";
#end
#end

    // -----------------------------------------------------
    //                                Referrer Property Name
    //                                (JavaBeansRule)
    //                                ----------------------
#foreach ($referrer in $table.referrers)
#if (!$referrer.isOneToOne())
    public static final String REFERRER_PROPERTY_NAME_${referrer.referrerJavaBeansRulePropertyName} = "$referrer.referrerJavaBeansRulePropertyName";
#end
#end

    // -----------------------------------------------------
    //                                              Name Map
    //                                              --------
    /** The map of {DB name : property name} key-to-lower. */
    private static Map<String, String> _dbNamePropertyNameKeyToLowerMap;
    protected Map<String, String> createDbNamePropertyNameKeyToLowerMap() {
        if (_dbNamePropertyNameKeyToLowerMap != null) {
            return _dbNamePropertyNameKeyToLowerMap;
        }
        final Map<String, String> map = new LinkedHashMap<String, String>();
        map.put(TABLE_DB_NAME.toLowerCase(), TABLE_PROPERTY_NAME);
        setupKeyToLowerMap(map, true);
        _dbNamePropertyNameKeyToLowerMap = Collections.unmodifiableMap(map);
        return _dbNamePropertyNameKeyToLowerMap;
    }

    /** The map of {property name : DB name} key-to-lower. */
    private static Map<String, String> _propertyNameDbNameKeyToLowerMap;
    protected Map<String, String> createPropertyNameDbNameKeyToLowerMap() {
        if (_propertyNameDbNameKeyToLowerMap != null) {
            return _propertyNameDbNameKeyToLowerMap;
        }
        final Map<String, String> map = new LinkedHashMap<String, String>();
        map.put(TABLE_PROPERTY_NAME.toLowerCase(), TABLE_DB_NAME);
        setupKeyToLowerMap(map, false);
        _propertyNameDbNameKeyToLowerMap = Collections.unmodifiableMap(map);
        return _propertyNameDbNameKeyToLowerMap;
    }

    // ===================================================================================
    //                                                                          Table Name
    //                                                                          ==========
    public String getTableDbName() {
        return TABLE_DB_NAME;
    }

    public String getTablePropertyName() {// as JavaBeansRule
        return TABLE_PROPERTY_NAME;
    }

    // ===================================================================================
    //                                                                            Name Map
    //                                                                            ========
    public Map<String, String> getDbNamePropertyNameKeyToLowerMap() {
        return createDbNamePropertyNameKeyToLowerMap();
    }

    public Map<String, String> getPropertyNameDbNameKeyToLowerMap() {
        return createPropertyNameDbNameKeyToLowerMap();
    }

    // ===================================================================================
    //                                                                           Type Name
    //                                                                           =========
    public String getEntityTypeName() {
        return "${myExtendedEntityPackageName}.${myExtendedObjectClassName}";
    }
#if ($isExistConditionBean)

    public String getConditionBeanTypeName() {
        return "${glPackageBaseCB}.${myConditionBeanClassName}";
    }
#else

    public String getConditionBeanTypeName() {
        return null;
    }
#end
#if ($isExistDao)

    public String getDaoTypeName() {
        return "${myExtendedDaoPackageName}.${myExtendedDaoClassName}";
    }
#else

    public String getDaoTypeName() {
        return null;
    }
#end
#if ($isExistBehavior)

    public String getBehaviorTypeName() {
        return "${myExtendedBhvPackageName}.${myExtendedBhvClassName}";
    }
#else

    public String getBehaviorTypeName() {
        return null;
    }
#end

    // ===================================================================================
    //                                                                         Object Type
    //                                                                         ===========
    public Class<${myExtendedObjectClassName}> getEntityType() {
        return ENTITY_TYPE;
    }

    // ===================================================================================
    //                                                                     Object Instance
    //                                                                     ===============
    public ${glEntityInterfaceName} newEntity() {
        return newMyEntity();
    }

    public ${myExtendedObjectClassName} newMyEntity() {
        return new ${myExtendedObjectClassName}();
    }

    // ===================================================================================
    //                                                                         Column Info
    //                                                                         ===========
#foreach ($col in $table.columns)
    public ${glColumnInfoName} column${col.javaBeansRulePropertyNameInitCap}() {
        return new ${glColumnInfoName}(this, "${col.name}", "${col.javaBeansRulePropertyName}", ${col.javaNative}.class, ${col.isPrimaryKey()}, ${col.columnSizeSettingExpression}, ${col.columnDecimalDigitsSettingExpression});
    }
#end

    // ===================================================================================
    //                                                                         Unique Info
    //                                                                         ===========
    // -----------------------------------------------------
    //                                       Primary Element
    //                                       ---------------
    public ${glUniqueInfoName} getPrimaryUniqueInfo() {
#if ($table.hasPrimaryKey())
        final ${glUniqueInfoName} uniqueInfo = new ${glUniqueInfoName}();
        uniqueInfo.setDBMeta(this);
#foreach ($col in $table.primaryKey)
        uniqueInfo.addUniqueColumnList(new ${glColumnInfoName}(this, "${col.name}", "${col.uncapitalisedJavaName}", ${col.javaNative}.class, true, ${col.columnSizeSettingExpression}, ${col.columnDecimalDigitsSettingExpression}));
#end
        uniqueInfo.setPrimary(true);
        return uniqueInfo;
#else
        throw new UnsupportedOperationException("The table doen not have primary key: " + getTableDbName());
#end
    }

    public boolean hasPrimaryKey() {
        return ${table.hasPrimaryKey()};
    }

    public boolean hasTwoOrMorePrimaryKeys() {
        return ${table.hasTwoOrMorePrimaryKeys()};
    }

    // ===================================================================================
    //                                                                       Relation Info
    //                                                                       =============
    // -----------------------------------------------------
    //                                      Foreign Property
    //                                      ----------------
#foreach ($foreignKeys in $table.foreignKeys)
    public ${glForeignInfoName} foreign${foreignKeys.foreignJavaBeansRulePropertyNameInitCap}() {
        final Map<${glColumnInfoName}, ${glColumnInfoName}> map = newLinkedHashMap();
#foreach ($column in $foreignKeys.localColumnList)
#set ($yourColumn = ${foreignKeys.getForeignColumnByLocalColumn(${column})})
        map.put(column${column.javaBeansRulePropertyNameInitCap}(), ${foreignKeys.foreignTableDBMetaClassName}.getInstance().column${yourColumn.javaBeansRulePropertyNameInitCap}());
#end
	    return craeteForeignInfo("${foreignKeys.foreignJavaBeansRulePropertyName}", ${table.DBMetaClassName}.getInstance(), ${foreignKeys.foreignTableDBMetaClassName}.getInstance(), map, ${table.resolveForeignIndex($foreignKeys)}, ${foreignKeys.isOneToOne()});
    }
#end

#foreach ($referrer in $table.referrers)
#set ($genericsColumnInfoMap = "${glColumnInfoName}, ${glColumnInfoName}")
#if (${referrer.isOneToOne()})
    public ${glForeignInfoName} foreign${referrer.referrerJavaBeansRulePropertyNameAsOneInitCap}() {
        final Map<${glColumnInfoName}, ${glColumnInfoName}> map = newLinkedHashMap();
#foreach ($column in $referrer.foreignColumnList)
#set ($yourColumn = ${referrer.getLocalColumnByForeignColumn(${column})})
        map.put(column${column.javaBeansRulePropertyNameInitCap}(), ${referrer.referrerTableDBMetaClassName}.getInstance().column${yourColumn.javaBeansRulePropertyNameInitCap}());
#end
	    return craeteForeignInfo("${referrer.refererJavaBeansRulePropertyNameAsOne}", ${referrer.foreignTableDBMetaClassName}.getInstance(), ${referrer.referrerTableDBMetaClassName}.getInstance(), map, ${table.resolveReferrerIndexAsOne($referrer)}, ${referrer.isOneToOne()});
    }
#end
#end

    // -----------------------------------------------------
    //                                     Referrer Property
    //                                     -----------------
#foreach ($referrer in $table.referrers)
#if (!${referrer.isOneToOne()})
    public ${glPackageBaseCommonDBMetaInfo}.${glReferrerInfoName} referrer${referrer.referrerJavaBeansRulePropertyNameInitCap}() {
        final Map<${glColumnInfoName}, ${glColumnInfoName}> map = newLinkedHashMap();
#foreach ($column in $referrer.foreignColumnList)
        map.put(column${column.javaBeansRulePropertyNameInitCap}(), ${referrer.referrerTableDBMetaClassName}.getInstance().column${referrer.getLocalColumnByForeignColumn(${column}).javaBeansRulePropertyNameInitCap}());
#end
	    return craeteReferrerInfo("${referrer.referrerJavaBeansRulePropertyName}", ${referrer.foreignTableDBMetaClassName}.getInstance(), ${referrer.referrerTableDBMetaClassName}.getInstance(), map, ${referrer.isOneToOne()});
    }

#end
#end
#if ($database.isMakeFlatExpansion())

    // -----------------------------------------------------
    //                                        Relation Trace
    //                                        --------------
    public ${table.relationTraceClassName}RelationTrace createRelationTrace(RelationTraceFixHandler relationTraceFixHandler) {
        return new ${table.relationTraceClassName}RelationTrace(relationTraceFixHandler);
    }

    public ${table.relationTraceClassName}RelationTrace createRelationTrace(List<${glRelationInfoName}> relationList, List<AbstractRelationTrace> relationTraceList) {
        return new ${table.relationTraceClassName}RelationTrace(relationList, relationTraceList);
    }

    public static class ${table.relationTraceClassName}RelationTrace extends AbstractRelationTrace {

        /**
         * Constructor for first step.
         * @param relationTraceFixHandler The handler of fixed relation trace. (Nullable)
         */
        public ${table.relationTraceClassName}RelationTrace(RelationTraceFixHandler relationTraceFixHandler) {
            super(relationTraceFixHandler);
        }

        /**
         * Constructor for relation step.
         * @param relationList The list of relation. (NotNull)
         * @param relationTraceList The list of relation trace. (NotNull)
         */
        public ${table.relationTraceClassName}RelationTrace(List<${glRelationInfoName}> relationList, List<AbstractRelationTrace> relationTraceList) {
            super(relationList, relationTraceList);
        }

#foreach ($foreignKeys in $table.foreignKeys)
        public ${foreignKeys.foreignTableDBMetaClassName}.${foreignKeys.foreignTable.relationTraceClassName}RelationTrace foreign${foreignKeys.foreignJavaBeansRulePropertyNameInitCap}() {
            _relationList.add(${myDBMetaClassName}.getInstance().foreign${foreignKeys.foreignJavaBeansRulePropertyNameInitCap}());
            return ${foreignKeys.foreignTableDBMetaClassName}.getInstance().createRelationTrace(_relationList, _relationTraceList);
        }
#end
#foreach ($referrer in $table.referrers)
#if (${referrer.isOneToOne()})
        public ${referrer.referrerTableDBMetaClassName}.${referrer.table.relationTraceClassName}RelationTrace foreign${referrer.referrerJavaBeansRulePropertyNameAsOneInitCap}() {
            _relationList.add(${myDBMetaClassName}.getInstance().foreign${referrer.referrerJavaBeansRulePropertyNameAsOneInitCap}());
            return ${referrer.referrerTableDBMetaClassName}.getInstance().createRelationTrace(_relationList, _relationTraceList);
        }
#end
#end
#foreach ($referrer in $table.referrers)
#if (!${referrer.isOneToOne()})
        public ${referrer.referrerTableDBMetaClassName}.${referrer.table.relationTraceClassName}RelationTrace referrer${referrer.referrerJavaBeansRulePropertyNameInitCap}() {
            _relationList.add(${myDBMetaClassName}.getInstance().referrer${referrer.referrerJavaBeansRulePropertyNameInitCap}());
            return ${referrer.referrerTableDBMetaClassName}.getInstance().createRelationTrace(_relationList, _relationTraceList);
        }
#end
#end

#foreach ($col in $table.columns)
        public RelationTrace column${col.javaBeansRulePropertyNameInitCap}() { return fixTrace(_relationList, ${myDBMetaClassName}.getInstance().column${col.javaBeansRulePropertyNameInitCap}()); }
#end
    }
#end

    // ===================================================================================
    //                                                                       Sequence Info
    //                                                                       =============
    public boolean hasSequence() {
        return ${table.isUseSequence()};
    }

    // ===================================================================================
    //                                                                Optimistic Lock Info
    //                                                                ====================
    public boolean hasVersionNo() {
        return ${table.isUseVersionNo()};
    }

    public boolean hasUpdateDate() {
        return ${table.isUseUpdateDate()};
    }

    // ===================================================================================
    //                                                                  Common Column Info
    //                                                                  ==================
    public boolean hasCommonColumn() {
        return ${table.hasAllCommonColumn()};
    }

    // ===================================================================================
    //                                                                     Entity Handling
    //                                                                     ===============  
    // -----------------------------------------------------
    //                                                Accept
    //                                                ------
    public void acceptPrimaryKeyMap(${glEntityInterfaceName} entity, Map<String, ? extends Object> primaryKeyMap) {
#if ($table.hasPrimaryKey())
        final ${myExtendedObjectClassName} myEntity = (${myExtendedObjectClassName})entity;
        MapAssertUtil.assertPrimaryKeyMapNotNullAndNotEmpty(primaryKeyMap);
        final MapStringValueAnalyzer analyzer = new MapStringValueAnalyzer(primaryKeyMap, entity.getModifiedPropertyNames());

#foreach ($col in $table.primaryKey)
        MapAssertUtil.assertColumnExistingInPrimaryKeyMap(primaryKeyMap, "${col.Name}");
#if ($col.isJavaNativeStringObject())
        if (analyzer.init("${col.Name}", "${col.UncapitalisedJavaName}", "${col.JavaBeansRulePropertyName}")) { myEntity.set${col.javaName}(analyzer.analyzeString(${col.JavaNative}.class)); }
#end
#if ($col.isJavaNativeNumberObject())
        if (analyzer.init("${col.Name}", "${col.UncapitalisedJavaName}", "${col.JavaBeansRulePropertyName}")) { myEntity.set${col.javaName}(analyzer.analyzeNumber(${col.JavaNative}.class)); }
#end
#if ($col.isJavaNativeDateObject())
        if (analyzer.init("${col.Name}", "${col.UncapitalisedJavaName}", "${col.JavaBeansRulePropertyName}")) { myEntity.set${col.javaName}(analyzer.analyzeDate(${col.JavaNative}.class)); }
#end
#if (!$col.isJavaNativeStringObject() && !$col.isJavaNativeNumberObject() && !$col.isJavaNativeDateObject())
        if (analyzer.init("${col.Name}", "${col.UncapitalisedJavaName}", "${col.JavaBeansRulePropertyName}")) { myEntity.set${col.javaName}(analyzer.analyzeOther(${col.JavaNative}.class)); }
#end
#end

#else

        String msg = "This table has no primary-keys: " + getTableDbName();
        throw new IllegalStateException(msg);
#end
    }

    public void acceptPrimaryKeyMapString(${glEntityInterfaceName} entity, String primaryKeyMapString) {
        MapStringUtil.acceptPrimaryKeyMapString(primaryKeyMapString, entity);
    }

    public void acceptColumnValueMap(${glEntityInterfaceName} entity, Map<String, ? extends Object> columnValueMap) {
        final ${myExtendedObjectClassName} myEntity = (${myExtendedObjectClassName})entity;
        MapAssertUtil.assertColumnValueMapNotNullAndNotEmpty(columnValueMap);
        final MapStringValueAnalyzer analyzer = new MapStringValueAnalyzer(columnValueMap, entity.getModifiedPropertyNames());

#foreach ($col in $table.columns)
#if ($col.isJavaNativeStringObject())
        if (analyzer.init("${col.Name}", "${col.UncapitalisedJavaName}", "${col.JavaBeansRulePropertyName}")) { myEntity.set${col.javaName}(analyzer.analyzeString(${col.JavaNative}.class)); }
#end
#if ($col.isJavaNativeNumberObject())
        if (analyzer.init("${col.Name}", "${col.UncapitalisedJavaName}", "${col.JavaBeansRulePropertyName}")) { myEntity.set${col.javaName}(analyzer.analyzeNumber(${col.JavaNative}.class)); }
#end
#if ($col.isJavaNativeDateObject())
        if (analyzer.init("${col.Name}", "${col.UncapitalisedJavaName}", "${col.JavaBeansRulePropertyName}")) { myEntity.set${col.javaName}(analyzer.analyzeDate(${col.JavaNative}.class)); }
#end
#if (!$col.isJavaNativeStringObject() && !$col.isJavaNativeNumberObject() && !$col.isJavaNativeDateObject())
        if (analyzer.init("${col.Name}", "${col.UncapitalisedJavaName}", "${col.JavaBeansRulePropertyName}")) { myEntity.set${col.javaName}(analyzer.analyzeOther(${col.JavaNative}.class)); }
#end
#end

    }

    public void acceptColumnValueMapString(${glEntityInterfaceName} entity, String columnValueMapString) {
        MapStringUtil.acceptColumnValueMapString(columnValueMapString, entity);
    }

    // -----------------------------------------------------
    //                                               Extract
    //                                               -------
    public String extractPrimaryKeyMapString(${glEntityInterfaceName} entity) {
        return MapStringUtil.extractPrimaryKeyMapString(entity);
    }

    public String extractPrimaryKeyMapString(${glEntityInterfaceName} entity, String startBrace, String endBrace, String delimiter, String equal) {
#if ($table.hasPrimaryKey())
        final ${myExtendedObjectClassName} myEntity = (${myExtendedObjectClassName})entity;
        final String mapMarkAndStartBrace = MAP_STRING_MAP_MARK + startBrace;
        final StringBuffer sb = new StringBuffer();
#foreach ($col in $table.PrimaryKey)
        helpAppendingColumnValueString(sb, delimiter, equal, "${col.Name}", myEntity.get${col.JavaName}());
#end

        sb.delete(0, delimiter.length()).insert(0, mapMarkAndStartBrace).append(endBrace);
        return sb.toString();
#else
        return extractColumnValueMapString(entity, startBrace, endBrace, delimiter, equal);
#end
    }

    public String extractColumnValueMapString(${glEntityInterfaceName} entity) {
        return MapStringUtil.extractColumnValueMapString(entity);
    }

    public String extractColumnValueMapString(${glEntityInterfaceName} entity, String startBrace, String endBrace, String delimiter, String equal) {
        final ${myExtendedObjectClassName} myEntity = (${myExtendedObjectClassName})entity;
        final String mapMarkAndStartBrace = MAP_STRING_MAP_MARK + startBrace;
        final StringBuffer sb = new StringBuffer();
#foreach ($col in $table.columns)
        helpAppendingColumnValueString(sb, delimiter, equal, "${col.Name}", myEntity.get${col.JavaName}());
#end

        sb.delete(0, delimiter.length()).insert(0, mapMarkAndStartBrace).append(endBrace);
        return sb.toString();
    }

    private void helpAppendingColumnValueString(StringBuffer sb, String delimiter, String equal, String colName, Object value) {
        sb.append(delimiter).append(colName).append(equal);
        sb.append(helpGettingColumnStringValue(value));
    }

#if (${table.hasAllCommonColumn()})
    public String extractCommonColumnValueMapString(${glEntityInterfaceName} entity) {
        final String startBrace = MAP_STRING_START_BRACE;
        final String endBrace = MAP_STRING_END_BRACE;
        final String delimiter = MAP_STRING_DELIMITER;
        final String equal = MAP_STRING_EQUAL;
        return extractCommonColumnValueMapString(entity, startBrace, endBrace, delimiter, equal);
    }

    public String extractCommonColumnValueMapString(${glEntityInterfaceName} entity, String startBrace, String endBrace, String delimiter, String equal) {
        final ${myExtendedObjectClassName} myEntity = (${myExtendedObjectClassName})entity;
        final String mapMarkAndStartBrace = MAP_STRING_MAP_MARK + startBrace;
        final StringBuffer sb = new StringBuffer();
  #foreach ($columnName in ${database.commonColumnNameList})
    #set ($filteredColumnName = ${database.filterCommonColumn(${columnName})})
    #set ($commonColumnMap = ${database.commonColumnMap})
    #set ($columnType = ${commonColumnMap.get(${columnName})})
    #set ($javaNative = ${database.convertJavaNativeByJdbcType(${columnType})})
    #set ($javaName = ${database.convertJavaNameByJdbcNameAsColumn(${filteredColumnName})})
    #set ($targetColumnName = ${table.findTargetColumnNameByCommonColumnName(${columnName})})
    #set ($col = $table.getColumnByFlexibleName($columnName))
    #if ($col.isJavaNativeDateObject())

        sb.append(delimiter).append("${targetColumnName}").append(equal);
        sb.append((myEntity.get${javaName}() != null ? helpFormatingDate(myEntity.get${javaName}()) : ""));
    #else

        sb.append(delimiter).append("${targetColumnName}").append(equal);
        sb.append((myEntity.get${javaName}() != null ? myEntity.get${javaName}().toString() : ""));
    #end
  #end

        sb.delete(0, delimiter.length()).insert(0, mapMarkAndStartBrace).append(endBrace);
        return sb.toString();
    }
#else

    public String extractCommonColumnValueMapString(${glEntityInterfaceName} entity) {
        return "map:{}";
    }

    public String extractCommonColumnValueMapString(${glEntityInterfaceName} entity, String startBrace, String endBrace, String delimiter, String equal) {
        return "map:" + startBrace + endBrace;
    }

#end

    // -----------------------------------------------------
    //                                               Convert
    //                                               -------
    public List<Object> convertToColumnValueList(${glEntityInterfaceName} entity) {
        return new ArrayList<Object>(convertToColumnValueMap(entity).values());
    }

    public Map<String, Object> convertToColumnValueMap(${glEntityInterfaceName} entity) {
        final ${myExtendedObjectClassName} myEntity = downcast(entity);
        final Map<String, Object> valueMap = new LinkedHashMap<String, Object>();
#foreach ($col in $table.columns)
        valueMap.put("${col.name}", myEntity.get${col.javaName}());
#end
        return valueMap;
    }

    public List<String> convertToColumnStringValueList(${glEntityInterfaceName} entity) {
        return new ArrayList<String>(convertToColumnStringValueMap(entity).values());
    }

    public Map<String, String> convertToColumnStringValueMap(${glEntityInterfaceName} entity) {
        final ${myExtendedObjectClassName} myEntity = downcast(entity);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
#foreach ($col in $table.columns)
        valueMap.put("${col.name}", helpGettingColumnStringValue(myEntity.get${col.JavaName}()));
#end
        return valueMap;
    }

    // ===================================================================================
    //                                                                        JDBC Support
    //                                                                        ============
    public String getPreparedInsertClause() {
        return getPreparedInsertClause(new PreparedInsertClauseOption());
    }

    public String getPreparedInsertClause(PreparedInsertClauseOption preparedInsertClauseOption) {
        if (preparedInsertClauseOption.getTablePrefix() != null) {
            final String tablePrefix = preparedInsertClauseOption.getTablePrefix();
            return "insert into " + tablePrefix + "${table.name}(${table.ColumnNameCommaString}) values(${table.insertClauseValuesAsQuetionMark})";
        }
        return "insert into ${table.name}(${table.ColumnNameCommaString}) values(${table.insertClauseValuesAsQuetionMark})";
    }

    // ===================================================================================
    //                                                               Entity Property Setup
    //                                                               =====================
    // It's very INTERNAL!
    protected Map<String, EntityPropertySetupper<${myExtendedObjectClassName}>> _entityPropertySetupperMap = new HashMap<String, EntityPropertySetupper<${myExtendedObjectClassName}>>();
    {
#foreach ($column in $table.columns)
        registerEntityPropertySetupper("$column.name", "$column.javaBeansRulePropertyName", new EntityProperty${column.javaName}Setupper(), _entityPropertySetupperMap);
#end
    }
    
    public boolean hasEntityPropertySetupper(String propertyName) {
        return _entityPropertySetupperMap.containsKey(propertyName);
    }

    public void setupEntityProperty(String propertyName, Object entity, Object value) {
        final EntityPropertySetupper<${myExtendedObjectClassName}> callback = _entityPropertySetupperMap.get(propertyName);
        if (callback == null) {
            String msg = "The propertyName was Not Found in the map of setupper of entity property:";
            msg = msg + " propertyName=" + propertyName + " _entityPropertySetupperMap.keySet()=" + _entityPropertySetupperMap.keySet();
            throw new IllegalStateException(msg);
        }
        callback.setup((${myExtendedObjectClassName})entity, value);
    }
    
#foreach ($column in $table.columns)
    public class EntityProperty${column.javaName}Setupper implements EntityPropertySetupper<${myExtendedObjectClassName}> {
        public void setup(${myExtendedObjectClassName} entity, Object value) { entity.set${column.javaName}((${column.javaNative})value); }
    }
#end
}
