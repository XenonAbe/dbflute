#set ($myClassName = "${glBehaviorWritableAbstractName}")

package ${glPackageBaseCommonBhv};

import ${glPackageBaseCommon}.${glEntityInterfaceName};
import ${glPackageBaseCommonCBean}.${glConditionBeanInterfaceName};
import ${glPackageBaseCommonHelper}.${glMapStringBuilderName};
import ${glPackageBaseCommonHelper}.${glMapStringBuilderImplName};

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * The abstract class of behavior-writable.
 * 
 * @author ${database.ClassAuthor}
 */
public abstract class ${myClassName} extends ${glBehaviorReadableAbstractName} implements ${glBehaviorWritableInterfaceName} {

    /** Log-instance. */
    private static final Log _log = LogFactory.getLog(${myClassName}.class);

    // =====================================================================================
    //                                                                           Constructor
    //                                                                           ===========
    /**
     * Constructor.
     */
    public ${myClassName}() {
    }

    // =====================================================================================
    //                                                                       Delegate Method
    //                                                                       ===============
    /**
     * ${database.ImplementComment}
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     * @return Inserted count.
     */
    public int callCreate(${glEntityInterfaceName} entity) {
        assertEntityNotNull(entity);// If this table use identity, the entity does not have primary-key.
        filterEntityOfInsert(entity);
        assertEntityOfInsert(entity);
        return getDaoWritable().create(entity);
    }

    /**
     * ${database.ImplementComment}
     * {modified only}
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     * @return Updated count.
     */
    public int callModify(${glEntityInterfaceName} entity) {
        assertEntityNotNullAndHasPrimaryKeyValue(entity);
        filterEntityOfUpdate(entity);
        assertEntityOfUpdate(entity);
        return getDaoWritable().modifyModifiedOnly(entity);
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     * @return Deleted count.
     */
    public int callRemove(${glEntityInterfaceName} entity) {
        assertEntityNotNullAndHasPrimaryKeyValue(entity);
        filterEntityOfDelete(entity);
        assertEntityOfDelete(entity);
        return getDaoWritable().remove(entity);
    }

    /**
     * Filter the entity of insert.
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     */
    protected void filterEntityOfInsert(${glEntityInterfaceName} entity) {
    }

    /**
     * Assert the entity of insert.
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     */
    protected void assertEntityOfInsert(${glEntityInterfaceName} entity) {
    }

    /**
     * Filter the entity of update.
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     */
    protected void filterEntityOfUpdate(${glEntityInterfaceName} entity) {
    }

    /**
     * Assert the entity of update.
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     */
    protected void assertEntityOfUpdate(${glEntityInterfaceName} entity) {
    }


    /**
     * Filter the entity of delete.
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     */
    protected void filterEntityOfDelete(${glEntityInterfaceName} entity) {
    }

    /**
     * Assert the entity of delete
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     */
    protected void assertEntityOfDelete(${glEntityInterfaceName} entity) {
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param entityList Entity-list that the type is entity-interface. (NotNull)
     * @return Inserted count.
     */
    public int callCreateList(java.util.List${database.filterGenericsString(${glEntityInterfaceName})} entityList) {
        assertListNotNullAndNotEmpty(entityList);
        for (final java.util.Iterator ite = entityList.iterator(); ite.hasNext(); ) {
            final ${glEntityInterfaceName} entity = (${glEntityInterfaceName})ite.next();
            filterEntityOfInsert(entity);
            assertEntityOfInsert(entity);
        }
        return getDaoWritable().createList(entityList);
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param entityList Entity-list that the type is entity-interface. (NotNull)
     * @return Updated count.
     */
    public int callModifyList(java.util.List${database.filterGenericsString(${glEntityInterfaceName})} entityList) {
        assertListNotNullAndNotEmpty(entityList);
        for (final java.util.Iterator ite = entityList.iterator(); ite.hasNext(); ) {
            final ${glEntityInterfaceName} entity = (${glEntityInterfaceName})ite.next();
            filterEntityOfUpdate(entity);
            assertEntityOfUpdate(entity);
        }
        return getDaoWritable().modifyList(entityList);
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param entityList Entity-list that the type is entity-interface. (NotNull)
     * @return Deleted count.
     */
    public int callRemoveList(java.util.List${database.filterGenericsString(${glEntityInterfaceName})} entityList) {
        assertListNotNullAndNotEmpty(entityList);
        for (final java.util.Iterator ite = entityList.iterator(); ite.hasNext(); ) {
            final ${glEntityInterfaceName} entity = (${glEntityInterfaceName})ite.next();
            filterEntityOfDelete(entity);
            assertEntityOfDelete(entity);
        }
        return getDaoWritable().removeList(entityList);
    }
#if ($database.isMakeDeprecated())

    /**
     * ${database.ImplementComment}
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     * @return Inserted count.
     * @deprecated Please use callCreate().
     */
    public int delegateCreate(${glEntityInterfaceName} entity) {
        assertEntityNotNull(entity);// If this table use identity, the entity does not have primary-key.
        filterEntityOfInsert(entity);
        assertEntityOfInsert(entity);
        return getDaoWritable().create(entity);
    }

    /**
     * ${database.ImplementComment}
     * {modified only}
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     * @return Updated count.
     * @deprecated Please use callModify().
     */
    public int delegateModify(${glEntityInterfaceName} entity) {
        assertEntityNotNullAndHasPrimaryKeyValue(entity);
        filterEntityOfUpdate(entity);
        assertEntityOfUpdate(entity);
        return getDaoWritable().modifyModifiedOnly(entity);
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     * @return Deleted count.
     * @deprecated Please use callRemove().
     */
    public int delegateRemove(${glEntityInterfaceName} entity) {
        assertEntityNotNullAndHasPrimaryKeyValue(entity);
        filterEntityOfDelete(entity);
        assertEntityOfDelete(entity);
        return getDaoWritable().remove(entity);
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param entityList Entity-list that the type is entity-interface. (NotNull)
     * @return Inserted count.
     * @deprecated Please use callCreateList().
     */
    public int delegateCreateList(java.util.List${database.filterGenericsString(${glEntityInterfaceName})} entityList) {
        assertListNotNullAndNotEmpty(entityList);
        for (final java.util.Iterator ite = entityList.iterator(); ite.hasNext(); ) {
            final ${glEntityInterfaceName} entity = (${glEntityInterfaceName})ite.next();
            filterEntityOfInsert(entity);
            assertEntityOfInsert(entity);
        }
        return getDaoWritable().createList(entityList);
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param entityList Entity-list that the type is entity-interface. (NotNull)
     * @return Updated count.
     * @deprecated Please use callModifyList().
     */
    public int delegateModifyList(java.util.List${database.filterGenericsString(${glEntityInterfaceName})} entityList) {
        assertListNotNullAndNotEmpty(entityList);
        for (final java.util.Iterator ite = entityList.iterator(); ite.hasNext(); ) {
            final ${glEntityInterfaceName} entity = (${glEntityInterfaceName})ite.next();
            filterEntityOfUpdate(entity);
            assertEntityOfUpdate(entity);
        }
        return getDaoWritable().modifyList(entityList);
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param entityList Entity-list that the type is entity-interface. (NotNull)
     * @return Deleted count.
     * @deprecated Please use callRemoveList().
     */
    public int delegateRemoveList(java.util.List${database.filterGenericsString(${glEntityInterfaceName})} entityList) {
        assertListNotNullAndNotEmpty(entityList);
        for (final java.util.Iterator ite = entityList.iterator(); ite.hasNext(); ) {
            final ${glEntityInterfaceName} entity = (${glEntityInterfaceName})ite.next();
            filterEntityOfDelete(entity);
            assertEntityOfDelete(entity);
        }
        return getDaoWritable().removeList(entityList);
    }
#end

    // =====================================================================================
    //                                                                   Basic Entity Update
    //                                                                   ===================
    /**
     * Create.
     * 
     * @param entity Entity. (NotNull)
     */
    public void create(${glPackageBaseCommon}.${glEntityInterfaceName} entity) {
        assertEntityNotNull(entity);
        callCreate(entity);
    }

    /**
     * Modify.
     * 
     * @param entity Entity. (NotNull)
     */
    public void modify(${glPackageBaseCommon}.${glEntityInterfaceName} entity) {
        assertEntityNotNull(entity);
        final int modifiedCount = callModify(entity);
        if (modifiedCount != 1) {
            throw new org.seasar.dao.NotSingleRowUpdatedRuntimeException(entity, modifiedCount);
        }
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param entity Entity having primary-key value. (NotNull)
     * @exception ${glPackageBaseCommonException}.${glRecordHasAlreadyBeenDeletedException}
     */
    public void modifyAfterSelect(${glEntityInterfaceName} entity) {
        assertEntityNotNullAndHasPrimaryKeyValue(entity);
        final ${glConditionBeanInterfaceName} cb = newConditionBean();
        cb.acceptPrimaryKeyMapString(entity.extractPrimaryKeyMapString());
        final ${glEntityInterfaceName} currentEntity = readEntityWithDeletedCheck(cb);
        mergeEntity(entity, currentEntity);
        modify(currentEntity);
    }

    /**
     * Create or modify after select.
     * {modify: modified only}
     * 
     * @param entity Entity. This must contain primary-key value at least(Except use identity). (NotNull)
     */
    public void createOrModifyAfterSelect(${glPackageBaseCommon}.${glEntityInterfaceName} entity) {
        assertEntityNotNull(entity);
        if (!entity.hasPrimaryKeyValue()) {
            create(entity);
            return;
        }
        ${glPackageBaseCommon}.${glEntityInterfaceName} currentEntity = null;
        try {
            final ${glConditionBeanInterfaceName} cb = newConditionBean();
            cb.acceptPrimaryKeyMapString(entity.extractPrimaryKeyMapString());
            currentEntity = readEntityWithDeletedCheck(cb);
        } catch (${glPackageBaseCommonException}.${glRecordHasAlreadyBeenDeletedException} e) {
            create(entity);
            return;
        }
        assertEntityNotNullAndHasPrimaryKeyValue(entity);
        mergeEntity(entity, currentEntity);
        modify(entity);
    }
#if ($database.isMakeBehaviorForUpdate())

    /**
     * ${database.ImplementComment}
     * 
     * @param entity Entity having primary-key value. (NotNull)
     * @exception ${glPackageBaseCommonException}.${glRecordHasAlreadyBeenDeletedException}
     */
    public void modifyAfterSelectForUpdate(${glEntityInterfaceName} entity) {
        assertEntityNotNullAndHasPrimaryKeyValue(entity);
        final ${glConditionBeanInterfaceName} cb = newConditionBean();
        cb.acceptPrimaryKeyMapString(entity.extractPrimaryKeyMapString());
        cb.lockForUpdate();
        final ${glEntityInterfaceName} currentEntity = readEntityWithDeletedCheck(cb);
        mergeEntity(entity, currentEntity);
        modify(currentEntity);
    }

    /**
     * Create or modify after select-for-update.
     * {modify: modified only}
     * 
     * @param entity Entity. This must contain primary-key value at least(Except use identity). (NotNull)
     */
    public void createOrModifyAfterSelectForUpdate(${glPackageBaseCommon}.${glEntityInterfaceName} entity) {
        assertEntityNotNull(entity);
        if (!entity.hasPrimaryKeyValue()) {
            create(entity);
            return;
        }
        ${glPackageBaseCommon}.${glEntityInterfaceName} currentEntity = null;
        try {
            final ${glConditionBeanInterfaceName} cb = newConditionBean();
            cb.acceptPrimaryKeyMapString(entity.extractPrimaryKeyMapString());
            cb.lockForUpdate();
            currentEntity = readEntityWithDeletedCheck(cb);
        } catch (${glPackageBaseCommonException}.${glRecordHasAlreadyBeenDeletedException} e) {
            create(entity);
            return;
        }
        assertEntityNotNullAndHasPrimaryKeyValue(entity);
        mergeEntity(entity, currentEntity);
        modify(currentEntity);
    }
#end

    /**
     * Merge entity.
     * Copy the column data of sourceEntity that the setter has been invoked to destinationEntity.
     * 
     * @param sourceEntity Source entity. (NotNull)
     * @param destinationEntity Destination entity. (NotNull)
     */
    abstract protected void mergeEntity(${glEntityInterfaceName} sourceEntity, ${glEntityInterfaceName} destinationEntity);

    /**
     * Remove.
     * 
     * @param entity Entity. (NotNull)
     * @return Removed count.
     */
    public void remove(${glPackageBaseCommon}.${glEntityInterfaceName} entity) {
        assertEntityNotNull(entity);
        callRemove(entity);
    }

    // =====================================================================================
    //                                                                    Basic Batch Update
    //                                                                    ==================
    /**
     * Create list.
     * 
     * @param entityList Entity-list. (NotNull and NotEmpty)
     * @return Created count.
     */
    public int createList(java.util.List${database.filterGenericsString(${glEntityInterfaceName})} entityList) {
        assertListNotNullAndNotEmpty(entityList);
        return callCreateList(entityList);
    }

    /**
     * Modify list.
     * 
     * @param entityList Entity-list. (NotNull and NotEmpty)
     * @return Modified count.
     */
    public int modifyList(java.util.List${database.filterGenericsString(${glEntityInterfaceName})} entityList) {
        assertListNotNullAndNotEmpty(entityList);
        return callModifyList(entityList);
    }

    /**
     * Remove list.
     * 
     * @param entityList Entity-list. (NotNull and NotEmpty)
     * @return Removed count.
     */
    public int removeList(java.util.List${database.filterGenericsString(${glEntityInterfaceName})} entityList) {
        assertListNotNullAndNotEmpty(entityList);
        return callRemoveList(entityList);
    }

    // =====================================================================================
    //                                                                        Separated File
    //                                                                        ==============

    /**
     * Reflect(insert or update) from separated-file.
     * 
     * @param filename Name of the file. (NotNull and NotEmpty)
     * @param encoding Encoding of the file. (NotNull and NotEmpty)
     * @param delimiter Delimiter of the file. (NotNull and NotEmpty)
     * @param batchCount Batch-count for transaction. If this value is 0, all records are done in one transaction.
     * @param isErrorContinue If true, this method continue in spite of throwing the exception.   
     * @return The list of InsertOrUpdateExceptionResult. (NotNull)
     * @throws java.io.FileNotFoundException
     * @throws java.io.IOException
     */
    public java.util.List${database.filterGenericsString('OneEntityExceptionResult')} reflectFromSeparatedFile(
            String filename, String encoding,
            String delimiter, int batchCount, boolean isErrorContinue
            ) throws java.io.FileNotFoundException, java.io.IOException {
        assertStringNotNullAndNotTrimmedEmpty("filename", filename);
        assertStringNotNullAndNotTrimmedEmpty("encoding", encoding);
        assertObjectNotNull("delimiter", delimiter);
        final java.util.List${database.filterGenericsString('OneEntityExceptionResult')} exceptionList = new java.util.ArrayList${database.filterGenericsString('OneEntityExceptionResult')}();

        java.io.FileInputStream fis = null;
        java.io.InputStreamReader ir = null;
        java.io.BufferedReader br = null;
        try {
            fis = new java.io.FileInputStream(filename);
            ir = new java.io.InputStreamReader(fis, encoding);
            br = new java.io.BufferedReader(ir);

            final ${glMapStringBuilderName} builder = new ${glMapStringBuilderImplName}();
            builder.setMsMapMark(MAP_STRING_MAP_MARK);
            builder.setMsStartBrace(MAP_STRING_START_BRACE);
            builder.setMsEndBrace(MAP_STRING_END_BRACE);
            builder.setMsDelimiter(MAP_STRING_DELIMITER);
            builder.setMsEqual(MAP_STRING_EQUAL);
            final java.util.List${database.filterGenericsString(${glEntityInterfaceName})} entityList = new java.util.ArrayList${database.filterGenericsString(${glEntityInterfaceName})}();
            int count = 0;
            while (true) {
                ++count;

                final String lineString = br.readLine();
                if (lineString == null) {
                    if (entityList.size() > 0) {
                        final java.util.List${database.filterGenericsString('OneEntityExceptionResult')} tmpList = reflectAfterSelectNewTx(entityList, isErrorContinue);
                        exceptionList.addAll(tmpList);
                        entityList.clear();
                    }
                    break;
                }
                if (count == 1) {
                    builder.setColumnNames(lineString.split(delimiter));
                    continue;
                }

                final String mapString = builder.buildByDelimiter(lineString, delimiter);
                final ${glEntityInterfaceName} entity = getDBMeta().newEntity();
                entity.acceptColumnValueMapString(mapString);
                entityList.add(entity);

                if (entityList.size() == batchCount) {
                    final java.util.List${database.filterGenericsString('OneEntityExceptionResult')} tmpList = reflectAfterSelectNewTx(entityList, isErrorContinue);
                    exceptionList.addAll(tmpList);
                    entityList.clear();
                }
            }
        } catch (java.io.FileNotFoundException e) {
            throw e;
        } catch (java.io.IOException e) {
            throw e;
        } finally {
            try {
                if (fis != null) {
                    fis.close();
                }
                if (ir != null) {
                    ir.close();
                }
                if (br != null) {
                    br.close();
                }
            } catch (java.io.IOException ignored) {
                _log.warn("File-close threw the exception: ", ignored);
            }
        }
        return exceptionList;
    }

    /**
     * Reflect(insert or update) from separated-file.
     * 
     * @param entityList The list of entity that is reflection target. (NotNull)
     * @param isErrorContinue If true, this method continue in spite of throwing the exception.
     * @return The list of InsertOrUpdateExceptionResult. (NotNull)
     */
    public java.util.List${database.filterGenericsString('OneEntityExceptionResult')} reflectAfterSelectNewTx(java.util.List${database.filterGenericsString(${glEntityInterfaceName})} entityList,
            boolean isErrorContinue) {
        final java.util.List${database.filterGenericsString('OneEntityExceptionResult')} exceptionList = new java.util.ArrayList${database.filterGenericsString('OneEntityExceptionResult')}();
        for (final java.util.Iterator ite = entityList.iterator(); ite.hasNext(); ) {
            final ${glEntityInterfaceName} entity = (${glEntityInterfaceName})ite.next();
            try {
                createOrModifyAfterSelect(entity);
            } catch (RuntimeException e) {
                if (isErrorContinue) {
                    final OneEntityExceptionResult result = new OneEntityExceptionResult();
                    result.setPrimaryKeyMapString(entity.extractPrimaryKeyMapString());
                    result.setEntity(entity);
                    result.setException(e);
                    exceptionList.add(result);
                    continue;
                }
                throw e;
            }
        }
        return exceptionList;
    }
}
