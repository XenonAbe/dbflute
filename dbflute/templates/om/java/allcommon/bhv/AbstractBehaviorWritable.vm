${database.allClassCopyright}package ${glPackageBaseCommonBhv};

#set ($myClassName = "${glBehaviorWritableAbstractName}")

import ${glPackageBaseCommon}.${glEntityInterfaceName};
import ${glPackageBaseCommonCBean}.${glConditionBeanInterfaceName};
import ${glPackageBaseCommonDBMeta}.${glDBMetaInterfaceName};
import ${glPackageBaseCommonHelper}.${glMapStringBuilderName};
import ${glPackageBaseCommonHelper}.${glMapStringBuilderImplName};

import ${glPackageBaseCommonBhvBatch}.${glTokenFileReflectionOptionName};
import ${glPackageBaseCommonBhvBatch}.${glTokenFileReflectionResultName};
import ${glPackageBaseCommonBhvBatch}.${glTokenFileReflectionFailureName};

import ${glPackageBaseCommonHelperTokenFile}.${glFileTokenName};
import ${glPackageBaseCommonHelperTokenFile}.${glFileTokenizingCallbackName};
import ${glPackageBaseCommonHelperTokenFile}.${glFileTokenizingRowResourceName};
import ${glPackageBaseCommonHelperTokenFile}.${glFileTokenizingHeaderInfoName};
import ${glPackageBaseCommonHelperTokenFile}.${glFileTokenizingOptionName};
import ${glPackageBaseCommonHelperTokenFileImpl}.${glFileTokenImplName};

/**
 * The abstract class of behavior-writable.
 * 
 * @author ${database.ClassAuthor}
 */
public abstract class ${myClassName} extends ${glBehaviorReadableAbstractName} implements ${glBehaviorWritableInterfaceName} {
#if ($database.isCommonColumnInterceptingOnBehaviorFilter())

    /** Log instance. */
    private static final org.apache.commons.logging.Log _log = org.apache.commons.logging.LogFactory.getLog(${myClassName}.class);
#end

#if ($database.hasCommonColumnSetupResource())
    // =====================================================================================
    //                                                                             Attribute
    //                                                                             =========
#foreach ($resource in ${database.commonColumnSetupResourceList})
    /** The property of ${resource.propertyName}. */
    protected ${resource.className} ${resource.propertyVariableName};

    /**
     * @return The value of ${resource.propertyName}.
     */
    public ${resource.className} get${resource.propertyNameInitCap}() {
        return ${resource.propertyVariableName};
    }

    /**
     * @param ${resource.propertyName} The value of ${resource.propertyName}.
     */
    public void set${resource.propertyNameInitCap}(${resource.className} ${resource.propertyName}) {
        this.${resource.propertyVariableName} = ${resource.propertyName};
    }

#end
#end
    // =====================================================================================
    //                                                                           Constructor
    //                                                                           ===========
    /**
     * Constructor.
     */
    public ${myClassName}() {
    }

    // =====================================================================================
    //                                                                       Delegate Method
    //                                                                       ===============
    /**
     * ${database.ImplementComment}
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     * @return Inserted count.
     */
    protected int callCreate(${glEntityInterfaceName} entity) {
        assertEntityNotNull(entity);// If this table use identity, the entity does not have primary-key.
        filterEntityOfInsert(entity);
        assertEntityOfInsert(entity);
        return getDaoWritable().create(entity);
    }

    /**
     * ${database.ImplementComment}
     * {modified only}
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     * @return Updated count.
     */
    protected int callModify(${glEntityInterfaceName} entity) {
        assertEntityNotNullAndHasPrimaryKeyValue(entity);
        filterEntityOfUpdate(entity);
        assertEntityOfUpdate(entity);
        return getDaoWritable().modifyModifiedOnly(entity);
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     * @return Deleted count.
     */
    protected int callRemove(${glEntityInterfaceName} entity) {
        assertEntityNotNullAndHasPrimaryKeyValue(entity);
        filterEntityOfDelete(entity);
        assertEntityOfDelete(entity);
        return getDaoWritable().remove(entity);
    }

    /**
     * Filter the entity of insert.
     * 
     * @param targetEntity Target entity that the type is entity-interface. (NotNull)
     */
    protected void filterEntityOfInsert(${glEntityInterfaceName} targetEntity) {
#if ($database.isAvailableBehaviorInsertSequenceInjection())
        injectSequenceToPrimaryKeyIfNeeds(targetEntity);
#end
#if ($database.isCommonColumnInterceptingOnBehaviorFilter())
        if (!(targetEntity instanceof ${glPackageBaseCommon}.${glEntityDefinedCommonColumnInterfaceName})) {
            return;
        }
        final ${glPackageBaseCommon}.${glEntityDefinedCommonColumnInterfaceName} entity = (${glPackageBaseCommon}.${glEntityDefinedCommonColumnInterfaceName})targetEntity;
        if (_log.isDebugEnabled()) {
            String msg = "...Filtering entity of INSERT about the column columns of " + getTableDbName();
            msg = msg + ": entity=" + entity.getDBMeta().extractPrimaryKeyMapString(entity);
            _log.debug(msg);
            _log.debug("  before setup : " + entity.getDBMeta().extractCommonColumnValueMapString(entity));
        }
#foreach ($columnName in ${database.commonColumnNameList})
  #set ($filteredColumnName = ${database.filterCommonColumn(${columnName})})
  #set ($entityCommonColumnMap = ${database.commonColumnMap})
  #set ($columnType = ${entityCommonColumnMap.get(${columnName})})
  #set ($javaNative = ${database.convertJavaNativeByJdbcType(${columnType})})
  #set ($javaName = ${database.convertJavaNameByJdbcNameAsColumn(${filteredColumnName})})
  #set ($uncapitalisedJavaName = ${database.convertUncapitalisedJavaNameByJdbcNameAsColumn(${filteredColumnName})})
  #if (${database.containsValidColumnNameKeyCommonColumnSetupBeforeInsertInterceptorLogicMap(${columnName})})
    #set ($logic = ${database.getCommonColumnSetupBeforeInsertInterceptorLogicByColumnName(${columnName})})
    #if ($database.isCommonColumnSetupInvokingLogic($logic))
      #set ($filteredLogic = $database.removeCommonColumnSetupInvokingMark($logic))

        ${filteredLogic}
        if (_log.isDebugEnabled()) {
            _log.debug("    ${filteredColumnName} has been set up: invoking=${filteredLogic}");
        }
    #else

        final ${javaNative} ${uncapitalisedJavaName} = ${logic};
        entity.set${javaName}(${uncapitalisedJavaName});
        if (_log.isDebugEnabled()) {
            _log.debug("    ${filteredColumnName} has been set up: value=" + ${uncapitalisedJavaName});
        }
    #end
  #end
#end

        if (_log.isDebugEnabled()) {
            _log.debug("  after setup  : " + entity.getDBMeta().extractCommonColumnValueMapString(entity));
        }
#end
    }

    /**
     * Assert the entity of insert.
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     */
    protected void assertEntityOfInsert(${glEntityInterfaceName} entity) {
    }

    /**
     * Filter the entity of update.
     * 
     * @param targetEntity Target entity that the type is entity-interface. (NotNull)
     */
    protected void filterEntityOfUpdate(${glEntityInterfaceName} targetEntity) {
#if ($database.isCommonColumnInterceptingOnBehaviorFilter())
        if (!(targetEntity instanceof ${glPackageBaseCommon}.${glEntityDefinedCommonColumnInterfaceName})) {
            return;
        }
        final ${glPackageBaseCommon}.${glEntityDefinedCommonColumnInterfaceName} entity = (${glPackageBaseCommon}.${glEntityDefinedCommonColumnInterfaceName})targetEntity;
        if (_log.isDebugEnabled()) {
            String msg = "...Filtering entity of UPDATE about the column columns of " + getTableDbName();
            msg = msg + ": entity=" + entity.getDBMeta().extractPrimaryKeyMapString(entity);
            _log.debug(msg);
            _log.debug("  before setup : " + entity.getDBMeta().extractCommonColumnValueMapString(entity));
        }
#foreach ($columnName in ${database.CommonColumnNameList})
  #set ($filteredColumnName = ${database.filterCommonColumn(${columnName})})
  #set ($entityCommonColumnMap = ${database.CommonColumnMap})
  #set ($columnType = ${entityCommonColumnMap.get(${columnName})})
  #set ($javaNative = ${database.convertJavaNativeByJdbcType(${columnType})})
  #set ($javaName = ${database.convertJavaNameByJdbcNameAsColumn(${filteredColumnName})})
  #set ($uncapitalisedJavaName = ${database.convertUncapitalisedJavaNameByJdbcNameAsColumn(${filteredColumnName})})
  #if (${database.containsValidColumnNameKeyCommonColumnSetupBeforeUpdateInterceptorLogicMap(${columnName})})
    #set ($logic = ${database.getCommonColumnSetupBeforeUpdateInterceptorLogicByColumnName(${columnName})})
    #if ($database.isCommonColumnSetupInvokingLogic($logic))
      #set ($filteredLogic = $database.removeCommonColumnSetupInvokingMark($logic))

        ${filteredLogic}
        if (_log.isDebugEnabled()) {
            _log.debug("    ${filteredColumnName} has been set up: invoking=${filteredLogic}");
        }
    #else

        final ${javaNative} ${uncapitalisedJavaName} = ${logic};
        entity.set${javaName}(${uncapitalisedJavaName});
        if (_log.isDebugEnabled()) {
            _log.debug("    ${filteredColumnName} has been set up: value=" + ${uncapitalisedJavaName});
        }
    #end
  #end
#end

        if (_log.isDebugEnabled()) {
            _log.debug("  after setup  : " + entity.getDBMeta().extractCommonColumnValueMapString(entity));
        }
#end
    }

    /**
     * Assert the entity of update.
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     */
    protected void assertEntityOfUpdate(${glEntityInterfaceName} entity) {
    }

    /**
     * Filter the entity of delete.
     * 
     * @param targetEntity Target entity that the type is entity-interface. (NotNull)
     */
    protected void filterEntityOfDelete(${glEntityInterfaceName} targetEntity) {
#if ($database.isCommonColumnInterceptingOnBehaviorFilter())
        if (!(targetEntity instanceof ${glPackageBaseCommon}.${glEntityDefinedCommonColumnInterfaceName})) {
            return;
        }
        final ${glPackageBaseCommon}.${glEntityDefinedCommonColumnInterfaceName} entity = (${glPackageBaseCommon}.${glEntityDefinedCommonColumnInterfaceName})targetEntity;
        if (_log.isDebugEnabled()) {
            String msg = "[Behavior] ...Filtering entity of DELETE about the column columns of " + getTableDbName();
            msg = msg + ": entity=" + entity.getDBMeta().extractPrimaryKeyMapString(entity);
            _log.debug(msg);
            _log.debug("  before setup : " + entity.getDBMeta().extractCommonColumnValueMapString(entity));
        }
#foreach ($columnName in ${database.CommonColumnNameList})
  #set ($filteredColumnName = ${database.filterCommonColumn(${columnName})})
  #set ($entityCommonColumnMap = ${database.CommonColumnMap})
  #set ($columnType = ${entityCommonColumnMap.get(${columnName})})
  #set ($javaNative = ${database.convertJavaNativeByJdbcType(${columnType})})
  #set ($javaName = ${database.convertJavaNameByJdbcNameAsColumn(${filteredColumnName})})
  #set ($uncapitalisedJavaName = ${database.convertUncapitalisedJavaNameByJdbcNameAsColumn(${filteredColumnName})})
  #if (${database.containsValidColumnNameKeyCommonColumnSetupBeforeDeleteInterceptorLogicMap(${columnName})})
    #set ($logic = ${database.getCommonColumnSetupBeforeDeleteInterceptorLogicByColumnName(${columnName})})
    #if ($database.isCommonColumnSetupInvokingLogic($logic))
      #set ($filteredLogic = $database.removeCommonColumnSetupInvokingMark($logic))

        ${filteredLogic}
        if (_log.isDebugEnabled()) {
            _log.debug("    ${filteredColumnName} has been set up: invoking=${filteredLogic}");
        }
    #else

        final ${javaNative} ${uncapitalisedJavaName} = ${logic};
        entity.set${javaName}(${uncapitalisedJavaName});
        if (_log.isDebugEnabled()) {
            _log.debug("    ${filteredColumnName} has been set up: value=" + ${uncapitalisedJavaName});
        }
    #end
  #end
#end

        if (_log.isDebugEnabled()) {
            _log.debug("  after setup  : " + entity.getDBMeta().extractCommonColumnValueMapString(entity));
        }
#end
    }

    /**
     * Assert the entity of delete
     * 
     * @param entity Entity that the type is entity-interface. (NotNull)
     */
    protected void assertEntityOfDelete(${glEntityInterfaceName} entity) {
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param entityList Entity-list that the type is entity-interface. (NotNull)
     * @return Inserted count.
     */
    public int callCreateList(java.util.List${database.filterGenericsString(${glEntityInterfaceName})} entityList) {
        assertListNotNullAndNotEmpty(entityList);
        for (final java.util.Iterator ite = entityList.iterator(); ite.hasNext(); ) {
            final ${glEntityInterfaceName} entity = (${glEntityInterfaceName})ite.next();
            assertEntityNotNull(entity);// If this table use identity, the entity does not have primary-key.
            filterEntityOfInsert(entity);
            assertEntityOfInsert(entity);
        }
        return getDaoWritable().createList(entityList);
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param entityList Entity-list that the type is entity-interface. (NotNull)
     * @return Updated count.
     */
    public int callModifyList(java.util.List${database.filterGenericsString(${glEntityInterfaceName})} entityList) {
        assertListNotNullAndNotEmpty(entityList);
        for (final java.util.Iterator ite = entityList.iterator(); ite.hasNext(); ) {
            final ${glEntityInterfaceName} entity = (${glEntityInterfaceName})ite.next();
            assertEntityNotNull(entity);// If this table use identity, the entity does not have primary-key.
            filterEntityOfUpdate(entity);
            assertEntityOfUpdate(entity);
        }
        return getDaoWritable().modifyList(entityList);
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param entityList Entity-list that the type is entity-interface. (NotNull)
     * @return Deleted count.
     */
    public int callRemoveList(java.util.List${database.filterGenericsString(${glEntityInterfaceName})} entityList) {
        assertListNotNullAndNotEmpty(entityList);
        for (final java.util.Iterator ite = entityList.iterator(); ite.hasNext(); ) {
            final ${glEntityInterfaceName} entity = (${glEntityInterfaceName})ite.next();
            assertEntityNotNull(entity);// If this table use identity, the entity does not have primary-key.
            filterEntityOfDelete(entity);
            assertEntityOfDelete(entity);
        }
        return getDaoWritable().removeList(entityList);
    }

    protected void assertEntityHasVersionNoValue(${glEntityInterfaceName} entity) {
        if (!getDBMeta().hasVersionNo()) {
            return;
        }
        if (entity.hasVersionNoValue()) {
            return;
        }
        String msg = "Not found the value of version no: " + entity;
        throw new IllegalStateException(msg);
    }

    protected void assertEntityHasUpdateDateValue(${glEntityInterfaceName} entity) {
        if (!getDBMeta().hasUpdateDate()) {
            return;
        }
        if (entity.hasUpdateDateValue()) {
            return;
        }
        String msg = "Not found the value of update date: " + entity;
        throw new IllegalStateException(msg);
    }

    // =====================================================================================
    //                                                                   Basic Entity Update
    //                                                                   ===================
    /**
     * Create.
     * 
     * @param entity Entity. (NotNull)
     */
    public void create(${glEntityInterfaceName} entity) {
        doCreate(entity);
    }

    abstract protected void doCreate(${glEntityInterfaceName} entity);

    /**
     * Modify.
     * 
     * @param entity Entity. (NotNull)
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException}
     */
    public void modify(${glEntityInterfaceName} entity) {
        doModify(entity);
    }

    abstract protected void doModify(${glEntityInterfaceName} entity);

    /**
     * Modify non strict.
     * 
     * @param entity Entity. (NotNull)
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException}
     */
    public void modifyNonstrict(${glEntityInterfaceName} entity) {
        doModifyNonstrict(entity);
    }

    abstract protected void doModifyNonstrict(${glEntityInterfaceName} entity);

#if ($database.isMakeRecentlyDeprecated())
    /**
     * ${database.ImplementComment}
     * 
     * @param entity Entity having primary-key value. (NotNull)
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}
     * @deprecated Thie method is old style and has wrong performance. Please use modify().
     */
    public void modifyAfterSelect(${glEntityInterfaceName} entity) {
        doModifyAfterSelect(entity);
    }

    /**
     * @param entity Entity having primary-key value. (NotNull)
     * @deprecated Thie method is old style and has wrong performance. Please use modify().
     */
    abstract protected void doModifyAfterSelect(${glEntityInterfaceName} entity);
#end

    /**
     * ${database.ImplementComment}
     * 
     * @param entity Entity. This must contain primary-key value at least(Except use identity). (NotNull)
     */
    public void createOrModify(${glPackageBaseCommon}.${glEntityInterfaceName} entity) {
        assertEntityNotNull(entity);
        doCreateOrUpdate(entity);
    }

    abstract protected void doCreateOrUpdate(${glEntityInterfaceName} entity);

    /**
     * ${database.ImplementComment}
     * 
     * @param entity Entity. This must contain primary-key value at least(Except use identity). (NotNull)
     */
    public void createOrModifyNonstrict(${glPackageBaseCommon}.${glEntityInterfaceName} entity) {
        assertEntityNotNull(entity);
        doCreateOrUpdateNonstrict(entity);
    }

    abstract protected void doCreateOrUpdateNonstrict(${glEntityInterfaceName} entity);

#if ($database.isMakeRecentlyDeprecated())
    /**
     * Create or modify after select. <br />
     * {modify: modified only}
     * 
     * @param entity Entity. This must contain primary-key value at least(Except use identity). (NotNull)
     * @deprecated Thie method is old style and has wrong performance. Please use createOrModify().
     */
    public void createOrModifyAfterSelect(${glPackageBaseCommon}.${glEntityInterfaceName} entity) {
        assertEntityNotNull(entity);
        doCreateOrModifyAfterSelect(entity);
    }

    /**
     * @param entity Entity. This must contain primary-key value at least(Except use identity). (NotNull)
     * @deprecated Thie method is old style and has wrong performance. Please use createOrModify().
     */
    abstract protected void doCreateOrModifyAfterSelect(${glEntityInterfaceName} entity);

    /**
     * Merge entity.
     * Copy the column data of sourceEntity that the setter has been invoked to destinationEntity.
     * 
     * @param sourceEntity Source entity. (NotNull)
     * @param destinationEntity Destination entity. (NotNull)
     * @deprecated Thie method is old style and has wrong performance.
     */
    abstract protected void mergeEntity(${glEntityInterfaceName} sourceEntity, ${glEntityInterfaceName} destinationEntity);
#end

    /**
     * Remove.
     * 
     * @param entity Entity. (NotNull)
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException}
     */
    public void remove(${glPackageBaseCommon}.${glEntityInterfaceName} entity) {
        assertEntityNotNull(entity);
        callRemove(entity);
    }

    abstract protected void doRemove(${glEntityInterfaceName} entity);

#if ($database.isMakeRecentlyDeprecated())
    /**
     * Remove after select.
     * 
     * @param entity Entity. This must contain primary-key value at least. (NotNull)
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}
     * @deprecated Thie method is old style and has wrong performance. Please use remove().
     */
    public void removeAfterSelect(${glEntityInterfaceName} entity) {
        assertEntityNotNullAndHasPrimaryKeyValue(entity);
        doRemoveAfterSelect(entity);
    }

    /**
     * @param entity Entity. This must contain primary-key value at least. (NotNull)
     * @deprecated Thie method is old style and has wrong performance. Please use remove().
     */
    abstract protected void doRemoveAfterSelect(${glEntityInterfaceName} entity);
#end

    // =====================================================================================
    //                                                   Basic Entity Update Internal Helper
    //                                                   ===================================
    // -----------------------------------------------------
    //                                                Update
    //                                                ------
    protected <ENTITY_TYPE extends ${glEntityInterfaceName}> void helpUpdateInternally(ENTITY_TYPE entity, InternalUpdateCallback<ENTITY_TYPE> callback) {
        assertEntityNotNull(entity);
        assertEntityHasVersionNoValue(entity);
        assertEntityHasUpdateDateValue(entity);
        final int updatedCount = callback.callbackDelegateUpdate(entity);
        if (updatedCount == 0) {
            throw new ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}(entity.toString());
        } else if (updatedCount > 1) {
            String msg = "updatedCount=" + updatedCount + ": " + entity.toString();
            throw new ${glPackageBaseCommonException}.${glEntityDuplicatedException}(msg);
        }
    }

    protected static interface InternalUpdateCallback<ENTITY_TYPE extends ${glEntityInterfaceName}> {
        public int callbackDelegateUpdate(ENTITY_TYPE entity);
    }

    protected <ENTITY_TYPE extends ${glEntityInterfaceName}> void helpUpdateNonstrictInternally(ENTITY_TYPE entity, InternalUpdateNonstrictCallback<ENTITY_TYPE> callback) {
        assertEntityNotNull(entity);
        final int updatedCount = callback.callbackDelegateUpdateNonstrict(entity);
        if (updatedCount == 0) {
            throw new ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}(entity.toString());
        } else if (updatedCount > 1) {
            String msg = "updatedCount=" + updatedCount + ": " + entity.toString();
            throw new ${glPackageBaseCommonException}.${glEntityDuplicatedException}(msg);
        }
    }

    protected static interface InternalUpdateNonstrictCallback<ENTITY_TYPE extends ${glEntityInterfaceName}> {
        public int callbackDelegateUpdateNonstrict(ENTITY_TYPE entity);
    }

    // -----------------------------------------------------
    //                                        InsertOrUpdate
    //                                        --------------
    protected <ENTITY_TYPE extends ${glEntityInterfaceName}, CB_TYPE extends ${glConditionBeanInterfaceName}>
            void helpInsertOrUpdateInternally(ENTITY_TYPE entity, InternalInsertOrUpdateCallback<ENTITY_TYPE, CB_TYPE> callback) {
        assertEntityNotNull(entity);
        if (!entity.hasPrimaryKeyValue()) {
            callback.callbackInsert(entity);
        } else {
            RuntimeException exception = null;
            try {
                callback.callbackUpdate(entity);
            } catch (${glPackageBaseCommonException}.${glEntityAlreadyUpdatedException} e) {
                if (e.getRows() == 0) {
                    exception = e;
                }
            } catch (${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} e) {
                exception = e;
            }
            if (exception != null) {
                final CB_TYPE cb = callback.callbackNewMyConditionBean();
                cb.acceptPrimaryKeyMapString(getDBMeta().extractPrimaryKeyMapString(entity));
                if (callback.callbackSelectCount(cb) == 0) {
                    callback.callbackInsert(entity);
                } else {
                    throw exception;
                }
            }
        }
    }

    protected static interface InternalInsertOrUpdateCallback<ENTITY_TYPE extends ${glEntityInterfaceName}, CB_TYPE extends ${glConditionBeanInterfaceName}> {
        public void callbackInsert(ENTITY_TYPE entity);
        public void callbackUpdate(ENTITY_TYPE entity);
        public CB_TYPE callbackNewMyConditionBean();
        public int callbackSelectCount(CB_TYPE cb);
    }

    protected <ENTITY_TYPE extends ${glEntityInterfaceName}> void helpInsertOrUpdateInternally(ENTITY_TYPE entity, InternalInsertOrUpdateNonstrictCallback<ENTITY_TYPE> callback) {
        assertEntityNotNull(entity);
        if (!entity.hasPrimaryKeyValue()) {
            callback.callbackInsert(entity);
        } else {
            try {
                callback.callbackUpdateNonstrict(entity);
            } catch (${glPackageBaseCommonException}.${glEntityAlreadyUpdatedException} e) {
                callback.callbackInsert(entity);
            } catch (${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} e) {
                callback.callbackInsert(entity);
            }
        }
    }

    protected static interface InternalInsertOrUpdateNonstrictCallback<ENTITY_TYPE extends ${glEntityInterfaceName}> {
        public void callbackInsert(ENTITY_TYPE entity);
        public void callbackUpdateNonstrict(ENTITY_TYPE entity);
    }

    // -----------------------------------------------------
    //                                                Delete
    //                                                ------
    protected <ENTITY_TYPE extends ${glEntityInterfaceName}> void helpDeleteInternally(ENTITY_TYPE entity, InternalDeleteCallback<ENTITY_TYPE> callback) {
        assertEntityNotNull(entity);
        assertEntityHasVersionNoValue(entity);
        assertEntityHasUpdateDateValue(entity);
        final int deletedCount = callback.callbackDelegateDelete(entity);
        if (deletedCount == 0) {
            throw new ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}(entity.toString());
        } else if (deletedCount > 1) {
            String msg = "deletedCount=" + deletedCount + ": " + entity.toString();
            throw new ${glPackageBaseCommonException}.${glEntityDuplicatedException}(msg);
        }
    }

    protected static interface InternalDeleteCallback<ENTITY_TYPE extends ${glEntityInterfaceName}> {
        public int callbackDelegateDelete(ENTITY_TYPE entity);
    }

    protected <ENTITY_TYPE extends ${glEntityInterfaceName}> void helpDeleteNonstrictInternally(ENTITY_TYPE entity, InternalDeleteNonstrictCallback<ENTITY_TYPE> callback) {
        assertEntityNotNull(entity);
        final int deletedCount = callback.callbackDelegateDeleteNonstrict(entity);
        if (deletedCount == 0) {
            throw new ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}(entity.toString());
        } else if (deletedCount > 1) {
            String msg = "deletedCount=" + deletedCount + ": " + entity.toString();
            throw new ${glPackageBaseCommonException}.${glEntityDuplicatedException}(msg);
        }
    }

    protected static interface InternalDeleteNonstrictCallback<ENTITY_TYPE extends ${glEntityInterfaceName}> {
        public int callbackDelegateDeleteNonstrict(ENTITY_TYPE entity);
    }

    protected <ENTITY_TYPE extends ${glEntityInterfaceName}> void helpDeleteNonstrictIgnoreDeletedInternally(ENTITY_TYPE entity, InternalDeleteNonstrictIgnoreDeletedCallback<ENTITY_TYPE> callback) {
        assertEntityNotNull(entity);
        final int deletedCount = callback.callbackDelegateDeleteNonstrict(entity);
        if (deletedCount == 0) {
            return;
        } else if (deletedCount > 1) {
            String msg = "deletedCount=" + deletedCount + ": " + entity.toString();
            throw new ${glPackageBaseCommonException}.${glEntityDuplicatedException}(msg);
        }
    }

    protected static interface InternalDeleteNonstrictIgnoreDeletedCallback<ENTITY_TYPE extends ${glEntityInterfaceName}> {
        public int callbackDelegateDeleteNonstrict(ENTITY_TYPE entity);
    }

    // =====================================================================================
    //                                                                    Basic Batch Update
    //                                                                    ==================
    /**
     * Create list.
     * 
     * @param entityList Entity-list. (NotNull and NotEmpty)
     * @return Created count.
     */
    public int createList(java.util.List${database.filterGenericsString(${glEntityInterfaceName})} entityList) {
        assertListNotNullAndNotEmpty(entityList);
        return callCreateList(entityList);
    }

    /**
     * Modify list.
     * 
     * @param entityList Entity-list. (NotNull and NotEmpty)
     * @return Modified count.
     */
    public int modifyList(java.util.List${database.filterGenericsString(${glEntityInterfaceName})} entityList) {
        assertListNotNullAndNotEmpty(entityList);
        return callModifyList(entityList);
    }

    /**
     * Remove list.
     * 
     * @param entityList Entity-list. (NotNull and NotEmpty)
     * @return Removed count.
     */
    public int removeList(java.util.List${database.filterGenericsString(${glEntityInterfaceName})} entityList) {
        assertListNotNullAndNotEmpty(entityList);
        return callRemoveList(entityList);
    }

    /**
     * Inject sequence to primary key if it needs.
     * 
     * @param entity Entity. (NotNull)
     */
    protected void injectSequenceToPrimaryKeyIfNeeds(${glEntityInterfaceName} entity) {
        final ${glDBMetaInterfaceName} dbmeta = entity.getDBMeta();
        if (!dbmeta.hasSequence() || dbmeta.hasTwoOrMorePrimaryKeys() || entity.hasPrimaryKeyValue()) {
            return;
        }
        final ${database.sequenceReturnType} sequenceValue = readNextVal();
        final String columnDbName = dbmeta.getPrimaryUniqueInfo().getFirstColumn().getColumnDbName();
        final java.util.Map${database.filterGenericsString('String, String')} map = new java.util.HashMap${database.filterGenericsString('String, String')}();
        map.put(columnDbName, sequenceValue.toString());
        dbmeta.acceptPrimaryKeyMap(entity, map);
    }

    // =====================================================================================
    //                                                                            Token File
    //                                                                            ==========
    /**
     * Reflect(insert or update) token-file to this table.
     * 
     * @param filename Name of the file. (NotNull and NotEmpty)
     * @param tokenFileReflectionOption token-file-reflection-option. (NotNull and Required{delimiter and encoding})
     * @return Token-file-reflection-result. (NotNull)
     * @throws java.io.FileNotFoundException
     * @throws java.io.IOException
     */
    public ${glTokenFileReflectionResultName} reflectTokenFile(String filename, ${glTokenFileReflectionOptionName} tokenFileReflectionOption) throws java.io.FileNotFoundException, java.io.IOException {
        assertStringNotNullAndNotTrimmedEmpty("filename", filename);
        assertFileTokenReflectionOption(tokenFileReflectionOption);

        final ${glTokenFileReflectionResultName} result = buildTokenFileReflectionResult();
        final ${glFileTokenizingCallbackName} fileTokenizingCallback = buildFileTokenReflectionFileTokenizingCallback(tokenFileReflectionOption, result);
        final ${glFileTokenizingOptionName} fileTokenizingOption = buildFileTokenReflectionFileTokenizingOption(tokenFileReflectionOption);
        final ${glFileTokenName} fileToken = new ${glFileTokenImplName}();
        fileToken.tokenize(filename, fileTokenizingCallback, fileTokenizingOption);
        return result;
    }

    /**
     * Reflect(insert or update) token-file to this table.
     * 
     * @param inputStream Input stream. (NotNull and NotClosed)
     * @param tokenFileReflectionOption token-file-reflection-option. (NotNull and Required{delimiter and encoding})
     * @return Token-file-reflection-result. (NotNull)
     * @throws java.io.FileNotFoundException
     * @throws java.io.IOException
     */
    public ${glTokenFileReflectionResultName} reflectTokenFile(java.io.InputStream inputStream, ${glTokenFileReflectionOptionName} tokenFileReflectionOption) throws java.io.FileNotFoundException, java.io.IOException {
        assertObjectNotNull("inputStream", inputStream);
        assertFileTokenReflectionOption(tokenFileReflectionOption);

        final ${glTokenFileReflectionResultName} result = buildTokenFileReflectionResult();
        final ${glFileTokenizingCallbackName} fileTokenizingCallback = buildFileTokenReflectionFileTokenizingCallback(tokenFileReflectionOption, result);
        final ${glFileTokenizingOptionName} fileTokenizingOption = buildFileTokenReflectionFileTokenizingOption(tokenFileReflectionOption);
        final ${glFileTokenName} fileToken = new ${glFileTokenImplName}();
        fileToken.tokenize(inputStream, fileTokenizingCallback, fileTokenizingOption);
        return result;
    }

    protected void assertFileTokenReflectionOption(${glTokenFileReflectionOptionName} tokenFileReflectionOption) {
        assertObjectNotNull("tokenFileReflectionOption", tokenFileReflectionOption);

        final String encoding = tokenFileReflectionOption.getEncoding();
        final String delimiter = tokenFileReflectionOption.getDelimiter();
        assertStringNotNullAndNotTrimmedEmpty("encoding", encoding);
        assertObjectNotNull("delimiter", delimiter);
    }

    protected ${glTokenFileReflectionResultName} buildTokenFileReflectionResult() {
        final ${glTokenFileReflectionResultName} result = new ${glTokenFileReflectionResultName}();
        final java.util.List${database.filterGenericsString(${glTokenFileReflectionFailureName})} failureList = new java.util.ArrayList${database.filterGenericsString(${glTokenFileReflectionFailureName})}();
        result.setFailureList(failureList);
        return result;
    }

    protected ${glFileTokenizingCallbackName} buildFileTokenReflectionFileTokenizingCallback(${glTokenFileReflectionOptionName} tokenFileReflectionOption, final ${glTokenFileReflectionResultName} result) throws java.io.FileNotFoundException, java.io.IOException {
        assertObjectNotNull("tokenFileReflectionOption", tokenFileReflectionOption);

        final String encoding = tokenFileReflectionOption.getEncoding();
        final String delimiter = tokenFileReflectionOption.getDelimiter();
        final boolean interruptIfError = tokenFileReflectionOption.isInterruptIfError();
        assertStringNotNullAndNotTrimmedEmpty("encoding", encoding);
        assertObjectNotNull("delimiter", delimiter);
        final java.util.List${database.filterGenericsString(${glTokenFileReflectionFailureName})} failureList = result.getFailureList();
        assertObjectNotNull("failureList", failureList);

        final ${glFileTokenizingCallbackName} fileTokenizingCallback = new ${glFileTokenizingCallbackName}() {
            public void handleRowResource(${glFileTokenizingRowResourceName} fileTokenizingRowResource) {
                final ${glFileTokenizingHeaderInfoName} fileTokenizingHeaderInfo = fileTokenizingRowResource.getFileTokenizingHeaderInfo();
                final java.util.List${database.filterGenericsString('String')} columnNameList = fileTokenizingHeaderInfo.getColumnNameList();
                final java.util.List${database.filterGenericsString('String')} valueList = fileTokenizingRowResource.getValueList();

                // Set up columnNameList of result object.
                if (result.getColumnNameList() == null) {
                    result.setColumnNameList(columnNameList);
                }

                ${glEntityInterfaceName} entity = null;
                try {
                    // Create entity by the list of value composed of String.
                    entity = createEntityByStringValueList(columnNameList, valueList);

                    // Create or modify as non-strict.
                    doCreateOrUpdateNonstrict(entity);

                    // Increment successCount of result object.
                    result.incrementSuccessCount();
                } catch (RuntimeException e) {
                    if (interruptIfError) {
                        throw e;
                    }
                    final ${glTokenFileReflectionFailureName} failure = new ${glTokenFileReflectionFailureName}();
                    failure.setColumnNameList(columnNameList);
                    failure.setValueList(valueList);
                    failure.setRowString(fileTokenizingRowResource.getRowString());
                    failure.setRowNumber(fileTokenizingRowResource.getRowNumber());
                    failure.setLineNumber(fileTokenizingRowResource.getLineNumber());
                    if (entity != null) {
                        failure.setEntity(entity);
                    }
                    failure.setException(e);
                    failureList.add(failure);
                }
            }
        };
        return fileTokenizingCallback;
    }

    protected ${glEntityInterfaceName} createEntityByStringValueList(java.util.List${database.filterGenericsString('String')} columnNameList, java.util.List${database.filterGenericsString('String')} valueList) {
        final ${glMapStringBuilderName} builder = new ${glMapStringBuilderImplName}();
        builder.setMsMapMark(MAP_STRING_MAP_MARK);
        builder.setMsStartBrace(MAP_STRING_START_BRACE);
        builder.setMsEndBrace(MAP_STRING_END_BRACE);
        builder.setMsDelimiter(MAP_STRING_DELIMITER);
        builder.setMsEqual(MAP_STRING_EQUAL);
        builder.setColumnNameList(columnNameList);
        final String mapString = builder.buildFromList(valueList);

        final ${glEntityInterfaceName} entity = getDBMeta().newEntity();
        getDBMeta().acceptColumnValueMapString(entity, mapString);
        return entity;
    }

    protected ${glFileTokenizingOptionName} buildFileTokenReflectionFileTokenizingOption(${glTokenFileReflectionOptionName} tokenFileReflectionOption) throws java.io.FileNotFoundException, java.io.IOException {
        assertObjectNotNull("tokenFileReflectionOption", tokenFileReflectionOption);

        final String encoding = tokenFileReflectionOption.getEncoding();
        final String delimiter = tokenFileReflectionOption.getDelimiter();
        assertStringNotNullAndNotTrimmedEmpty("encoding", encoding);
        assertObjectNotNull("delimiter", delimiter);

        final ${glFileTokenizingOptionName} fileTokenizingOption = new ${glFileTokenizingOptionName}();
        fileTokenizingOption.setEncoding(encoding);
        fileTokenizingOption.setDelimiter(delimiter);
        if (tokenFileReflectionOption.isHandleEmptyAsNull()) {
            fileTokenizingOption.handleEmptyAsNull();
        }
        return fileTokenizingOption;
    }
}
