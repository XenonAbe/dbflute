${database.allClassCopyright}package ${glPackageBaseCommonBhv};

#set ($myClassName = "${glBehaviorReadableAbstractName}")

import ${glPackageBaseCommon}.${glBehaviorSelectorInterfaceName};
import ${glPackageBaseCommon}.${glDaoSelectorInterfaceName};
import ${glPackageBaseCommon}.${glEntityInterfaceName};
#if ($database.isAvailableGenerics())
import ${glPackageBaseCommonBhvSetup}.${glValueLabelSetupperName};
import ${glPackageBaseCommonBhvSetup}.${glValueLabelBoxName};
#end
import ${glPackageBaseCommonCBean}.${glConditionBeanInterfaceName};
import ${glPackageBaseCommonCBean}.${glListResultBeanName};
import ${glPackageBaseCommonCBean}.${glPagingBeanInterfaceName};
import ${glPackageBaseCommonCBean}.${glPagingResultBeanName};

import ${glPackageBaseCommonBhvBatch}.${glTokenFileOutputOptionName};
import ${glPackageBaseCommonBhvBatch}.${glTokenFileOutputResultName};

import ${glPackageBaseCommonDBMetaInfo}.${glColumnInfoName};

import ${glPackageBaseCommonHelperTokenFile}.${glFileMakingOptionName};
import ${glPackageBaseCommonHelperTokenFile}.${glFileMakingHeaderInfoName};
import ${glPackageBaseCommonHelperTokenFile}.${glFileMakingSimpleFacadeName};
import ${glPackageBaseCommonHelperTokenFileImpl}.${glFileMakingSimpleFacadeImplName};

/**
 * The abstract class of behavior-readable.
 * 
 * @author ${database.ClassAuthor}
 */${database.outputSuppressWarningsAfterLineSeparator()}
public abstract class $myClassName implements ${glBehaviorReadableInterfaceName} {

    // ===================================================================================
    //                                                                           Attribute
    //                                                                           =========
    /** Behavior-selector instance. */
    protected ${glBehaviorSelectorInterfaceName} _behaviorSelector;

    /** Dao-selector instance. */
    protected ${glDaoSelectorInterfaceName} _daoSelector;

    // ===================================================================================
    //                                                                            Selector
    //                                                                            ========
    /**
     * ${database.ImplementComment}
     * 
     * @return Behavior-selector.
     */
    public ${glBehaviorSelectorInterfaceName} getBehaviorSelector() {
        return _behaviorSelector;
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param value Behavior-selector.
     */
    public void setBehaviorSelector(${glBehaviorSelectorInterfaceName} value) {
        _behaviorSelector = value;
    }

    /**
     * ${database.ImplementComment}
     * 
     * @return Dao-selector.
     */
    public ${glDaoSelectorInterfaceName} getDaoSelector() {
        return _daoSelector;
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param value Dao-selector.
     */
    public void setDaoSelector(${glDaoSelectorInterfaceName} value) {
        _daoSelector = value;
    }

    // ===================================================================================
    //                                                                     Delegate Method
    //                                                                     ===============
    /**
     * ${database.ImplementComment}
     * 
     * @return All count.
     */
    protected int callGetCountAll() {
        final java.lang.reflect.Method mtd = getMethod(getDaoReadable().getClass(), "getCountAll", new Class[]{});
        final Object result = invoke(mtd, getDaoReadable(), new Object[]{});
        return ((Integer)result).intValue();
    }

    /**
     * ${database.ImplementComment}
     * 
     * @return All list. (NotNull)
     */
    protected java.util.List${database.filterGenericsString(${glEntityInterfaceName})} callGetListAll() {
        final java.lang.reflect.Method mtd = getMethod(getDaoReadable().getClass(), "getListAll", new Class[]{});
        final Object result = invoke(mtd, getDaoReadable(), new Object[]{});
        return (java.util.List${database.filterGenericsString(${glEntityInterfaceName})})result;
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param cb Condition-bean that the type is condition-bean-interface. (NotNull)
     * @return Read count. (NotNull)
     */
    protected int callReadCount(${glConditionBeanInterfaceName} cb) {
        assertConditionBeanNotNull(cb);
        final Class[] types = new Class[]{cb.getClass()};
        final java.lang.reflect.Method mtd = getMethod(getDaoReadable().getClass(), "selectCount", types);
        final Object result = invoke(mtd, getDaoReadable(), new Object[]{cb});
        return ((Integer)result).intValue();
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param cb Condition-bean that the type is condition-bean-interface. (NotNull)
     * @return Read entity. If the select result is zero, it returns null. (Nullable)
     */
    protected ${glEntityInterfaceName} callReadEntity(${glConditionBeanInterfaceName} cb) {
        assertConditionBeanNotNull(cb);
        final Class[] types = new Class[]{cb.getClass()};
        final java.lang.reflect.Method mtd = getMethod(getDaoReadable().getClass(), "selectEntity", types);
        final Object result = invoke(mtd, getDaoReadable(), new Object[]{cb});
        return (${glEntityInterfaceName})result;
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param cb Condition-bean that the type is condition-bean-interface. (NotNull)
     * @return Read list. If the select result is zero, it returns empty list. (NotNull)
     */
    protected java.util.List${database.filterGenericsString(${glEntityInterfaceName})} callReadList(${glConditionBeanInterfaceName} cb) {
        assertConditionBeanNotNull(cb);
        final Class[] types = new Class[]{cb.getClass()};
        final java.lang.reflect.Method mtd = getMethod(getDaoReadable().getClass(), "selectList", types);
        final Object result = invoke(mtd, getDaoReadable(), new Object[]{cb});
        return (java.util.List${database.filterGenericsString(${glEntityInterfaceName})})result;
    }

    private java.lang.reflect.Method getMethod(Class clazz, String methodName, Class[] argTypes) {
        try {
            return clazz.getMethod(methodName, argTypes);
        } catch (NoSuchMethodException ex) {
            String msg = "class=" + clazz + " method=" + methodName + "-" + java.util.Arrays.asList(argTypes);
            throw new RuntimeException(msg, ex);
        }
    }

    private Object invoke(java.lang.reflect.Method method, Object target, Object[] args) {
        try {
            return method.invoke(target, args);
        } catch (java.lang.reflect.InvocationTargetException ex) {
            Throwable t = ex.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            }
            if (t instanceof Error) {
                throw (Error) t;
            }
            String msg = "target=" + target + " method=" + method + "-" + java.util.Arrays.asList(args);
            throw new RuntimeException(msg, ex);
        } catch (IllegalAccessException ex) {
            String msg = "target=" + target + " method=" + method + "-" + java.util.Arrays.asList(args);
            throw new RuntimeException(msg, ex);
        }
    }

    // =====================================================================================
    //                                                                         Basic Get All
    //                                                                         =============
    /**
     * Get count all.
     * 
     * @return Count all.
     */
    public int getCountAll() {
        return callGetCountAll();
    }

    // =====================================================================================
    //                                                                      Basic Read Count
    //                                                                      ================
    /**
     * ${database.ImplementComment}
     * 
     * @param cb Condition-bean. This condition-bean should not be set up about fetch-scope. (NotNull)
     * @return Read count. (NotNull)
     */
    public int readCount(${glConditionBeanInterfaceName} cb) {
        assertConditionBeanNotNull(cb);
        return callReadCount(cb);
    }

    // =====================================================================================
    //                                                                     Basic Read Entity
    //                                                                     =================
    /**
     * ${database.ImplementComment}
     * 
     * @param cb Condition-bean. (NotNull)
     * @return Read entity. (Nullalble)
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException}
     */
    public ${glEntityInterfaceName} readEntity(${glConditionBeanInterfaceName} cb) {
        assertConditionBeanNotNull(cb);
        final java.util.List${database.filterGenericsString(${glEntityInterfaceName})} ls = readList(cb);
        if (ls.isEmpty()) {
            return null;
        }
        assertRecordHasBeenSelectedAsOne(ls, cb);
        return (${glEntityInterfaceName})ls.get(0);
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param cb Condition-bean. (NotNull)
     * @return Read entity. (NotNull)
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException}
     */
    public ${glEntityInterfaceName} readEntityWithDeletedCheck(${glConditionBeanInterfaceName} cb) {
        assertConditionBeanNotNull(cb);
        final java.util.List${database.filterGenericsString(${glEntityInterfaceName})} ls = readList(cb);
        assertRecordHasNotBeenDeleted(ls, cb);
        assertRecordHasBeenSelectedAsOne(ls, cb);
        return (${glEntityInterfaceName})ls.get(0);
    }

    // =====================================================================================
    //                                                     Basic Read Entity Internal Helper
    //                                                     =================================
    protected <ENTITY_TYPE extends ${glEntityInterfaceName}, CB_TYPE extends ${glConditionBeanInterfaceName}>
            ENTITY_TYPE helpSelectEntityInternally(CB_TYPE cb, InternalSelectEntityCallback<ENTITY_TYPE, CB_TYPE> callback) {
        assertConditionBeanNotNull(cb);
        cb.checkSafetyResult(1);
        java.util.List<ENTITY_TYPE> ls = null;
        try {
            ls = callback.callbackSelectList(cb);
        } catch (${glPackageBaseCommonException}.${glDangerousResultSizeExceptionName} e) {
            throwRecordHasOverlappedException("{Over safetyMaxResultSize '1'}", cb, e);
        }
        if (ls.isEmpty()) {
            return null;
        }
        assertRecordHasBeenSelectedAsOne(ls, cb);
        return (ENTITY_TYPE)ls.get(0);
    }

    protected static interface InternalSelectEntityCallback<ENTITY_TYPE extends ${glEntityInterfaceName}, CB_TYPE extends ${glConditionBeanInterfaceName}> {
        public java.util.List<ENTITY_TYPE> callbackSelectList(CB_TYPE cb);
    }

    protected <ENTITY_TYPE extends ${glEntityInterfaceName}, CB_TYPE extends ${glConditionBeanInterfaceName}>
            ENTITY_TYPE helpSelectEntityWithDeletedCheckInternally(CB_TYPE cb, InternalSelectEntityWithDeletedCheckCallback<ENTITY_TYPE, CB_TYPE> callback) {
        assertConditionBeanNotNull(cb);
        cb.checkSafetyResult(1);
        java.util.List<ENTITY_TYPE> ls = null;
        try {
            ls = callback.callbackSelectList(cb);
        } catch (${glPackageBaseCommonException}.${glDangerousResultSizeExceptionName} e) {
            throwRecordHasOverlappedException("{Over safetyMaxResultSize '1'}", cb, e);
        }
        assertRecordHasNotBeenDeleted(ls, cb);
        assertRecordHasBeenSelectedAsOne(ls, cb);
        return (ENTITY_TYPE)ls.get(0);
    }

    protected static interface InternalSelectEntityWithDeletedCheckCallback<ENTITY_TYPE extends ${glEntityInterfaceName}, CB_TYPE extends ${glConditionBeanInterfaceName}> {
        public java.util.List<ENTITY_TYPE> callbackSelectList(CB_TYPE cb);
    }


    // =====================================================================================
    //                                                                       Basic Read List
    //                                                                       ===============
    /**
     * ${database.ImplementComment}
     * 
     * @param cb Condition-bean.
     * @return List-result-bean. If the select result is zero, it returns empty list. (NotNull)
     */
    public ${glListResultBeanName}${database.filterGenericsString(${glEntityInterfaceName})} readList(${glConditionBeanInterfaceName} cb) {
        assertConditionBeanNotNull(cb);
        return new ResultBeanBuilder${database.filterGenericsString(${glEntityInterfaceName})}(this).buildListResultBean(cb, callReadList(cb));
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param cb Condition-bean. (NotNull)
     * @return Read page. (NotNull)
     */
    public ${glPagingResultBeanName}${database.filterGenericsString(${glEntityInterfaceName})} readPage(final ${glConditionBeanInterfaceName} cb) {
        assertConditionBeanNotNull(cb);
        return readPage(cb, new SelectPageSimpleInvoker${database.filterGenericsString(${glEntityInterfaceName})}(this));
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param cb Condition-bean. (NotNull)
     * @param invoker Select-page-invoker (NotNull)
     * @return Read page. (NotNull)
     */
    public ${glPagingResultBeanName}${database.filterGenericsString(${glEntityInterfaceName})} readPage(final ${glConditionBeanInterfaceName} cb, SelectPageInvoker${database.filterGenericsString(${glEntityInterfaceName})} invoker) {
        assertConditionBeanNotNull(cb);
        final SelectPageCallback${database.filterGenericsString(${glEntityInterfaceName})} pageCallback = new SelectPageCallback${database.filterGenericsString(${glEntityInterfaceName})}() {
            public ${glPagingBeanInterfaceName} getPagingBean() { return cb; }
            public int selectCountIgnoreFetchScope() {
                return readCount(cb);
            }
            public java.util.List${database.filterGenericsString(${glEntityInterfaceName})} selectListWithFetchScope() {
                return readList(cb);
            }
        };
        return invoker.invokeSelectPage(pageCallback);
    }

    /**
     * Assert that record has not been deleted.
     * 
     * @param entity Selected entity.
     * @param searchKey4log Search-key for Logging.
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}
     */
    protected void assertRecordHasNotBeenDeleted(${glPackageBaseCommon}.${glEntityInterfaceName} entity, Object searchKey4log) {
        if (entity == null) {
            String msg = buildRecordHasBeenDeletedMessage(searchKey4log);
            throw new ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}(msg);
        }
    }

    /**
     * Assert that record has not been deleted.
     * 
     * @param ls Selected list.
     * @param searchKey4Log Search-key for Logging.
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}
     */
    protected void assertRecordHasNotBeenDeleted(java.util.List ls, Object searchKey4Log) {
        if (ls == null || ls.isEmpty()) {
            String msg = buildRecordHasBeenDeletedMessage(searchKey4Log);
            throw new ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}(msg);
        }
    }

    /**
     * Assert that record has been selected as one.
     * 
     * @param ls Selected list.
     * @param searchKey4Log Search-key for Logging.
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException}
     */
    protected void assertRecordHasBeenSelectedAsOne(java.util.List ls, Object searchKey4Log) {
        if (ls == null || ls.isEmpty()) {
            String msg = buildRecordHasBeenDeletedMessage(searchKey4Log);
            throw new ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}(msg);
        }
        if (ls.size() != 1) {
            throwRecordHasOverlappedException(ls.size() + "", searchKey4Log, null);
        }
    }

    protected void throwRecordHasOverlappedException(String resultCountString, Object searchKey4Log, Throwable cause) {
        String msg = "The selected records should be only one! But the resultCount=" + resultCountString + getLineSeparator();
        msg = msg + "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *" + getLineSeparator();
        msg = msg + "Please confirm your condition. Does it really select only one?" + getLineSeparator();
        msg = msg + "And please confirm your database. Does it really exist only one?" + getLineSeparator();
        msg = msg + "- - - - -" + getLineSeparator();
        msg = msg + "The searchKey is as follows:" + getLineSeparator() + searchKey4Log + getLineSeparator();
        msg = msg + "* * * * * * * * * */" + getLineSeparator();
        if (cause != null) {
            throw new ${glPackageBaseCommonException}.${glEntityDuplicatedException}(msg, cause);
        } else {
            throw new ${glPackageBaseCommonException}.${glEntityDuplicatedException}(msg);
        }
    }

    private String buildRecordHasBeenDeletedMessage(Object searchKey4log) {
        String msg = "The record has already been deleted!" + getLineSeparator();
        msg = msg + "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *" + getLineSeparator();
        msg = msg + "Please confirm the existence of your target record." + getLineSeparator();
        msg = msg + "Does the target record really created before this operation?" + getLineSeparator();
        msg = msg + "Has the target record been deleted by other thread?" + getLineSeparator();
        msg = msg + "It is precondition that the record exists on database." + getLineSeparator();
        msg = msg + "- - - - -" + getLineSeparator();
        msg = msg + "The searchKey is as follows:" + getLineSeparator() + searchKey4log + getLineSeparator();
        msg = msg + "* * * * * * * * * */" + getLineSeparator();
        return msg;
    }

    /**
     * Assert that selected count has not exceeded max count.
     * 
     * @param selectedCount Selected count.
     * @param maxCount Max count.
     * @param clauseObject Clause object for exception message.
     * @exception ${glPackageBaseCommonException}.${glSelectedCountExceedMaxCountExceptionName}
     */
    protected void assertSelectedCountHasNotExceededMaxCount(int selectedCount, int maxCount, Object clauseObject) {
        if (selectedCount > maxCount) {
            String msg = "Selected count[" + selectedCount + "] has exceeded max count[" + maxCount + "]: clauseObject=" + clauseObject;
            throw new ${glPackageBaseCommonException}.${glSelectedCountExceedMaxCountExceptionName}(msg, selectedCount, maxCount);
        }
    }

#if ($database.isAvailableGenerics())
    // ===================================================================================
    //                                                                      Various Select
    //                                                                      ==============
    /**
     * Select value-label list.
     * 
     * ${database.filterGenericsParamOutput('<ENTITY>', 'The type of entity.')}
     * @param cb Condition-bean. (NotNull)
     * @param valueLabelSetupper Value-label-setupper. (NotNull)
     * @return Value-label list. (NotNull)
     */
    protected <ENTITY extends ${glEntityInterfaceName}> java.util.List<java.util.Map<String, Object>> createValueLabelList(${glListResultBeanName}<ENTITY> ls, ${glValueLabelSetupperName}<ENTITY> valueLabelSetupper) {
        final java.util.List<java.util.Map<String, Object>> valueLabelList = new java.util.ArrayList<java.util.Map<String, Object>>();
        final ${glValueLabelBoxName} box = new ${glValueLabelBoxName}();
        for (ENTITY entity : ls) {
            final java.util.Map<String, Object> valueLabel = new java.util.HashMap<String, Object>();
            valueLabelSetupper.setup(box, entity);
            valueLabel.put("value", box.getValue());
            valueLabel.put("label", box.getLabel());
            valueLabelList.add(valueLabel);
        }
        return valueLabelList;
    }
#end

    // ===================================================================================
    //                                                                            Sequence
    //                                                                            ========
    /**
     * ${database.ImplementComment}
     * 
     * @return The value of sequence. (NotNull)
     */
    public ${database.sequenceReturnType} readNextVal() {
        try {
            final java.lang.reflect.Method method = getClass().getMethod("selectNextVal", new Class[]{});
            Object sequenceObject = method.invoke(this, new Object[] {});
            if (sequenceObject instanceof ${database.sequenceReturnType}) {
                return (${database.sequenceReturnType})sequenceObject;
            }
            return (${database.sequenceReturnType})newInstanceSequence(${database.sequenceReturnType}.class, sequenceObject);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException("The table does not have sequence: " + getTableDbName(), e);
        } catch (Exception e) {
            throw new RuntimeException("The selectNextVal() of the table threw the exception: " + getTableDbName(), e);
        }
    }

    private Object newInstanceSequence(Class resultClass, Object sequenceObject) {
        try {
            final java.lang.reflect.Method method = resultClass.getMethod("valueOf", new Class[]{String.class});
            return method.invoke(null, new Object[]{sequenceObject.toString()});
        } catch (NoSuchMethodException e) {
        } catch (Exception e) {
            throw new RuntimeException("The readNextVal() of the table threw the exception: " + getTableDbName(), e);
        }
        try {
            final java.lang.reflect.Method method = resultClass.getMethod("valueOf", new Class[]{Long.class});
            return method.invoke(null, new Object[]{Long.valueOf(sequenceObject.toString())});
        } catch (NoSuchMethodException e) {
        } catch (Exception e) {
            throw new RuntimeException("The readNextVal() of the table threw the exception: " + getTableDbName(), e);
        }
        String msg = "The result type of selectNextVal() is unsupported: type=" + resultClass;
        throw new IllegalStateException(msg);
    }

    // ===================================================================================
    //                                                        Load Referer Internal Helper
    //                                                        ============================
    /**
     * Help load referer internally. <br />
     * About internal policy, the value of primary key(and others too) is treated as CaseInsensitive.
     * 
     * @param <BASE_ENTITY_TYPE> The type of base entity.
     * @param <PK_TYPE> The type of primary key.
     * @param <REFERER_CB_TYPE> The type of referer condition-bean.
     * @param <REFERER_ENTITY_TYPE> The type of referer entity.
     * @param baseEntityList The list of base entity. (NotNull)
     * @param loadRefererOption The option of load referer. (NotNull)
     * @param callback The internal callback of load referer. (NotNull) 
     */
    protected <BASE_ENTITY_TYPE extends ${glEntityInterfaceName}, PK_TYPE, REFERER_CB_TYPE extends ${glConditionBeanInterfaceName}, REFERER_ENTITY_TYPE extends ${glEntityInterfaceName}>
            void helpLoadRefererInternally(java.util.List<BASE_ENTITY_TYPE> baseEntityList
                                         , ${glPackageBaseCommonBhvLoad}.${glLoadRefererOptionName}<REFERER_CB_TYPE, REFERER_ENTITY_TYPE> loadRefererOption
                                         , InternalLoadRefererCallback<BASE_ENTITY_TYPE, PK_TYPE, REFERER_CB_TYPE, REFERER_ENTITY_TYPE> callback) {

        // - - - - - - - - - - -
        // Assert pre-condition
        // - - - - - - - - - - -
        assertObjectNotNull("baseEntityList", baseEntityList);
        assertObjectNotNull("loadRefererOption", loadRefererOption);
        if (baseEntityList.isEmpty()) {
            return;
        }

        // - - - - - - - - - - - - - -
        // Prepare temporary container
        // - - - - - - - - - - - - - -
        final java.util.Map<PK_TYPE, BASE_ENTITY_TYPE> pkBaseEntityMap = new java.util.LinkedHashMap<PK_TYPE, BASE_ENTITY_TYPE>();
        final java.util.List<PK_TYPE> pkList = new java.util.ArrayList<PK_TYPE>();
        for (BASE_ENTITY_TYPE baseEntity : baseEntityList) {
            final PK_TYPE primaryKeyValue = callback.callbackBase_getPrimaryKeyValue(baseEntity);
            pkList.add(callback.callbackBase_getPrimaryKeyValue(baseEntity));
            pkBaseEntityMap.put(toLowerCasePrimaryKeyIfString(primaryKeyValue), baseEntity);
        }

        // - - - - - - - - - - - - - - - -
        // Prepare referer condition bean
        // - - - - - - - - - - - - - - - -
        final REFERER_CB_TYPE cb;
        if (loadRefererOption.getRefererConditionBean() != null) {
            cb = loadRefererOption.getRefererConditionBean();
        } else {
            cb = callback.callbackReferer_newMyConditionBean();
        }

        // - - - - - - - - - - - - - -
        // Select the list of referer
        // - - - - - - - - - - - - - -
        callback.callbackReferer_queryForeignKeyInScope(cb, pkList);
        loadRefererOption.delegateKeyConditionExchangingFirstWhereClauseForLastOne(cb);
        if (!loadRefererOption.isStopOrderByKey()) {
            callback.callbackReferer_queryAddOrderByForeignKeyAsc(cb);
            cb.getSqlComponentOfOrderByClause().exchangeFirstOrderByElementForLastOne();
        }
        loadRefererOption.delegateConditionBeanSettingUp(cb);
        final java.util.List<REFERER_ENTITY_TYPE> refererList = callback.callbackReferer_selectList(cb);
        loadRefererOption.delegateEntitySettingUp(refererList);

        // - - - - - - - - - - - - - - - - - - - - - - - -
        // Create the map of {primary key / referer list}
        // - - - - - - - - - - - - - - - - - - - - - - - -
        final java.util.Map<PK_TYPE, java.util.List<REFERER_ENTITY_TYPE>> pkReffererListMap = new java.util.LinkedHashMap<PK_TYPE, java.util.List<REFERER_ENTITY_TYPE>>();
        for (REFERER_ENTITY_TYPE refererEntity : refererList) {
            final PK_TYPE refererListKey;
            {
                final PK_TYPE foreignKeyValue = callback.callbackReferer_getForeignKeyValue(refererEntity);
                refererListKey = toLowerCasePrimaryKeyIfString(foreignKeyValue);
            }
            if (!pkReffererListMap.containsKey(refererListKey)) {
                pkReffererListMap.put(refererListKey, new java.util.ArrayList<REFERER_ENTITY_TYPE>());
            }
            (pkReffererListMap.get(refererListKey)).add(refererEntity);

            // for Reverse Reference.
            final BASE_ENTITY_TYPE baseEntity = pkBaseEntityMap.get(refererListKey);
            callback.callbackReferer_setForeignEntity(refererEntity, baseEntity);
        }

        // - - - - - - - - - - - - - - - - - -
        // Relate referer list to base entity
        // - - - - - - - - - - - - - - - - - -
        for (BASE_ENTITY_TYPE baseEntity : baseEntityList) {
            final PK_TYPE refererListKey;
            {
                final PK_TYPE primaryKey = callback.callbackBase_getPrimaryKeyValue(baseEntity);
                refererListKey = toLowerCasePrimaryKeyIfString(primaryKey);
            }
            if (pkReffererListMap.containsKey(refererListKey)) {
                callback.callbackBase_setRefererList(baseEntity, pkReffererListMap.get(refererListKey));
            } else {
                callback.callbackBase_setRefererList(baseEntity, new java.util.ArrayList<REFERER_ENTITY_TYPE>());
            }
        }
    }

    /**
     * To lower case for primary key if the value is string.
     * 
     * @param <PK_TYPE> The type of primary key.
     * @param value The value of primary key. (Nullable)
     * @return The value of primary key. (Nullable)
     */
    protected <PK_TYPE> PK_TYPE toLowerCasePrimaryKeyIfString(PK_TYPE value) {
        return (PK_TYPE)toLowerCaseIfString(value);
    }

    /**
     * @param <BASE_ENTITY_TYPE> The type of base entity.
     * @param <PK_TYPE> The type of primary key.
     * @param <REFERER_CB_TYPE> The type of referer condition-bean.
     * @param <REFERER_ENTITY_TYPE> The type of referer entity.
     */
    protected static interface InternalLoadRefererCallback<BASE_ENTITY_TYPE extends ${glEntityInterfaceName}
                                                         , PK_TYPE, REFERER_CB_TYPE extends ${glConditionBeanInterfaceName}
                                                         , REFERER_ENTITY_TYPE extends ${glEntityInterfaceName}> {
        // For Base
        public PK_TYPE callbackBase_getPrimaryKeyValue(BASE_ENTITY_TYPE entity);
        public void callbackBase_setRefererList(BASE_ENTITY_TYPE entity, java.util.List<REFERER_ENTITY_TYPE> refererList);

        // For Referer
        public REFERER_CB_TYPE callbackReferer_newMyConditionBean();
        public void callbackReferer_queryForeignKeyInScope(REFERER_CB_TYPE cb, java.util.List<PK_TYPE> pkList);
        public void callbackReferer_queryAddOrderByForeignKeyAsc(REFERER_CB_TYPE cb);
        public java.util.List<REFERER_ENTITY_TYPE> callbackReferer_selectList(REFERER_CB_TYPE cb);
        public PK_TYPE callbackReferer_getForeignKeyValue(REFERER_ENTITY_TYPE entity);
        public void callbackReferer_setForeignEntity(REFERER_ENTITY_TYPE refererEntity, BASE_ENTITY_TYPE baseEntity);
    }

    // ===================================================================================
    //                                                             Pullout Internal Helper
    //                                                             =======================
    protected <BASE_ENTITY_TYPE extends ${glEntityInterfaceName}, FOREIGN_ENTITY_TYPE extends ${glEntityInterfaceName}>
            java.util.List<FOREIGN_ENTITY_TYPE> helpPulloutInternally(java.util.List<BASE_ENTITY_TYPE> baseEntityList, InternalPulloutCallback<BASE_ENTITY_TYPE, FOREIGN_ENTITY_TYPE> callback) {
        assertObjectNotNull("baseEntityList", baseEntityList);
        final java.util.Set<FOREIGN_ENTITY_TYPE> foreignSet = new java.util.LinkedHashSet<FOREIGN_ENTITY_TYPE>();
        for (BASE_ENTITY_TYPE entity : baseEntityList) {
            final FOREIGN_ENTITY_TYPE foreignEntity = callback.callbackGetForeignEntity(entity);
            if (foreignEntity == null || foreignSet.contains(foreignEntity)) {
                continue;
            }
            foreignSet.add(foreignEntity);
        }
        return new java.util.ArrayList<FOREIGN_ENTITY_TYPE>(foreignSet);
    }

    protected static interface InternalPulloutCallback<BASE_ENTITY_TYPE extends ${glEntityInterfaceName}, FOREIGN_ENTITY_TYPE extends ${glEntityInterfaceName}> {
        public FOREIGN_ENTITY_TYPE callbackGetForeignEntity(BASE_ENTITY_TYPE entity);
    }

    // ===================================================================================
    //                                                                          Token File
    //                                                                          ==========
    /**
     * Output token-file from this table records.
     * 
     * @param cb Condition-bean. (NotNull)
     * @param filename Name of the file. (NotNull and NotEmpty)
     * @param tokenFileOutputOption token-file-output-option. (NotNull and Required{delimiter and encoding})
     * @return Token-file-output-result. (NotNull)
     * @throws java.io.FileNotFoundException
     * @throws java.io.IOException
     */
    public ${glTokenFileOutputResultName} outputTokenFile(${glConditionBeanInterfaceName} cb, String filename, ${glTokenFileOutputOptionName} tokenFileOutputOption) throws java.io.FileNotFoundException, java.io.IOException {
        assertConditionBeanNotNull(cb);
        assertStringNotNullAndNotTrimmedEmpty("filename", filename);
        assertObjectNotNull("tokenFileOutputOption", tokenFileOutputOption);

        final java.util.List${database.filterGenericsString(${glEntityInterfaceName})} ls = readList(cb);
        java.util.List${database.filterGenericsString('java.util.List<String>')} rowList = new java.util.ArrayList${database.filterGenericsString('java.util.List<String>')}();
        for (java.util.Iterator ite = ls.iterator(); ite.hasNext(); ) {
            final ${glEntityInterfaceName} entity = (${glEntityInterfaceName})ite.next();
            final java.util.List${database.filterGenericsString('String')} valueList = getDBMeta().convertToColumnStringValueList(entity);
            rowList.add(valueList);
        }
        final ${glFileMakingSimpleFacadeName} fileMakingSimpleFacade = new ${glFileMakingSimpleFacadeImplName}();
        final ${glFileMakingOptionName} fileMakingOption = tokenFileOutputOption.getFileMakingOption();
        final ${glFileMakingHeaderInfoName} fileMakingHeaderInfo = new ${glFileMakingHeaderInfoName}();
        final java.util.List${database.filterGenericsString('String')} columnDbNameList = new java.util.ArrayList${database.filterGenericsString('String')}();
        for (final java.util.Iterator ite = getDBMeta().getColumnInfoList().iterator(); ite.hasNext(); ) {
            final ${glColumnInfoName} columnInfo = (${glColumnInfoName})ite.next();
            columnDbNameList.add(columnInfo.getColumnDbName());
        }
        fileMakingHeaderInfo.setColumnNameList(columnDbNameList);
        fileMakingOption.setFileMakingHeaderInfo(fileMakingHeaderInfo);
        fileMakingSimpleFacade.makeFromRowList(filename, rowList, fileMakingOption);
        final ${glTokenFileOutputResultName} tokeFileOutputResult = new ${glTokenFileOutputResultName}();
        tokeFileOutputResult.setSelectedList(ls);
        return tokeFileOutputResult;
    }

    // ===================================================================================
    //                                                                              Helper
    //                                                                              ======
    /**
     * To lower case if the type is String.
     * 
     * @param obj Object. (Nullable)
     * @return Lower object. (Nullable)
     */
    protected Object toLowerCaseIfString(Object obj) {
        if (obj != null && obj instanceof String) {
            return ((String)obj).toLowerCase();
        }
        return obj;
    }

    /**
     * Get the value of line separator.
     * 
     * @return The value of line separator. (NotNull)
     */
    protected String getLineSeparator() {
        return System.getProperty("line.separator");
    }

    protected <ENTITY_TYPE extends ${glEntityInterfaceName}> ENTITY_TYPE helpDowncastInternally(${glEntityInterfaceName} entity, Class<ENTITY_TYPE> clazz) {
        assertObjectNotNull("entity", entity);
        assertObjectNotNull("clazz", clazz);
        try {
            return (ENTITY_TYPE)entity;
        } catch (ClassCastException e) {
            String msg = "The entity should be " + clazz.getSimpleName() + " but it was: " + entity.getClass();
            throw new RuntimeException(msg, e);
        }
    }

    // ----------------------------------------------------------------
    //                                                    Assert Object
    //                                                    -------------
    /**
     * Assert that the object is not null.
     * 
     * @param variableName Variable name. (NotNull)
     * @param value Value. (NotNull)
     * @exception IllegalArgumentException
     */
    protected void assertObjectNotNull(String variableName, Object value) {
        if (variableName == null) {
            String msg = "The value should not be null: variableName=" + variableName + " value=" + value;
            throw new IllegalArgumentException(msg);
        }
        if (value == null) {
            String msg = "The value should not be null: variableName=" + variableName;
            throw new IllegalArgumentException(msg);
        }
    }

    /**
     * Assert that the entity is not null.
     * 
     * @param entity Entity. (NotNull)
     */
    protected void assertEntityNotNull(${glEntityInterfaceName} entity) {
        assertObjectNotNull("entity", entity);
    }

    /**
     * Assert that the condition-bean is not null.
     * 
     * @param cb Condition-bean. (NotNull)
     */
    protected void assertConditionBeanNotNull(${glPackageBaseCommonCBean}.${glConditionBeanInterfaceName} cb) {
        assertObjectNotNull("cb", cb);
    }

    /**
     * Assert that the entity has primary-key value.
     * 
     * @param entity Entity. (NotNull)
     */
    protected void assertEntityNotNullAndHasPrimaryKeyValue(${glEntityInterfaceName} entity) {
        assertEntityNotNull(entity);
        if (!entity.hasPrimaryKeyValue()) {
            String msg = "The entity must should primary-key: entity=" + entity;
            throw new IllegalArgumentException(msg + entity);
        }
    }

    // ----------------------------------------------------------------
    //                                                    Assert String
    //                                                    -------------
    /**
     * Assert that the entity is not null and not trimmed empty.
     * 
     * @param variableName Variable name. (NotNull)
     * @param value Value. (NotNull)
     */
    protected void assertStringNotNullAndNotTrimmedEmpty(String variableName, String value) {
        assertObjectNotNull("variableName", variableName);
        assertObjectNotNull(variableName, value);
        if (value.trim().length() ==0) {
            String msg = "The value should not be empty: variableName=" + variableName + " value=" + value;
            throw new IllegalArgumentException(msg);
        }
    }

    // ----------------------------------------------------------------
    //                                                      Assert List
    //                                                      -----------
    /**
     * Assert that the list is empty.
     * 
     * @param ls List. (NotNull)
     */
    protected void assertListNotNullAndEmpty(java.util.List ls) {
        assertObjectNotNull("ls", ls);
        if (!ls.isEmpty()) {
            String msg = "The list should be empty: ls=" + ls.toString();
            throw new IllegalArgumentException(msg);
        }
    }

    /**
     * Assert that the list is not empty.
     * 
     * @param ls List. (NotNull)
     */
    protected void assertListNotNullAndNotEmpty(java.util.List ls) {
        assertObjectNotNull("ls", ls);
        if (ls.isEmpty()) {
            String msg = "The list should not be empty: ls=" + ls.toString();
            throw new IllegalArgumentException(msg);
        }
    }

    /**
     * Assert that the list having only one.
     * 
     * @param ls List. (NotNull)
     */
    protected void assertListNotNullAndHasOnlyOne(java.util.List ls) {
        assertObjectNotNull("ls", ls);
        if (ls.size() != 1) {
            String msg = "The list should contain only one object: ls=" + ls.toString();
            throw new IllegalArgumentException(msg);
        }
    }
}
