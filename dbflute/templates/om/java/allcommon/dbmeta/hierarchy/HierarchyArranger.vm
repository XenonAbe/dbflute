package dbflute.ldb.allcommon.dbmeta.hierarchy;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import dbflute.ldb.allcommon.LdEntity;
import dbflute.ldb.allcommon.dbmeta.LdDBMeta;
import dbflute.ldb.allcommon.dbmeta.info.LdColumnInfo;
import dbflute.ldb.allcommon.dbmeta.info.LdForeignInfo;
import dbflute.ldb.allcommon.dbmeta.info.LdRefererInfo;
import dbflute.ldb.allcommon.dbmeta.info.LdRelationInfo;

/**
 * 
 * <pre>
 * ex) LIBRARY Hierarchy
 * 
 * LIBRARY
 *  |1
 *  |--* NEXT_LIBRARY (Referer)
 *  |       |*
 *  |       |--1 LIBRARY (Foreign)
 *  |
 *  |--* COLLECTION (Referer)
 *  |       |1 
 *  |       |--1 COLLECTION_STATUS (Referer)
 *  |       |       |*
 *  |       |       |--1 COLLECTION_STATUS_LOOKUP (Foreign)
 *  |       |
 *  |       |--1 BOOK (Foreign)
 *  |       |     |*
 *  |       |     |--1 AUTHOR (Foreign)
 *  |       |     |--1 PUBLISER (Foreign)
 *  |       |     |--1 GENRE (Foreign)
 *  |       |           |*
 *  |       |           |--1 GENRE (Foreign)
 *  |       |
 *  |       |--* LENDING_COLLECTION (Referer)
 *  |       |
 *  |
 *  |--* LIBRARY_USER (Referer)
 *         |*  |1
 *         |   |--* LENDING (Referer)
 *         |         |1
 *         |         |--* LENDING_COLLECTION (Referer)
 *         |
 *         |--1 LB_USER (Foreign)
 *                 |1
 *                 |--* BLACK_LIST (Referer)
 *                         |1
 *                         |--* BLACK_ACTION (Referer)
 *                                 |*
 *                                 |--1 BLACK_ACTION_LOOKUP (Foreign)
 *          
 *          
 * ex) The SQL of LIBRARY Hierarchy as FLAT
 * 
 * select library.LIBRARY_ID as LIBRARY_ID
 *      , library.LIBRARY_NAME as LIBRARY_NAME
 *      , library.R_USER as R_USER
 *      , library.R_TIMESTAMP as R_TIMESTAMP
 *      , nextBase.LIBRARY_ID as BASE_LIBRARY_ID
 *      , nextBase.NEXT_LIBRARY_ID as NEXT_LIBRARY_ID
 *      , nextBaseNextLibrary.LIBRARY_ID as NEXT_LIBRARY_NEXT_LIBRARY_ID
 *      , nextBaseNextLibrary.LIBRARY_NAME as NEXT_LIBRARY_NEXT_LIBRARY_NAME
 *      , collection.COLLECTION_ID as COLLECTION_ID
 *      , collection.ARRIVAL_DATE as COLLECTION_ARRIVAL_DATE
 *      , collectionStatus.COLLECTION_ID as COLLECTION_STATUS_ID
 *      , collectionStatus.COLLECTION_STATUS_CODE as COLLECTION_STATUS_CODE
 *      , collectionStatusLookup.COLLECTION_STATUS_CODE as COLLECTION_STATUS_CODE
 *      , collectionStatusLookup.COLLECTION_STATUS_NAME as COLLECTION_STATUS_NAME
 *      , book.BOOK_ID as COLLECTION_BOOK_ID
 *      , book.BOOK_NAME as COLLECTION_BOOK_NAME
 *      , author.AUTHOR_ID as COLLECTION_BOOK_AUTHOR_ID
 *      , author.AUTHOR_NAME as COLLECTION_BOOK_AUTHOR_NAME
 *      , libraryUser.LIBRARY_ID as LIBRARY_USER_LIBRARY_ID 
 *      , libraryUser.LB_USER_ID as LIBRARY_USER_LB_USER_ID
 *      , lending.LIBRARY_ID as LENDING_LIBRARY_ID
 *      , lending.LB_USER_ID as LENDING_LB_USER_ID
 *      , lending.LENDING_DATE as LENDING_DATE
 *      , lending.U_USER as LENDING_U_USER
 *      , lending.U_MODULE as LENDING_U_MODULE
 *      , lbUser.LB_USER_ID as LB_USER_ID
 *      , lbUser.LB_USER_NAME as LB_USER_NAME
 *   from LIBRARY library
 *     left outer join NEXT_LIBRARY nextBase on library.LIBRARY_ID = nextBase.LIBRARY_ID
 *       left outer join LIBRARY nextBaseNextLibrary on nextBase.NEXT_LIBRARY_ID = nextBaseNextLibrary.LIBRARY_ID
 *     left outer join COLLECTION collection on library.LIBRARY_ID = collection.LIBRARY_ID
 *       left outer join COLLECTION_STATUS collectionStatus on collection.COLLECTION_ID = collectionStatus.COLLECTION_ID
 *         left outer join COLLECTION_STATUS_LOOKUP collectionStatusLookup on collectionStatus.COLLECTION_STATUS_CODE = collectionStatusLookup.COLLECTION_STATUS_CODE
 *       left outer join BOOK book on collection.BOOK_ID = book.BOOK_ID
 *         left outer join AUTHOR author on book.AUTHOR_ID = author.AUTHOR_ID
 *     left outer join LIBRARY_USER libraryUser on library.LIBRARY_ID = libraryUser.LIBRARY_ID
 *       left outer join LENDING lending on libraryUser.LIBRARY_ID = lending.LIBRARY_ID and libraryUser.LB_USER_ID = lending.LB_USER_ID
 *       left outer join LB_USER lbUser on libraryUser.LB_USER_ID = lbUser.LB_USER_ID
 * 
 * 
 * ex) Invoking Hierarchy Arranger
 * 
 * private List&lt;Book&gt; makeLibraryList() {
 *     final HierarchyRequest request = createHierarchyRequest(createFlatBookList());
 *     return new HierarchyArranger&lt;Library&gt;().arrangeHierarchy(request);
 * }
 * 
 * 
 * ex) Creating Hierarchy Request
 * 
 * private HierarchyRequest createHierarchsyRequest(java.util.List&gt;HierarchyFlatLibrary&gt; flatLibraryList) {
 *
 *     // Define hierarychy request as library.
 *     final LdHierarchyRequest&lt;LdLibrary&gt; request = new LdHierarchyRequest&lt;LdLibrary&gt;(LdLibrary.class);
 * 
 *     // Register source iterator. (by calling creator for flat library list)
 *     request.registerSourceBeanList(flatLibraryList);
 *
 *     // Define dbmeta.
 *     final LdHierarchyFlatLibraryDbm sourceDbm = LdHierarchyFlatLibraryDbm.getInstance();
 *     final LdLibraryDbm libraryDbm = LdLibraryDbm.getInstance();
 *     final LdNextLibraryDbm nextLibraryDbm = LdNextLibraryDbm.getInstance();
 *     final LdCollectionDbm collectionDbm = LdCollectionDbm.getInstance();
 *     final LdCollectionStatusDbm collectionStatusDbm = LdCollectionStatusDbm.getInstance();
 *     final LdCollectionStatusLookupDbm collectionStatusLookupDbm = LdCollectionStatusLookupDbm.getInstance();
 *     final LdBookDbm bookDbm = LdBookDbm.getInstance();
 *     final LdAuthorDbm authorDbm = LdAuthorDbm.getInstance();
 *     final LdLendingDbm lendingDbm = LdLendingDbm.getInstance();
 *     final LdLbUserDbm lbUserDbm = LdLbUserDbm.getInstance();
 *     
 *     // Define relation information.
 *     final LdRefererInfo library_nextLibraryByBaseIdList = libraryDbm.getRefererInfo_nextLibraryByBaseIdList();
 *     final LdForeignInfo libraryByNextId_library = nextLibraryDbm.getForeignInfo_libraryByNextId();
 *     final LdRefererInfo library_collectionList = libraryDbm.getRefererInfo_collectionList();
 *     final LdForeignInfo collection_collectionStatusAsOne = collectionDbm.getForeignInfo_collectionStatusAsOne();
 *     final LdForeignInfo collectionStatus_collectionStatusLookup = collectionStatusDbm.getForeignInfo_collectionStatusLookup();
 *     final LdForeignInfo collection_book = collectionDbm.getForeignInfo_book();
 *     final LdForeignInfo book_author = bookDbm.getForeignInfo_author();
 *     final LdRefererInfo library_libraryUserList = libraryDbm.getRefererInfo_libraryUserList();
 *     final LdRefererInfo libraryUser_lendingList = libraryUserDbm.getRefererInfo_lendingList();
 *     final LdForeignInfo libraryUser_lbUser = libraryUserDbm.getForeignInfo_lbUser();
 *     
 *     // Register column [libraryId]
 *     request.mapping(sourceDbm.getColumnInfo_libraryId(), libraryDbm.getColumnInfo_libraryId());
 * 
 *     // Register column [libraryName]
 *     request.mapping(sourceDbm.getColumnInfo_libraryName(), libraryDbm.getColumnInfo_libraryName());
 * 
 *     // Register column [RUser]
 *     request.mapping(sourceDbm.getColumnInfo_RUser(), libraryDbm.getColumnInfo_RUser());
 * 
 *     // Register column [RTimestamp]
 *     request.mapping(sourceDbm.getColumnInfo_RTimestamp(), libraryDbm.getColumnInfo_RTimestamp());
 * 
 *     // Register column [baseLibraryId]
 *     request.mapping(sourceDbm.getColumnInfo_baseLibraryId(), nextLibraryDbm.getColumnInfo_libraryId());
 *     request.relation(library_nextLibraryByBaseIdList);
 * 
 *     // Register column [nextLibraryId]
 *     request.mapping(sourceDbm.getColumnInfo_nextLibraryId(), nextLibraryDbm.getColumnInfo_nextLibraryId());
 *     request.relation(library_nextLibraryByBaseIdList);
 * 
 *     // Register column [nextLibraryNextLibraryId]
 *     request.mapping(sourceDbm.getColumnInfo_nextLibraryNextLibraryId(), libraryDbm.getColumnInfo_libraryId());
 *     request.relation(library_nextLibraryByBaseIdList);
 *     request.relation(libraryByNextId_library);
 * 
 *     // Register column [nextLibraryNextLibraryName]
 *     request.mapping(sourceDbm.getColumnInfo_nextLibraryNextLibraryName(), libraryDbm.getColumnInfo_libraryName());
 *     request.relation(library_nextLibraryByBaseIdList);
 *     request.relation(libraryByNextId_library);
 * 
 *     // Register column [collectionId]
 *     request.mapping(sourceDbm.getColumnInfo_collectionId(), collectionDbm.getColumnInfo_collectionId());
 *     request.relation(library_collectionList);
 * 
 *     // Register column [arrivalDate]
 *     request.mapping(sourceDbm.getColumnInfo_collectionArrivalDate(), collectionDbm.getColumnInfo_arrivalDate());
 *     request.relation(library_collectionList);
 * 
 *     // Register column [collectionStatusId]
 *     request.mapping(sourceDbm.getColumnInfo_collectionStatusId(), collectionStatusDbm.getColumnInfo_collectionId());
 *     request.relation(library_collectionList);
 *     request.relation(collection_collectionStatusAsOne);
 * 
 *     // Register column [collectionStatusCode]
 *     request.mapping(sourceDbm.getColumnInfo_collectionStatusCode(), collectionStatusLookupDbm.getColumnInfo_collectionStatusCode());
 *     request.relation(library_collectionList);
 *     request.relation(collection_collectionStatusAsOne);
 *     request.relation(collectionStatus_collectionStatusLookup);
 * 
 *     // Register column [collectionStatusName]
 *     request.mapping(sourceDbm.getColumnInfo_collectionStatusName(), collectionStatusLookupDbm.getColumnInfo_collectionStatusName());
 *     request.relation(library_collectionList);
 *     request.relation(collection_collectionStatusAsOne);
 *     request.relation(collectionStatus_collectionStatusLookup);
 * 
 *     // Register column [collectionBookId]
 *     request.mapping(sourceDbm.getColumnInfo_collectionBookId(), bookDbm.getColumnInfo_bookId());
 *     request.relation(library_collectionList);
 *     request.relation(collection_book);
 * 
 *     // Register column [collectionBookName]
 *     request.mapping(sourceDbm.getColumnInfo_collectionBookName(), bookDbm.getColumnInfo_bookName());
 *     request.relation(library_collectionList);
 *     request.relation(collection_book);
 * 
 *     // Register column [collectionBookAuthorId]
 *     request.mapping(sourceDbm.getColumnInfo_collectionBookAuthorId(), authorDbm.getColumnInfo_authorId());
 *     request.relation(library_collectionList);
 *     request.relation(collection_book);
 *     request.relation(book_author);
 * 
 *     // Register column [collectionBookAuthorName]
 *     request.mapping(sourceDbm.getColumnInfo_collectionBookAuthorName(), authorDbm.getColumnInfo_authorName());
 *     request.relation(library_collectionList);
 *     request.relation(collection_book);
 *     request.relation(book_author);
 * 
 *     // Register column [libraryUserLibraryId]
 *     request.mapping(sourceDbm.getColumnInfo_libraryUserLibraryId(), libraryUserDbm.getColumnInfo_libraryId());
 *     request.relation(library_libraryUserList);
 * 
 *     // Register column [libraryUserLbUserId]
 *     request.mapping(sourceDbm.getColumnInfo_libraryUserLbUserId(), libraryUserDbm.getColumnInfo_lbUserId());
 *     request.relation(library_libraryUserList);
 * 
 *     // Register column [lendingLibraryId]
 *     request.mapping(sourceDbm.getColumnInfo_lendingLibraryId(), lendingDbm.getColumnInfo_libraryId());
 *     request.relation(library_libraryUserList);
 *     request.relation(libraryUser_lendingList);
 * 
 *     // Register column [lendingLbUserId]
 *     request.mapping(sourceDbm.getColumnInfo_lendingLbUserId(), lendingDbm.getColumnInfo_lbUserId());
 *     request.relation(library_libraryUserList);
 *     request.relation(libraryUser_lendingList);
 * 
 *     // Register column [lendingDate]
 *     request.mapping(sourceDbm.getColumnInfo_lendingDate(), lendingDbm.getColumnInfo_lendingDate());
 *     request.relation(library_libraryUserList);
 *     request.relation(libraryUser_lendingList);
 * 
 *     // Register column [lendingUUser]
 *     request.mapping(sourceDbm.getColumnInfo_lendingUUser(), lendingDbm.getColumnInfo_UUser());
 *     request.relation(library_libraryUserList);
 *     request.relation(libraryUser_lendingList);
 * 
 *     // Register column [lendingUModule]
 *     request.mapping(sourceDbm.getColumnInfo_lendingUModule(), lendingDbm.getColumnInfo_UModule());
 *     request.relation(library_libraryUserList);
 *     request.relation(libraryUser_lendingList);
 * 
 *     // Register column [lbUserId]
 *     request.mapping(sourceDbm.getColumnInfo_lbUserId(), lbUserDbm.getColumnInfo_lbUserId());
 *     request.relation(library_libraryUserList);
 *     request.relation(libraryUser_lbUser);
 * 
 *     // Register column [lbUserName]
 *     request.mapping(sourceDbm.getColumnInfo_lbUserName(), lbUserDbm.getColumnInfo_lbUserName());
 *     request.relation(library_libraryUserList);
 *     request.relation(libraryUser_lbUser);
 *     
 *     return request;
 * }
 * 
 * private java.util.List&gt;HierarchyFlatLibrary&gt; createFlatBookList() {
 *     (...select and get list)
 *     return flatBookList;
 * }
 * 
 * <pre>
 * @author jflute
 * @param <LOCAL_ENTITY> The type of local entity extends Entity
 */
public class LdHierarchyArranger<LOCAL_ENTITY extends LdEntity> {

    // ===================================================================================
    //                                                                                Main
    //                                                                                ====
    /**
     * Arrange hierarchy.
     * 
     * @param request Hierarchy request. (NotNull)
     * @return The list of local entity. (NotNull)
     */
    public List<LOCAL_ENTITY> arrangeHierarchy(LdHierarchyRequest<LOCAL_ENTITY> request) {
        //        final List<? extends Object> sourceList = request.getSourceEntityList();
        final List<LOCAL_ENTITY> localTableList = new ArrayList<LOCAL_ENTITY>();
        final Map<String, LdEntity> alreadyRegisteredEntityMap = new HashMap<String, LdEntity>();

        // ============
        // Record Loop!
        // ============
        final LdHierarchySourceIterator sourceIterator = request.getSourceIterator();
        while (sourceIterator.hasNext()) {
            final LdHierarchySourceRow sourceRow = sourceIterator.next();
            final TopInfo<LOCAL_ENTITY> topInfo = new TopInfo<LOCAL_ENTITY>();
            topInfo.setHierarchyRequest(request);
            topInfo.setSourceRow(sourceRow);
            topInfo.setAlreadyRegisteredEntityMap(alreadyRegisteredEntityMap);

            final Map<String, Object> primaryKeyMap = extractTopPrimaryKeyMapFromSource(topInfo);
            final String alreadyRegisteredKey = buildTopAlreadyRegisteredKey(primaryKeyMap);
            if (alreadyRegisteredEntityMap.containsKey(alreadyRegisteredKey)) {
                final LdEntity localEntity = alreadyRegisteredEntityMap.get(alreadyRegisteredKey);
                topInfo.setLocalEntity(localEntity);
            } else {
                // Make local entity and register it to the result list.
                final LOCAL_ENTITY localEntity = newLocalEntity(request.getDestinationDBMeta());
                topInfo.setLocalEntity(localEntity);
                localTableList.add(localEntity);
                alreadyRegisteredEntityMap.put(alreadyRegisteredKey, localEntity);
            }

            // ============
            // Column Loop!
            // ============
            doColumnLoop(topInfo);
        }
        return localTableList;
    }

    protected String buildTopAlreadyRegisteredKey(Map<String, Object> primaryKeyMap) {
        return LdHierarchyRequestElement.TOP_KEY + ":" + primaryKeyMap;
    }

    protected void doColumnLoop(TopInfo<LOCAL_ENTITY> topInfo) {
        final LdHierarchyRequest<LOCAL_ENTITY> request = topInfo.getHierarchyRequest();
        final LdEntity localEntity = topInfo.getLocalEntity();
        final List<LdHierarchyRequestElement> requestElementList = request.getRequestElementList();

        // ============
        // Column Loop!
        // ============
        for (LdHierarchyRequestElement requestElement : requestElementList) {
            final List<String> relationPropertyNameList = requestElement.getRelationPropertyNameList();

            // If the column belongs to local entity, inject the value to entity and continue loop.
            if (relationPropertyNameList == null || relationPropertyNameList.isEmpty()) {
                final LdHierarchySourceColumn sourceColumn = requestElement.getSourceColumnInfo();
                final LdHierarchySourceRow sourceRow = topInfo.getSourceRow();
                final Object sourceColumnValue = extractColumnValueFromSource(sourceRow, sourceColumn);
                final LdColumnInfo destinationColumnInfo = requestElement.getDestinationColumnInfo();
                injectColumnValueToDestination(localEntity, destinationColumnInfo, sourceColumnValue);
                continue;
            }

            // ==============
            // Relation Loop!
            // ==============
            doRelationLoop(topInfo, requestElement, relationPropertyNameList);
        }
    }

    protected void doRelationLoop(TopInfo<LOCAL_ENTITY> topInfo, LdHierarchyRequestElement requestElement,
            List<String> relationPropNameList) {
        final LdHierarchyRequest<LOCAL_ENTITY> request = topInfo.getHierarchyRequest();
        final Map<String, LdEntity> alreadyRegisteredEntityMap = topInfo.getAlreadyRegisteredEntityMap();

        // Temporary variables for local
        LdEntity localEntity = topInfo.getLocalEntity();// as Default
        LdDBMeta localDBMeta = request.getDestinationDBMeta();// as Default
        String localRelationPath = LdHierarchyRequestElement.TOP_KEY;// as Default

        // ==============
        // Relation Loop!
        // ==============
        final StringBuilder relationPropKeyStringBuilder = new StringBuilder();
        int relationLoopCount = 0;
        for (String relationPropName : relationPropNameList) {
            if (relationPropKeyStringBuilder.length() > 0) {
                relationPropKeyStringBuilder.append("_");
            }
            relationPropKeyStringBuilder.append(relationPropName);
            final String targetRelationPath = relationPropKeyStringBuilder.toString();
            final LdRelationInfo relationInfo = localDBMeta.getRelationInfo(relationPropName);

            final Map<String, Object> targetPrimaryKeyMap;
            final String alreadyRegisteredRefererKey;
            if (!relationInfo.isReferer()) {
                // =======
                // Foreign
                // =======
                final LdForeignInfo foreignInfo = localDBMeta.getForeignInfo(relationPropName);
                final String foreignPropName = foreignInfo.getForeignPropertyName();

                // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                // If the value of primary key does not exist, break this relation path!
                // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                if (isNotExistPrimaryKey(topInfo, targetRelationPath)) {
                    break;
                }

                targetPrimaryKeyMap = extractPrimaryKeyMapFromSource(topInfo, targetRelationPath);
                alreadyRegisteredRefererKey = targetRelationPath + ":" + targetPrimaryKeyMap.toString();
                if (!alreadyRegisteredEntityMap.containsKey(alreadyRegisteredRefererKey)) {
                    // - - - - - - - - - - - - - - - - - - - - - - -
                    // Initialize the list of referer and inject it.
                    // - - - - - - - - - - - - - - - - - - - - - - -
                    final LdEntity foreignEntity = foreignInfo.getForeignDBMeta().newEntity();
                    injectForeignEntity(localEntity, foreignPropName, foreignEntity);

                    // - - - - - - - - - - - - - - - - - -
                    // Initialize primary key of foreign.
                    // - - - - - - - - - - - - - - - - - -
                    injectForeignPrimaryKey(foreignEntity, targetPrimaryKeyMap);

                    // - - - - - - - - - - - - - - - - - -
                    // Initialize foreign key of local.
                    // - - - - - - - - - - - - - - - - - -
                    injectLocalForeignKey(topInfo, localEntity, foreignInfo, targetRelationPath);

                    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                    // Put foreign entity to the map of already-registered-entity.
                    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                    alreadyRegisteredEntityMap.put(alreadyRegisteredRefererKey.toString(), foreignEntity);
                }
            } else {
                // =======
                // Referer
                // =======
                final LdRefererInfo refererInfo = localDBMeta.getRefererInfo(relationPropName);

                // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                // Extract referer list from current local entity and initialize it if needs.
                // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                List<LdEntity> refererList = extractRefererList(localEntity, refererInfo);
                if (refererList == null) {
                    // Initialize the list of referer and inject it.
                    refererList = new ArrayList<LdEntity>();
                    injectRefererList(localEntity, refererInfo, refererList);
                }

                // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                // If the value of primary key does not exist, break this relation path!
                // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                if (isNotExistPrimaryKey(topInfo, targetRelationPath)) {
                    break;
                }

                targetPrimaryKeyMap = extractPrimaryKeyMapFromSource(topInfo, targetRelationPath);
                alreadyRegisteredRefererKey = targetRelationPath + ":" + targetPrimaryKeyMap.toString();
                if (!alreadyRegisteredEntityMap.containsKey(alreadyRegisteredRefererKey)) {
                    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                    // Initialize referer entity and register it to the list of referer with primary key value.
                    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                    final LdEntity refererEntity = relationInfo.getTargetDBMeta().newEntity();
                    refererList.add(refererEntity);

                    // - - - - - - - - - - - - - - - - - -
                    // Initialize primary key of referer.
                    // - - - - - - - - - - - - - - - - - -
                    injectRefererPrimaryKey(refererEntity, targetPrimaryKeyMap);

                    // - - - - - - - - - - - - - - - - - -
                    // Initialize foreign key of referer.
                    // - - - - - - - - - - - - - - - - - -
                    injectRefererForeignKey(topInfo, refererEntity, refererInfo, localRelationPath);

                    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                    // Put referer entity to the map of already-registered-entity.
                    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                    alreadyRegisteredEntityMap.put(alreadyRegisteredRefererKey.toString(), refererEntity);
                }
            }

            // - - - - - - - - - - - - - - - - - -
            // Set next value to current element.
            // - - - - - - - - - - - - - - - - - -
            localEntity = alreadyRegisteredEntityMap.get(alreadyRegisteredRefererKey);
            localDBMeta = localEntity.getDBMeta();
            localRelationPath = targetRelationPath;

            if (relationLoopCount == (relationPropNameList.size() - 1)) {// The last loop!
                // - - - - - - - - - - - -  
                // Here is the last loop!
                // - - - - - - - - - - - - 
                doLastLoopInjection(topInfo, requestElement, localEntity, targetPrimaryKeyMap);
            }
            ++relationLoopCount;
        }
    }

    private boolean isNotExistPrimaryKey(TopInfo<LOCAL_ENTITY> topInfo, String relationPath) {
        final Map<String, Object> primaryKeyMap = extractPrimaryKeyMapFromSource(topInfo, relationPath);
        final Set<String> keySet = primaryKeyMap.keySet();
        for (String key : keySet) {
            final Object value = primaryKeyMap.get(key);
            if (value == null) {
                return true;
            }
        }
        return false;
    }

    protected void doLastLoopInjection(TopInfo<LOCAL_ENTITY> topInfo, LdHierarchyRequestElement requestElement,
            LdEntity localEntity, Map<String, Object> primaryKeyMap) {
        final LdColumnInfo destinationColumnInfo = requestElement.getDestinationColumnInfo();
        if (!primaryKeyMap.containsKey(destinationColumnInfo.getColumnDbName())) {// The column is primary key!
            final LdHierarchySourceRow sourceRow = topInfo.getSourceRow();
            final LdHierarchySourceColumn sourceColumnInfo = requestElement.getSourceColumnInfo();
            final Object sourceColumnValue = extractColumnValueFromSource(sourceRow, sourceColumnInfo);
            if (sourceColumnValue != null) {
                injectColumnValueToDestination(localEntity, destinationColumnInfo, sourceColumnValue);
            }
        }
    }

    // ===================================================================================
    //                                                                       Extract Logic
    //                                                                       =============
    protected Map<String, Object> extractTopPrimaryKeyMapFromSource(TopInfo<LOCAL_ENTITY> topInfo) {
        return extractPrimaryKeyMapFromSource(topInfo, LdHierarchyRequestElement.TOP_KEY);
    }

    protected Map<String, Object> extractPrimaryKeyMapFromSource(TopInfo<LOCAL_ENTITY> topInfo, String relationPath) {
        final LdHierarchyRequest<LOCAL_ENTITY> request = topInfo.getHierarchyRequest();
        final LdHierarchySourceRow sourceRow = topInfo.getSourceRow();
        final java.util.List<LdHierarchyRequestElement> primaryKeyElement = request.findPrimaryKeyElement(relationPath);
        final java.util.Map<String, Object> primaryKeyMap = new java.util.LinkedHashMap<String, Object>();
        for (LdHierarchyRequestElement element : primaryKeyElement) {
            final LdHierarchySourceColumn sourcePrimaryKey = element.getSourceColumnInfo();
            final Object sourcePrimaryKeyValue = extractColumnValueFromSource(sourceRow, sourcePrimaryKey);
            primaryKeyMap.put(element.getDestinationColumnInfo().getColumnDbName(), sourcePrimaryKeyValue);
        }
        return primaryKeyMap;
    }

    protected Object extractColumnValueFromSource(LdHierarchySourceRow sourceRow,
            LdHierarchySourceColumn sourceColumn) {
        return sourceRow.extractColumnValue(sourceColumn);
    }

    @SuppressWarnings("unchecked")
    protected java.util.List<LdEntity> extractRefererList(LdEntity entity, LdRefererInfo refererInfo) {
        return (java.util.List<LdEntity>) invoke(refererInfo.findGetter(), entity, new Object[] {});
    }

    // ===================================================================================
    //                                                                        Inject Logic
    //                                                                        ============
    /**
     * 
     * @param entity Entity. (NotNull)
     * @param columnInfo Column info. (NotNull)
     * @param columnValue Column value. (NotNull)
     */
    protected void injectColumnValueToDestination(LdEntity entity, LdColumnInfo columnInfo, final Object columnValue) {
        injectColumnValueToDestination(entity, columnInfo.getColumnDbName(), columnValue);
    }

    protected void injectColumnValueToDestination(LdEntity entity, String columnDbName, final Object columnValue) {
        if (columnValue == null) {
            String msg = "The argument[columnValue] should not be null: ";
            msg = msg + " table=" + entity.getTableDbName() + " column=" + columnDbName;
            throw new IllegalStateException(msg);
        }
        final String capPropName = initCap(entity.getDBMeta().getPropertyNameByFlexibleName(columnDbName));
        final Method method = findMethod(entity.getClass(), "set" + capPropName, new Class[] { columnValue.getClass() });
        invoke(method, entity, new Object[] { columnValue });
    }

    protected void injectColumnValueMapToDestination(LdEntity entity, final Map<String, Object> columnValueMap) {
        final Set<String> columnNameSet = columnValueMap.keySet();
        for (String columnName : columnNameSet) {
            final Object columnValue = columnValueMap.get(columnName);
            injectColumnValueToDestination(entity, columnName, columnValue);
        }
    }

    protected void injectForeignEntity(LdEntity entity, String foreignPropName, LdEntity foreignEntity) {
        final String capPropRefererName = initCap(foreignPropName);
        final Method method = findMethod(entity.getClass(), "set" + capPropRefererName, new Class[] { foreignEntity
                .getDBMeta().getEntityType() });
        invoke(method, entity, new Object[] { foreignEntity });
    }

    protected void injectRefererList(LdEntity entity, LdRefererInfo refererInfo, java.util.List<LdEntity> refererList) {
        invoke(refererInfo.findSetter(), entity, new Object[] { refererList });
    }

    protected void injectForeignPrimaryKey(LdEntity foreignEntity, Map<String, Object> foreigPrimaryKeyMap) {
        injectColumnValueMapToDestination(foreignEntity, foreigPrimaryKeyMap);
    }

    protected void injectRefererPrimaryKey(LdEntity refererEntity, Map<String, Object> refererPrimaryKeyMap) {
        injectColumnValueMapToDestination(refererEntity, refererPrimaryKeyMap);
    }

    protected void injectLocalForeignKey(TopInfo<LOCAL_ENTITY> topInfo, LdEntity localEntity,
            LdForeignInfo foreignInfo, String foreignRelationPath) {
        final LdHierarchyRequest<LOCAL_ENTITY> request = topInfo.getHierarchyRequest();
        final Map<String, Object> foreignPrimaryKeyMap = extractPrimaryKeyMapFromSource(topInfo, foreignRelationPath);
        final List<LdHierarchyRequestElement> primaryKeyElementList = request
                .findPrimaryKeyElement(foreignRelationPath);
        final Map<String, Object> localForeignKeyMap = new HashMap<String, Object>();
        for (LdHierarchyRequestElement foreignElement : primaryKeyElementList) {
            final String foreignPrimaryKeyColumnName = foreignElement.getDestinationColumnInfo().getColumnDbName();
            final LdColumnInfo localForeignKeyInfo = foreignInfo.findLocalByForeign(foreignPrimaryKeyColumnName);
            final Object localForeignKeyValue = foreignPrimaryKeyMap.get(foreignPrimaryKeyColumnName);
            localForeignKeyMap.put(localForeignKeyInfo.getColumnDbName(), localForeignKeyValue);
        }
        injectColumnValueMapToDestination(localEntity, localForeignKeyMap);
    }

    protected void injectRefererForeignKey(TopInfo<LOCAL_ENTITY> topInfo, LdEntity refererEntity,
            LdRefererInfo refererInfo, String localRelationPath) {
        final LdHierarchyRequest<LOCAL_ENTITY> request = topInfo.getHierarchyRequest();
        final Map<String, Object> localPrimaryKeyMap = extractPrimaryKeyMapFromSource(topInfo, localRelationPath);
        final List<LdHierarchyRequestElement> primaryKeyElementList = request.findPrimaryKeyElement(localRelationPath);
        final Map<String, Object> refererForeignKeyMap = new HashMap<String, Object>();
        for (LdHierarchyRequestElement localElement : primaryKeyElementList) {
            final String localPrimaryKeyName = localElement.getDestinationColumnInfo().getColumnDbName();
            final LdColumnInfo refererForeignKeyInfo = refererInfo.findRefererByLocal(localPrimaryKeyName);
            final Object refererForeignKeyValue = localPrimaryKeyMap.get(localPrimaryKeyName);
            refererForeignKeyMap.put(refererForeignKeyInfo.getColumnDbName(), refererForeignKeyValue);
        }
        injectColumnValueMapToDestination(refererEntity, refererForeignKeyMap);
    }

    // ===================================================================================
    //                                                                         Other Logic
    //                                                                         ===========
    @SuppressWarnings("unchecked")
    protected LOCAL_ENTITY newLocalEntity(final LdDBMeta destinationDBMeta) {
        final LOCAL_ENTITY localEntity;
        try {
            localEntity = (LOCAL_ENTITY) destinationDBMeta.getEntityType().newInstance();
        } catch (InstantiationException e) {
            throw new IllegalStateException(e);
        } catch (IllegalAccessException e) {
            throw new IllegalStateException(e);
        }
        return localEntity;
    }

    // ===================================================================================
    //                                                                              Helper
    //                                                                              ======
    protected String initCap(final String name) {
        final String capPropRefererName = name.substring(0, 1).toUpperCase() + name.substring(1);
        return capPropRefererName;
    }

    private java.lang.reflect.Method findMethod(Class clazz, String methodName, Class[] argTypes) {
        try {
            return clazz.getMethod(methodName, argTypes);
        } catch (NoSuchMethodException ex) {
            String msg = "class=" + clazz + " method=" + methodName + "-" + java.util.Arrays.asList(argTypes);
            throw new RuntimeException(msg, ex);
        }
    }

    private Object invoke(java.lang.reflect.Method method, Object target, Object[] args) {
        try {
            return method.invoke(target, args);
        } catch (java.lang.reflect.InvocationTargetException ex) {
            Throwable t = ex.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            }
            if (t instanceof Error) {
                throw (Error) t;
            }
            String msg = "target=" + target + " method=" + method + "-" + java.util.Arrays.asList(args);
            throw new RuntimeException(msg, ex);
        } catch (IllegalAccessException ex) {
            String msg = "target=" + target + " method=" + method + "-" + java.util.Arrays.asList(args);
            throw new RuntimeException(msg, ex);
        }
    }

    // ===================================================================================
    //                                                                          Info Class
    //                                                                          ==========
    protected static class TopInfo<LOCAL_ENTITY extends LdEntity> {
        private LdHierarchyRequest<LOCAL_ENTITY> hierarchyRequest;

        private LdHierarchySourceRow sourceRow;

        private LdEntity localEntity;

        private Map<String, LdEntity> alreadyRegisteredEntityMap;

        public LdHierarchySourceRow getSourceRow() {
            return sourceRow;
        }

        public void setSourceRow(LdHierarchySourceRow sourceRow) {
            this.sourceRow = sourceRow;
        }

        public LdEntity getLocalEntity() {
            return localEntity;
        }

        public void setLocalEntity(LdEntity localEntity) {
            this.localEntity = localEntity;
        }

        public Map<String, LdEntity> getAlreadyRegisteredEntityMap() {
            return alreadyRegisteredEntityMap;
        }

        public void setAlreadyRegisteredEntityMap(Map<String, LdEntity> alreadyRegisteredEntityMap) {
            this.alreadyRegisteredEntityMap = alreadyRegisteredEntityMap;
        }

        public LdHierarchyRequest<LOCAL_ENTITY> getHierarchyRequest() {
            return hierarchyRequest;
        }

        public void setHierarchyRequest(LdHierarchyRequest<LOCAL_ENTITY> hierarchyRequest) {
            this.hierarchyRequest = hierarchyRequest;
        }
    }
}
