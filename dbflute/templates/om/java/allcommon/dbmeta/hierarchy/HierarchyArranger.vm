${database.allClassCopyright}package ${glPackageBaseCommonDBMetaHierarchy};

#set ($myClassName = "${glHierarchyArrangerName}")

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import ${glPackageBaseCommon}.${glEntityInterfaceName};
import ${glPackageBaseCommonDBMeta}.${glDBMetaInterfaceName};
import ${glPackageBaseCommonDBMetaInfo}.${glColumnInfoName};
import ${glPackageBaseCommonDBMetaInfo}.${glForeignInfoName};
import ${glPackageBaseCommonDBMetaInfo}.${glRefererInfoName};
import ${glPackageBaseCommonDBMetaInfo}.${glRelationInfoName};

/**
 * The arranger of hierarchy.
 * <pre>
 * ex) LIBRARY Hierarchy
 * 
 * LIBRARY
 *  |1
 *  |--* NEXT_LIBRARY (Referer)
 *  |       |*
 *  |       |--1 LIBRARY (Foreign)
 *  |
 *  |--* COLLECTION (Referer)
 *  |       |1 
 *  |       |--1 COLLECTION_STATUS (Referer)
 *  |       |       |*
 *  |       |       |--1 COLLECTION_STATUS_LOOKUP (Foreign)
 *  |       |
 *  |       |--1 BOOK (Foreign)
 *  |       |     |*
 *  |       |     |--1 AUTHOR (Foreign)
 *  |       |     |--1 PUBLISER (Foreign)
 *  |       |     |--1 GENRE (Foreign)
 *  |       |           |*
 *  |       |           |--1 GENRE (Foreign)
 *  |       |
 *  |       |--* LENDING_COLLECTION (Referer)
 *  |       |
 *  |
 *  |--* LIBRARY_USER (Referer)
 *         |*  |1
 *         |   |--* LENDING (Referer)
 *         |         |1
 *         |         |--* LENDING_COLLECTION (Referer)
 *         |
 *         |--1 LB_USER (Foreign)
 *                 |1
 *                 |--* BLACK_LIST (Referer)
 *                         |1
 *                         |--* BLACK_ACTION (Referer)
 *                                 |*
 *                                 |--1 BLACK_ACTION_LOOKUP (Foreign)
 *          
 *          
 * ex) The SQL of LIBRARY Hierarchy as FLAT
 * 
 * select library.LIBRARY_ID as LIBRARY_ID
 *      , library.LIBRARY_NAME as LIBRARY_NAME
 *      , library.R_USER as R_USER
 *      , library.R_TIMESTAMP as R_TIMESTAMP
 *      , nextBase.LIBRARY_ID as BASE_LIBRARY_ID
 *      , nextBase.NEXT_LIBRARY_ID as NEXT_LIBRARY_ID
 *      , nextBaseNextLibrary.LIBRARY_ID as NEXT_LIBRARY_NEXT_LIBRARY_ID
 *      , nextBaseNextLibrary.LIBRARY_NAME as NEXT_LIBRARY_NEXT_LIBRARY_NAME
 *      , collection.COLLECTION_ID as COLLECTION_ID
 *      , collection.ARRIVAL_DATE as COLLECTION_ARRIVAL_DATE
 *      , collectionStatus.COLLECTION_ID as COLLECTION_STATUS_ID
 *      , collectionStatus.COLLECTION_STATUS_CODE as COLLECTION_STATUS_CODE
 *      , collectionStatusLookup.COLLECTION_STATUS_CODE as COLLECTION_STATUS_CODE
 *      , collectionStatusLookup.COLLECTION_STATUS_NAME as COLLECTION_STATUS_NAME
 *      , book.BOOK_ID as COLLECTION_BOOK_ID
 *      , book.BOOK_NAME as COLLECTION_BOOK_NAME
 *      , author.AUTHOR_ID as COLLECTION_BOOK_AUTHOR_ID
 *      , author.AUTHOR_NAME as COLLECTION_BOOK_AUTHOR_NAME
 *      , libraryUser.LIBRARY_ID as LIBRARY_USER_LIBRARY_ID 
 *      , libraryUser.LB_USER_ID as LIBRARY_USER_LB_USER_ID
 *      , lending.LIBRARY_ID as LENDING_LIBRARY_ID
 *      , lending.LB_USER_ID as LENDING_LB_USER_ID
 *      , lending.LENDING_DATE as LENDING_DATE
 *      , lending.U_USER as LENDING_U_USER
 *      , lending.U_MODULE as LENDING_U_MODULE
 *      , lbUser.LB_USER_ID as LB_USER_ID
 *      , lbUser.LB_USER_NAME as LB_USER_NAME
 *   from LIBRARY library
 *     left outer join NEXT_LIBRARY nextBase on library.LIBRARY_ID = nextBase.LIBRARY_ID
 *       left outer join LIBRARY nextBaseNextLibrary on nextBase.NEXT_LIBRARY_ID = nextBaseNextLibrary.LIBRARY_ID
 *     left outer join COLLECTION collection on library.LIBRARY_ID = collection.LIBRARY_ID
 *       left outer join COLLECTION_STATUS collectionStatus on collection.COLLECTION_ID = collectionStatus.COLLECTION_ID
 *         left outer join COLLECTION_STATUS_LOOKUP collectionStatusLookup on collectionStatus.COLLECTION_STATUS_CODE = collectionStatusLookup.COLLECTION_STATUS_CODE
 *       left outer join BOOK book on collection.BOOK_ID = book.BOOK_ID
 *         left outer join AUTHOR author on book.AUTHOR_ID = author.AUTHOR_ID
 *     left outer join LIBRARY_USER libraryUser on library.LIBRARY_ID = libraryUser.LIBRARY_ID
 *       left outer join LENDING lending on libraryUser.LIBRARY_ID = lending.LIBRARY_ID and libraryUser.LB_USER_ID = lending.LB_USER_ID
 *       left outer join LB_USER lbUser on libraryUser.LB_USER_ID = lbUser.LB_USER_ID
 * 
 * 
 * ex) Invoking Hierarchy Arranger
 * 
 * private List&lt;Library&gt; makeLibraryList() {
 *     final HierarchyRequest request = createHierarchyRequest(createFlatLibraryList());
 *     return new HierarchyArranger&lt;Library&gt;().arrangeHierarchy(request);
 * }
 * 
 * 
 * ex) Creating Hierarchy Request
 * 
 * private HierarchyRequest&lt;Library&gt; createHierarchsyRequest(java.util.List&gt;HierarchyFlatLibrary&gt; flatLibraryList) {
 * 
 *     // Define dbmeta.
 *     final HierarchyFlatLibraryDbm sourceDbm = HierarchyFlatLibraryDbm.getInstance();
 *     final LibraryDbm libraryDbm = LibraryDbm.getInstance();
 *     final NextLibraryDbm nextLibraryDbm = NextLibraryDbm.getInstance();
 *     final CollectionDbm collectionDbm = CollectionDbm.getInstance();
 *     final CollectionStatusDbm collectionStatusDbm = CollectionStatusDbm.getInstance();
 *     final CollectionStatusLookupDbm collectionStatusLookupDbm = CollectionStatusLookupDbm.getInstance();
 *     final BookDbm bookDbm = BookDbm.getInstance();
 *     final AuthorDbm authorDbm = AuthorDbm.getInstance();
 *     final LendingDbm lendingDbm = LendingDbm.getInstance();
 *     final LbUserDbm lbUserDbm = LbUserDbm.getInstance();
 *
 *     // Define hierarychy request as library.
 *     final HierarchyRequest&lt;Library&gt; request = new HierarchyRequest&lt;Library&gt;(Library.class);
 * 
 *     // Register the list of source iterator. (by calling creator for flat library list)
 *     request.registerSourceBeanList(flatLibraryList);
 *
 *     // Create relation trace.
 *     final LibraryRelationTrace trace = libraryDbm.createRelationTrace();
 *     
 *     // Register column [libraryId]
 *     request.mapping(sourceDbm.columnLibraryId(), libraryDbm.columnLibraryId());
 *     
 *     // Register column [libraryName]
 *     request.mapping(sourceDbm.columnLibraryName(), libraryDbm.columnLibraryName());
 *     
 *     // Register column [RUser]
 *     request.mapping(sourceDbm.columnRUser(), libraryDbm.columnRUser());
 *     
 *     // Register column [RTimestamp]
 *     request.mapping(sourceDbm.columnRTimestamp(), libraryDbm.columnRTimestamp());
 *     
 *     // Register column [baseLibraryId]
 *     request.mapping(sourceDbm.columnBaseLibraryId(), nextLibraryDbm.columnLibraryId());
 *     request.relation(trace.refererNextLibraryByBaseIdList().end());
 *     
 *     // Register column [nextLibraryId]
 *     request.mapping(sourceDbm.columnNextLibraryId(), nextLibraryDbm.columnNextLibraryId());
 *     request.relation(trace.refererNextLibraryByBaseIdList().end());
 *     
 *     // Register column [nextLibraryNextLibraryId]
 *     request.mapping(sourceDbm.columnNextLibraryNextLibraryId(), libraryDbm.columnLibraryId());
 *     request.relation(trace.refererNextLibraryByBaseIdList().foreignLibraryByNextId().end());
 *     
 *     // Register column [nextLibraryNextLibraryName]
 *     request.mapping(sourceDbm.columnNextLibraryNextLibraryName(), libraryDbm.columnLibraryName());
 *     request.relation(trace.refererNextLibraryByBaseIdList().foreignLibraryByNextId().end());
 *     
 *     // Register column [collectionId]
 *     request.mapping(sourceDbm.columnCollectionId(), collectionDbm.columnCollectionId());
 *     request.relation(trace.refererCollectionList().end());
 *     
 *     // Register column [arrivalDate]
 *     request.mapping(sourceDbm.columnCollectionArrivalDate(), collectionDbm.columnArrivalDate());
 *     request.relation(trace.refererCollectionList().end());
 *     
 *     // Register column [collectionStatusId]
 *     request.mapping(sourceDbm.columnCollectionStatusId(), collectionStatusDbm.columnCollectionId());
 *     request.relation(trace.refererCollectionList().foreignCollectionStatusAsOne().end());
 *     
 *     // Register column [collectionStatusCode]
 *     request.mapping(sourceDbm.columnCollectionStatusCode(), collectionStatusLookupDbm.columnCollectionStatusCode());
 *     request.relation(trace.refererCollectionList().foreignCollectionStatusAsOne().foreignCollectionStatusLookup().end());
 *     
 *     // Register column [collectionStatusName]
 *     request.mapping(sourceDbm.columnCollectionStatusName(), collectionStatusLookupDbm.columnCollectionStatusName());
 *     request.relation(trace.refererCollectionList().foreignCollectionStatusAsOne().foreignCollectionStatusLookup().end());
 *     
 *     // Register column [collectionBookId]
 *     request.mapping(sourceDbm.columnCollectionBookId(), bookDbm.columnBookId());
 *     request.relation(trace.refererCollectionList().foreignBook().end());
 *     
 *     // Register column [collectionBookName]
 *     request.mapping(sourceDbm.columnCollectionBookName(), bookDbm.columnBookName());
 *     request.relation(trace.refererCollectionList().foreignBook().end());
 *     
 *     // Register column [collectionBookAuthorId]
 *     request.mapping(sourceDbm.columnCollectionBookAuthorId(), authorDbm.columnAuthorId());
 *     request.relation(trace.refererCollectionList().foreignBook().foreignAuthor().end());
 *     
 *     // Register column [collectionBookAuthorName]
 *     request.mapping(sourceDbm.columnCollectionBookAuthorName(), authorDbm.columnAuthorName());
 *     request.relation(trace.refererCollectionList().foreignBook().foreignAuthor().end());
 *     
 *     // Register column [libraryUserLibraryId]
 *     request.mapping(sourceDbm.columnLibraryUserLibraryId(), libraryUserDbm.columnLibraryId());
 *     request.relation(trace.refererLibraryUserList().end());
 *     
 *     // Register column [libraryUserLbUserId]
 *     request.mapping(sourceDbm.columnLibraryUserLbUserId(), libraryUserDbm.columnLbUserId());
 *     request.relation(trace.refererLibraryUserList().end());
 *     
 *     // Register column [lendingLibraryId]
 *     request.mapping(sourceDbm.columnLendingLibraryId(), lendingDbm.columnLibraryId());
 *     request.relation(trace.refererLibraryUserList().refererLendingList().end());
 *     
 *     // Register column [lendingLbUserId]
 *     request.mapping(sourceDbm.columnLendingLbUserId(), lendingDbm.columnLbUserId());
 *     request.relation(trace.refererLibraryUserList().refererLendingList().end());
 *     
 *     // Register column [lendingDate]
 *     request.mapping(sourceDbm.columnLendingDate(), lendingDbm.columnLendingDate());
 *     request.relation(trace.refererLibraryUserList().refererLendingList().end());
 *     
 *     // Register column [lendingUUser]
 *     request.mapping(sourceDbm.columnLendingUUser(), lendingDbm.columnUUser());
 *     request.relation(trace.refererLibraryUserList().refererLendingList().end());
 *     
 *     // Register column [lendingUModule]
 *     request.mapping(sourceDbm.columnLendingUModule(), lendingDbm.columnUModule());
 *     request.relation(trace.refererLibraryUserList().refererLendingList().end());
 *     
 *     // Register column [lbUserId]
 *     request.mapping(sourceDbm.columnLbUserId(), lbUserDbm.columnLbUserId());
 *     request.relation(trace.refererLibraryUserList().foreignLbUser().end());
 *     
 *     // Register column [lbUserName]
 *     request.mapping(sourceDbm.columnLbUserName(), lbUserDbm.columnLbUserName());
 *     request.relation(trace.refererLibraryUserList().foreignLbUser().end());
 *     
 *     return request;
 * }
 * 
 * private java.util.List&gt;HierarchyFlatLibrary&gt; createFlatLibraryList() {
 *     (...select and get list)
 *     return flatLibraryList;
 * }
 * 
 * <pre>
 * @author ${database.ClassAuthor}
 * @param <LOCAL_ENTITY> The type of local entity extends Entity
 */
public class ${myClassName}<LOCAL_ENTITY extends ${glEntityInterfaceName}> {

    // ===================================================================================
    //                                                                                Main
    //                                                                                ====
    /**
     * Arrange hierarchy.
     * 
     * @param request Hierarchy request. (NotNull)
     * @return The list of local entity. (NotNull)
     */
    public List<LOCAL_ENTITY> arrangeHierarchy(${glHierarchyRequestName}<LOCAL_ENTITY> request) {
        //        final List<? extends Object> sourceList = request.getSourceEntityList();
        final List<LOCAL_ENTITY> localTableList = new ArrayList<LOCAL_ENTITY>();
        final Map<String, ${glEntityInterfaceName}> alreadyRegisteredEntityMap = new HashMap<String, ${glEntityInterfaceName}>();

        // ============
        // Record Loop!
        // ============
        final ${glHierarchySourceIteratorName} sourceIterator = request.getSourceIterator();
        while (sourceIterator.hasNext()) {
            final ${glHierarchySourceRowName} sourceRow = sourceIterator.next();
            final TopInfo<LOCAL_ENTITY> topInfo = new TopInfo<LOCAL_ENTITY>();
            topInfo.setHierarchyRequest(request);
            topInfo.setSourceRow(sourceRow);
            topInfo.setAlreadyRegisteredEntityMap(alreadyRegisteredEntityMap);

            final Map<String, Object> primaryKeyMap = extractTopPrimaryKeyMapFromSource(topInfo);
            final String alreadyRegisteredKey = buildTopAlreadyRegisteredKey(primaryKeyMap);
            if (alreadyRegisteredEntityMap.containsKey(alreadyRegisteredKey)) {
                final ${glEntityInterfaceName} localEntity = alreadyRegisteredEntityMap.get(alreadyRegisteredKey);
                topInfo.setLocalEntity(localEntity);
            } else {
                // Make local entity and register it to the result list.
                final LOCAL_ENTITY localEntity = newLocalEntity(request.getDestinationDBMeta());
                topInfo.setLocalEntity(localEntity);
                localTableList.add(localEntity);
                alreadyRegisteredEntityMap.put(alreadyRegisteredKey, localEntity);
            }

            // ============
            // Column Loop!
            // ============
            doColumnLoop(topInfo);
        }
        return localTableList;
    }

    /**
     * Build top already-registered key.
     * 
     * @param primaryKeyMap The map of primary key. (NotNull)
     * @return Top already-registered key. (NotNull)
     */
    protected String buildTopAlreadyRegisteredKey(Map<String, Object> primaryKeyMap) {
        return ${glHierarchyRequestElementName}.TOP_KEY + ":" + primaryKeyMap;
    }

    /**
     * Do column loop.
     * 
     * @param topInfo The information object of top that has generics of the type of local entity. (NotNull)
     */
    protected void doColumnLoop(TopInfo<LOCAL_ENTITY> topInfo) {
        final ${glHierarchyRequestName}<LOCAL_ENTITY> request = topInfo.getHierarchyRequest();
        final ${glEntityInterfaceName} localEntity = topInfo.getLocalEntity();
        final List<${glHierarchyRequestElementName}> requestElementList = request.getRequestElementList();

        // ============
        // Column Loop!
        // ============
        for (${glHierarchyRequestElementName} requestElement : requestElementList) {
            final List<String> relationPropertyNameList = requestElement.getRelationPropertyNameList();

            // If the column belongs to local entity, inject the value to entity and continue loop.
            if (relationPropertyNameList == null || relationPropertyNameList.isEmpty()) {
                final ${glHierarchySourceColumnName} sourceColumn = requestElement.getSourceColumnInfo();
                final ${glHierarchySourceRowName} sourceRow = topInfo.getSourceRow();
                final Object sourceColumnValue = extractColumnValueFromSource(sourceRow, sourceColumn);
                final ${glColumnInfoName} destinationColumnInfo = requestElement.getDestinationColumnInfo();
                injectColumnValueToDestination(localEntity, destinationColumnInfo, sourceColumnValue);
                continue;
            }

            // ==============
            // Relation Loop!
            // ==============
            doRelationLoop(topInfo, requestElement, relationPropertyNameList);
        }
    }

    /**
     * Do relation loop.
     * 
     * @param topInfo The information object of top that has generics of local entity. (NotNull)
     * @param requestElement The element of request. This is relation loop resource. (NotNull)
     * @param relationPropNameList The list of relation property name that has generics of string. (NotNull)
     */
    protected void doRelationLoop(TopInfo<LOCAL_ENTITY> topInfo, ${glHierarchyRequestElementName} requestElement, java.util.List<String> relationPropNameList) {
        final ${glHierarchyRequestName}<LOCAL_ENTITY> request = topInfo.getHierarchyRequest();
        final Map<String, ${glEntityInterfaceName}> alreadyRegisteredEntityMap = topInfo.getAlreadyRegisteredEntityMap();

        // Temporary variables for local
        ${glEntityInterfaceName} localEntity = topInfo.getLocalEntity();// as Default
        ${glDBMetaInterfaceName} localDBMeta = request.getDestinationDBMeta();// as Default
        String localRelationPath = ${glHierarchyRequestElementName}.TOP_KEY;// as Default

        // ==============
        // Relation Loop!
        // ==============
        final StringBuilder relationPropKeyStringBuilder = new StringBuilder();
        int relationLoopCount = 0;
        for (String relationPropName : relationPropNameList) {
            if (relationPropKeyStringBuilder.length() > 0) {
                relationPropKeyStringBuilder.append("_");
            }
            relationPropKeyStringBuilder.append(relationPropName);
            final String targetRelationPath = relationPropKeyStringBuilder.toString();
            final ${glRelationInfoName} relationInfo = localDBMeta.findRelationInfo(relationPropName);

            final Map<String, Object> targetPrimaryKeyMap;
            final String alreadyRegisteredRefererKey;
            if (!relationInfo.isReferer()) {
                // =======
                // Foreign
                // =======
                final ${glForeignInfoName} foreignInfo = localDBMeta.findForeignInfo(relationPropName);
                final String foreignPropName = foreignInfo.getForeignPropertyName();

                // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                // If the value of primary key does not exist, break this relation path!
                // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                if (isNotExistPrimaryKey(topInfo, targetRelationPath)) {
                    break;
                }

                targetPrimaryKeyMap = extractPrimaryKeyMapFromSource(topInfo, targetRelationPath);
                alreadyRegisteredRefererKey = targetRelationPath + ":" + targetPrimaryKeyMap.toString();
                if (!alreadyRegisteredEntityMap.containsKey(alreadyRegisteredRefererKey)) {
                    // - - - - - - - - - - - - - - - - - - - - - - -
                    // Initialize the list of referer and inject it.
                    // - - - - - - - - - - - - - - - - - - - - - - -
                    final ${glEntityInterfaceName} foreignEntity = foreignInfo.getForeignDBMeta().newEntity();
                    injectForeignEntity(localEntity, foreignPropName, foreignEntity);

                    // - - - - - - - - - - - - - - - - - -
                    // Initialize primary key of foreign.
                    // - - - - - - - - - - - - - - - - - -
                    injectForeignPrimaryKey(foreignEntity, targetPrimaryKeyMap);

                    // - - - - - - - - - - - - - - - - - -
                    // Initialize foreign key of local.
                    // - - - - - - - - - - - - - - - - - -
                    injectLocalForeignKey(topInfo, localEntity, foreignInfo, targetRelationPath);

                    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                    // Put foreign entity to the map of already-registered-entity.
                    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                    alreadyRegisteredEntityMap.put(alreadyRegisteredRefererKey.toString(), foreignEntity);
                }
            } else {
                // =======
                // Referer
                // =======
                final ${glRefererInfoName} refererInfo = localDBMeta.findRefererInfo(relationPropName);

                // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                // Extract referer list from current local entity and initialize it if needs.
                // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                List<${glEntityInterfaceName}> refererList = extractRefererList(localEntity, refererInfo);
                if (refererList == null) {
                    // Initialize the list of referer and inject it.
                    refererList = new ArrayList<${glEntityInterfaceName}>();
                    injectRefererList(localEntity, refererInfo, refererList);
                }

                // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                // If the value of primary key does not exist, break this relation path!
                // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                if (isNotExistPrimaryKey(topInfo, targetRelationPath)) {
                    break;
                }

                targetPrimaryKeyMap = extractPrimaryKeyMapFromSource(topInfo, targetRelationPath);
                alreadyRegisteredRefererKey = targetRelationPath + ":" + targetPrimaryKeyMap.toString();
                if (!alreadyRegisteredEntityMap.containsKey(alreadyRegisteredRefererKey)) {
                    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                    // Initialize referer entity and register it to the list of referer with primary key value.
                    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                    final ${glEntityInterfaceName} refererEntity = relationInfo.getTargetDBMeta().newEntity();
                    refererList.add(refererEntity);

                    // - - - - - - - - - - - - - - - - - -
                    // Initialize primary key of referer.
                    // - - - - - - - - - - - - - - - - - -
                    injectRefererPrimaryKey(refererEntity, targetPrimaryKeyMap);

                    // - - - - - - - - - - - - - - - - - -
                    // Initialize foreign key of referer.
                    // - - - - - - - - - - - - - - - - - -
                    injectRefererForeignKey(topInfo, refererEntity, refererInfo, localRelationPath);

                    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                    // Put referer entity to the map of already-registered-entity.
                    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                    alreadyRegisteredEntityMap.put(alreadyRegisteredRefererKey.toString(), refererEntity);
                }
            }

            // - - - - - - - - - - - - - - - - - -
            // Set next value to current element.
            // - - - - - - - - - - - - - - - - - -
            localEntity = alreadyRegisteredEntityMap.get(alreadyRegisteredRefererKey);
            localDBMeta = localEntity.getDBMeta();
            localRelationPath = targetRelationPath;

            if (relationLoopCount == (relationPropNameList.size() - 1)) {// The last loop!
                // - - - - - - - - - - - -  
                // Here is the last loop!
                // - - - - - - - - - - - - 
                doLastLoopInjection(topInfo, requestElement, localEntity, targetPrimaryKeyMap);
            }
            ++relationLoopCount;
        }
    }

    /**
     * Is not existing primary key at the relation path?.
     * 
     * @param topInfo The information object of top that has generics of local entity. (NotNull)
     * @param relationPath The path of relation. (NotNull)
     * @return Determination.
     */
    protected boolean isNotExistPrimaryKey(TopInfo<LOCAL_ENTITY> topInfo, String relationPath) {
        final Map<String, Object> primaryKeyMap = extractPrimaryKeyMapFromSource(topInfo, relationPath);
        final Set<String> keySet = primaryKeyMap.keySet();
        for (String key : keySet) {
            final Object value = primaryKeyMap.get(key);
            if (value == null) {
                return true;
            }
        }
        return false;
    }

    /**
     * Do last loop injection.
     * 
     * @param topInfo The information object of top that has generics of local entity. (NotNull)
     * @param requestElement The element of request. This is relation loop resource. (NotNull)
     * @param localEntity The interface of local entity. (NotNull)
     * @param primaryKeyMap The map of primary key. (NotNull)
     */
    protected void doLastLoopInjection(TopInfo<LOCAL_ENTITY> topInfo, ${glHierarchyRequestElementName} requestElement,
                                       ${glEntityInterfaceName} localEntity, Map<String, Object> primaryKeyMap) {
        final ${glColumnInfoName} destinationColumnInfo = requestElement.getDestinationColumnInfo();
        if (!primaryKeyMap.containsKey(destinationColumnInfo.getColumnDbName())) {// The column is primary key!
            final ${glHierarchySourceRowName} sourceRow = topInfo.getSourceRow();
            final ${glHierarchySourceColumnName} sourceColumnInfo = requestElement.getSourceColumnInfo();
            final Object sourceColumnValue = extractColumnValueFromSource(sourceRow, sourceColumnInfo);
            if (sourceColumnValue != null) {
                injectColumnValueToDestination(localEntity, destinationColumnInfo, sourceColumnValue);
            }
        }
    }

    // ===================================================================================
    //                                                                       Extract Logic
    //                                                                       =============
    protected Map<String, Object> extractTopPrimaryKeyMapFromSource(TopInfo<LOCAL_ENTITY> topInfo) {
        return extractPrimaryKeyMapFromSource(topInfo, ${glHierarchyRequestElementName}.TOP_KEY);
    }

    protected Map<String, Object> extractPrimaryKeyMapFromSource(TopInfo<LOCAL_ENTITY> topInfo, String relationPath) {
        final ${glHierarchyRequestName}<LOCAL_ENTITY> request = topInfo.getHierarchyRequest();
        final ${glHierarchySourceRowName} sourceRow = topInfo.getSourceRow();
        final java.util.List<${glHierarchyRequestElementName}> primaryKeyElement = request.findPrimaryKeyElement(relationPath);
        final java.util.Map<String, Object> primaryKeyMap = new java.util.LinkedHashMap<String, Object>();
        for (${glHierarchyRequestElementName} element : primaryKeyElement) {
            final ${glHierarchySourceColumnName} sourcePrimaryKey = element.getSourceColumnInfo();
            final Object sourcePrimaryKeyValue = extractColumnValueFromSource(sourceRow, sourcePrimaryKey);
            primaryKeyMap.put(element.getDestinationColumnInfo().getColumnDbName(), sourcePrimaryKeyValue);
        }
        return primaryKeyMap;
    }

    protected Object extractColumnValueFromSource(${glHierarchySourceRowName} sourceRow,
            ${glHierarchySourceColumnName} sourceColumn) {
        return sourceRow.extractColumnValue(sourceColumn);
    }

    @SuppressWarnings("unchecked")
    protected java.util.List<${glEntityInterfaceName}> extractRefererList(${glEntityInterfaceName} entity, ${glRefererInfoName} refererInfo) {
        return (java.util.List<${glEntityInterfaceName}>) invoke(refererInfo.findGetter(), entity, new Object[] {});
    }

    // ===================================================================================
    //                                                                        Inject Logic
    //                                                                        ============
    /**
     * 
     * @param entity Entity. (NotNull)
     * @param columnInfo Column info. (NotNull)
     * @param columnValue Column value. (NotNull)
     */
    protected void injectColumnValueToDestination(${glEntityInterfaceName} entity, ${glColumnInfoName} columnInfo, final Object columnValue) {
        injectColumnValueToDestination(entity, columnInfo.getColumnDbName(), columnValue);
    }

    protected void injectColumnValueToDestination(${glEntityInterfaceName} entity, String columnDbName, final Object columnValue) {
        if (columnValue == null) {
            String msg = "The argument[columnValue] should not be null: ";
            msg = msg + " table=" + entity.getTableDbName() + " column=" + columnDbName;
            throw new IllegalStateException(msg);
        }
        invoke(entity.getDBMeta().findColumnInfo(columnDbName).findSetter(), entity, new Object[] { columnValue });
    }

    protected void injectColumnValueMapToDestination(${glEntityInterfaceName} entity, final Map<String, Object> columnValueMap) {
        final Set<String> columnNameSet = columnValueMap.keySet();
        for (String columnName : columnNameSet) {
            final Object columnValue = columnValueMap.get(columnName);
            injectColumnValueToDestination(entity, columnName, columnValue);
        }
    }

    protected void injectForeignEntity(${glEntityInterfaceName} entity, String foreignPropName, ${glEntityInterfaceName} foreignEntity) {
        final String capPropRefererName = initCap(foreignPropName);
        final Method method = findMethod(entity.getClass(), "set" + capPropRefererName, new Class[] { foreignEntity
                .getDBMeta().getEntityType() });
        invoke(method, entity, new Object[] { foreignEntity });
    }

    protected void injectRefererList(${glEntityInterfaceName} entity, ${glRefererInfoName} refererInfo, java.util.List<${glEntityInterfaceName}> refererList) {
        invoke(refererInfo.findSetter(), entity, new Object[] { refererList });
    }

    protected void injectForeignPrimaryKey(${glEntityInterfaceName} foreignEntity, Map<String, Object> foreigPrimaryKeyMap) {
        injectColumnValueMapToDestination(foreignEntity, foreigPrimaryKeyMap);
    }

    protected void injectRefererPrimaryKey(${glEntityInterfaceName} refererEntity, Map<String, Object> refererPrimaryKeyMap) {
        injectColumnValueMapToDestination(refererEntity, refererPrimaryKeyMap);
    }

    protected void injectLocalForeignKey(TopInfo<LOCAL_ENTITY> topInfo, ${glEntityInterfaceName} localEntity,
            ${glForeignInfoName} foreignInfo, String foreignRelationPath) {
        final ${glHierarchyRequestName}<LOCAL_ENTITY> request = topInfo.getHierarchyRequest();
        final Map<String, Object> foreignPrimaryKeyMap = extractPrimaryKeyMapFromSource(topInfo, foreignRelationPath);
        final List<${glHierarchyRequestElementName}> primaryKeyElementList = request
                .findPrimaryKeyElement(foreignRelationPath);
        final Map<String, Object> localForeignKeyMap = new HashMap<String, Object>();
        for (${glHierarchyRequestElementName} foreignElement : primaryKeyElementList) {
            final String foreignPrimaryKeyColumnName = foreignElement.getDestinationColumnInfo().getColumnDbName();
            final ${glColumnInfoName} localForeignKeyInfo = foreignInfo.findLocalByForeign(foreignPrimaryKeyColumnName);
            final Object localForeignKeyValue = foreignPrimaryKeyMap.get(foreignPrimaryKeyColumnName);
            localForeignKeyMap.put(localForeignKeyInfo.getColumnDbName(), localForeignKeyValue);
        }
        injectColumnValueMapToDestination(localEntity, localForeignKeyMap);
    }

    protected void injectRefererForeignKey(TopInfo<LOCAL_ENTITY> topInfo, ${glEntityInterfaceName} refererEntity,
            ${glRefererInfoName} refererInfo, String localRelationPath) {
        final ${glHierarchyRequestName}<LOCAL_ENTITY> request = topInfo.getHierarchyRequest();
        final Map<String, Object> localPrimaryKeyMap = extractPrimaryKeyMapFromSource(topInfo, localRelationPath);
        final List<${glHierarchyRequestElementName}> primaryKeyElementList = request.findPrimaryKeyElement(localRelationPath);
        final Map<String, Object> refererForeignKeyMap = new HashMap<String, Object>();
        for (${glHierarchyRequestElementName} localElement : primaryKeyElementList) {
            final String localPrimaryKeyName = localElement.getDestinationColumnInfo().getColumnDbName();
            final ${glColumnInfoName} refererForeignKeyInfo = refererInfo.findRefererByLocal(localPrimaryKeyName);
            final Object refererForeignKeyValue = localPrimaryKeyMap.get(localPrimaryKeyName);
            refererForeignKeyMap.put(refererForeignKeyInfo.getColumnDbName(), refererForeignKeyValue);
        }
        injectColumnValueMapToDestination(refererEntity, refererForeignKeyMap);
    }

    // ===================================================================================
    //                                                                         Other Logic
    //                                                                         ===========
    @SuppressWarnings("unchecked")
    protected LOCAL_ENTITY newLocalEntity(final ${glDBMetaInterfaceName} destinationDBMeta) {
        final LOCAL_ENTITY localEntity;
        try {
            localEntity = (LOCAL_ENTITY) destinationDBMeta.getEntityType().newInstance();
        } catch (InstantiationException e) {
            throw new IllegalStateException(e);
        } catch (IllegalAccessException e) {
            throw new IllegalStateException(e);
        }
        return localEntity;
    }

    // ===================================================================================
    //                                                                              Helper
    //                                                                              ======
    protected String initCap(final String name) {
        final String capPropRefererName = name.substring(0, 1).toUpperCase() + name.substring(1);
        return capPropRefererName;
    }

    private java.lang.reflect.Method findMethod(Class clazz, String methodName, Class[] argTypes) {
        try {
            return clazz.getMethod(methodName, argTypes);
        } catch (NoSuchMethodException ex) {
            String msg = "class=" + clazz + " method=" + methodName + "-" + java.util.Arrays.asList(argTypes);
            throw new RuntimeException(msg, ex);
        }
    }

    private Object invoke(java.lang.reflect.Method method, Object target, Object[] args) {
        try {
            return method.invoke(target, args);
        } catch (java.lang.reflect.InvocationTargetException ex) {
            Throwable t = ex.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            }
            if (t instanceof Error) {
                throw (Error) t;
            }
            String msg = "target=" + target + " method=" + method + "-" + java.util.Arrays.asList(args);
            throw new RuntimeException(msg, ex);
        } catch (IllegalAccessException ex) {
            String msg = "target=" + target + " method=" + method + "-" + java.util.Arrays.asList(args);
            throw new RuntimeException(msg, ex);
        }
    }

    // ===================================================================================
    //                                                                          Info Class
    //                                                                          ==========
    protected static class TopInfo<LOCAL_ENTITY extends ${glEntityInterfaceName}> {
        private ${glHierarchyRequestName}<LOCAL_ENTITY> hierarchyRequest;

        private ${glHierarchySourceRowName} sourceRow;

        private ${glEntityInterfaceName} localEntity;

        private Map<String, ${glEntityInterfaceName}> alreadyRegisteredEntityMap;

        public ${glHierarchySourceRowName} getSourceRow() {
            return sourceRow;
        }

        public void setSourceRow(${glHierarchySourceRowName} sourceRow) {
            this.sourceRow = sourceRow;
        }

        public ${glEntityInterfaceName} getLocalEntity() {
            return localEntity;
        }

        public void setLocalEntity(${glEntityInterfaceName} localEntity) {
            this.localEntity = localEntity;
        }

        public Map<String, ${glEntityInterfaceName}> getAlreadyRegisteredEntityMap() {
            return alreadyRegisteredEntityMap;
        }

        public void setAlreadyRegisteredEntityMap(Map<String, ${glEntityInterfaceName}> alreadyRegisteredEntityMap) {
            this.alreadyRegisteredEntityMap = alreadyRegisteredEntityMap;
        }

        public ${glHierarchyRequestName}<LOCAL_ENTITY> getHierarchyRequest() {
            return hierarchyRequest;
        }

        public void setHierarchyRequest(${glHierarchyRequestName}<LOCAL_ENTITY> hierarchyRequest) {
            this.hierarchyRequest = hierarchyRequest;
        }
    }
}
