package ${glPackageBaseCommonDBMeta};

#set ($myClassName = "${glDBMetaAbstractName}")

import ${glPackageBaseCommon}.${glEntityInterfaceName};
import ${glPackageBaseCommonHelper}.${glMapListStringName};
import ${glPackageBaseCommonHelper}.${glMapListStringImplName};
import ${glPackageBaseCommonHelper}.${glMapStringBuilderName};
import ${glPackageBaseCommonHelper}.${glMapStringBuilderImplName};

/**
 * The abstract class of dbmeta.
 * 
 * @author ${database.ClassAuthor}
 */
public abstract class ${myClassName} implements ${glDBMetaInterfaceName} {

    // =====================================================================================
    //                                                                         Name Handling
    //                                                                         =============
    /**
     * ${database.ImplementComment}
     * 
     * @param dbName Db-name. (NotNull)
     * @return Determination.
     */
    public boolean isExistDbName(String dbName) {
        return getDbNameCapPropNameMap().containsKey(dbName);
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param capPropName Cap-prop-name. (NotNull)
     * @return Determination.
     */
    public boolean isExistCapPropName(String capPropName) {
        return getCapPropNameDbNameMap().containsKey(capPropName);
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param uncapPropName Uncap-prop-name. (NotNull)
     * @return Determination.
     */
    public boolean isExistUncapPropName(String uncapPropName) {
        return getUncapPropNameDbNameMap().containsKey(uncapPropName);
    }

    /// <sumarry>
    /// ${database.ImplementComment}
    /// </sumarry>
    /// <param name="multiName">Multi-name.</param>
    /// <returns>Determination.</returns>
    public boolean isExistMultiName(String multiName) {
        if (isExistDbName(multiName)) {
            return true;
        }
        if (isExistCapPropName(multiName)) {
            return true;
        }
        if (isExistUncapPropName(multiName)) {
            return true;
        }
        return false;
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param capPropName Cap-prop-name. (NotNull)
     * @return Db-name. (NotNull)
     */
    public String getDbNameByCapPropName(String capPropName) {
        assertStringNotNullAndNotTrimmedEmpty("capPropName", capPropName);
        final String dbName = (String)getCapPropNameDbNameMap().get(capPropName);
        if (dbName == null) {
            String msg = "The capPropNameDbNameMap didn't contain the key of '" + capPropName + "': ";
            throw new IllegalStateException(msg + getCapPropNameDbNameMap());
        }
        return dbName;
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param uncapPropName Uncap-prop-name. (NotNull)
     * @return {db-name : java-name} map. (NotNull)
     */
    public String getDbNameByUncapPropName(String uncapPropName) {
        assertStringNotNullAndNotTrimmedEmpty("uncapPropName", uncapPropName);
        final String dbName = (String)getUncapPropNameDbNameMap().get(uncapPropName);
        if (dbName == null) {
            String msg = "The uncapPropNameDbNameMap didn't contain the key of '" + uncapPropName + "': ";
            throw new IllegalStateException(msg + getUncapPropNameDbNameMap());
        }
        return dbName;
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param dbName Db-name. (NotNull)
     * @return Cap-prop-name. (NotNull)
     */
    public String getCapPropNameByDbName(String dbName) {
        assertStringNotNullAndNotTrimmedEmpty("dbName", dbName);
        final String capPropName = (String)getDbNameCapPropNameMap().get(dbName);
        if (capPropName == null) {
            String msg = "The dbNameCapPropNameMap didn't contain the key of '" + dbName + "': ";
            throw new IllegalStateException(msg + getDbNameCapPropNameMap());
        }
        return capPropName;
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param uncapPropName Uncap-prop-name. (NotNull)
     * @return Cap-prop-name. (NotNull)
     */
    public String getCapPropNameByUncapPropName(String uncapPropName) {
        assertStringNotNullAndNotTrimmedEmpty("uncapPropName", uncapPropName);
        final String dbName = getDbNameByMultiName(uncapPropName);
        final String capPropName = (String)getDbNameCapPropNameMap().get(dbName);
        if (capPropName == null) {
            String msg = "The dbNameCapPropNameMap didn't contain the key of '" + dbName + "': ";
            throw new IllegalStateException(msg + getDbNameCapPropNameMap());
        }
        return capPropName;
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param dbName Db-name. (NotNull)
     * @return Uncap-prop-name. (NotNull)
     */
    public String getUncapPropNameByDbName(String dbName) {
        assertStringNotNullAndNotTrimmedEmpty("dbName", dbName);
        final String uncapPropName = (String)getDbNameUncapPropNameMap().get(dbName);
        if (uncapPropName == null) {
            String msg = "The dbNameUncapPropNameMap didn't contain the key of '" + dbName + "': ";
            throw new IllegalStateException(msg + getDbNameUncapPropNameMap());
        }
        return uncapPropName;
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param capPropName Cap-prop-name. (NotNull)
     * @return Uncap-prop-name. (NotNull)
     */
    public String getUncapPropNameByCapPropName(String capPropName) {
        assertStringNotNullAndNotTrimmedEmpty("capPropName", capPropName);
        final String dbName = getDbNameByMultiName(capPropName);
        final String uncapPropName = (String)getDbNameUncapPropNameMap().get(dbName);
        if (uncapPropName == null) {
            String msg = "The dbNameUncapPropNameMap didn't contain the key of '" + capPropName + "': ";
            throw new IllegalStateException(msg + getDbNameUncapPropNameMap());
        }
        return uncapPropName;
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param multiName Multi-name. (NotNull)
     * @return Db-name. (NotNull)
     */
    public String getDbNameByMultiName(String multiName) {
        assertStringNotNullAndNotTrimmedEmpty("multiName", multiName);
        if (isExistDbName(multiName)) {
            return multiName;
        }
        if (isExistCapPropName(multiName)) {
            return getDbNameByCapPropName(multiName);
        }
        if (isExistUncapPropName(multiName)) {
            return getDbNameByUncapPropName(multiName);
        }
        String msg = "The multi-name is invalid: multiName=" + multiName;
        throw new IllegalStateException(msg);
    }

    /**
     * Get java-name by multi-name.
     * 
     * @param multiName Multi-name.
     * @return Cap-prop-name.
     */
    public String getCapPropNameByMultiName(String multiName) {
        assertStringNotNullAndNotTrimmedEmpty("multiName", multiName);
        if (isExistDbName(multiName)) {
            return getCapPropNameByDbName(multiName);
        }
        if (isExistCapPropName(multiName)) {
            return multiName;
        }
        if (isExistUncapPropName(multiName)) {
            return getCapPropNameByUncapPropName(multiName);
        }
        String msg = "The multi-name is invalid: multiName=" + multiName;
        throw new IllegalStateException(msg);
    }

    /**
     * Get property-name by multi-name.
     * 
     * @param multiName Multi-name.
     * @return Uncap-prop-name.
     */
    public String getUncapPropNameByMultiName(String multiName) {
        assertStringNotNullAndNotTrimmedEmpty("multiName", multiName);
        if (isExistDbName(multiName)) {
            return getUncapPropNameByDbName(multiName);
        }
        if (isExistCapPropName(multiName)) {
            return getUncapPropNameByCapPropName(multiName);
        }
        if (isExistUncapPropName(multiName)) {
            return multiName;
        }
        String msg = "The multi-name is invalid: multiName=" + multiName;
        throw new IllegalStateException(msg);
    }

    // ===================================================================================
    //                                                                        JDBC Support
    //                                                                        ============
    public int insertEntity(java.sql.Connection conn, ${glEntityInterfaceName} entity) {
        return insertEntity(conn, entity, "");
    }

    public int insertEntity(java.sql.Connection conn, ${glEntityInterfaceName} entity, String tablePrefix) {
        checkDowncast(entity);
        final String sql = getPreparedInsertClause(tablePrefix);
        java.sql.PreparedStatement ps = null;
        try {
            ps = conn.prepareStatement(sql);
            final java.util.List${database.filterGenericsString('Object')} valueList = convertToColumnValueList(entity);
            int settingIndex = 1;
            for (final java.util.Iterator ite = valueList.iterator(); ite.hasNext(); ) {
                Object value = ite.next();
                if (value == null) {
                    ps.setNull(settingIndex, java.sql.Types.VARCHAR);
                } else {
                    ps.setObject(settingIndex, value);
                }
                ++settingIndex;
            }
            return ps.executeUpdate();
        } catch (java.sql.SQLException e) {
            String msg = "The sql threw the exception: sql=" + sql;
            throw new IllegalStateException(msg, e);
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (java.sql.SQLException ignored) {
                }
            }
        }
    }

    // ===================================================================================
    //                                                                          Map String
    //                                                                          ==========
    public ${glMapListStringName} createMapListString() {
        return MapStringUtil.createMapListString();
    }

    public ${glMapStringBuilderName} createMapStringBuilder() {
        return MapStringUtil.createMapStringBuilder(getColumnDbNameList());
    }

    // ===================================================================================
    //                                                                          Util Class
    //                                                                          ==========
    /**
     * This class is for Internal. Don't use this!
     */
    protected static class MapStringUtil {
        public static void acceptPrimaryKeyMapString(String primaryKeyMapString, ${glEntityInterfaceName} entity) {
            if (primaryKeyMapString == null) {
                String msg = "The argument[primaryKeyMapString] should not be null.";
                throw new IllegalArgumentException(msg);
            }
            final String prefix = MAP_STRING_MAP_MARK + MAP_STRING_START_BRACE;
            final String suffix = MAP_STRING_END_BRACE;
            if (!primaryKeyMapString.trim().startsWith(prefix)) {
                primaryKeyMapString = prefix + primaryKeyMapString;
            }
            if (!primaryKeyMapString.trim().endsWith(suffix)) {
                primaryKeyMapString = primaryKeyMapString + suffix;
            }
            ${glMapListStringName} mapListString = createMapListString();
            entity.getDBMeta().acceptPrimaryKeyMap(entity, mapListString.generateMap(primaryKeyMapString));
        }

        public static void acceptColumnValueMapString(String columnValueMapString, ${glEntityInterfaceName} entity) {
            if (columnValueMapString == null) {
                String msg = "The argument[columnValueMapString] should not be null.";
                throw new IllegalArgumentException(msg);
            }
            final String prefix = MAP_STRING_MAP_MARK + MAP_STRING_START_BRACE;
            final String suffix = MAP_STRING_END_BRACE;
            if (!columnValueMapString.trim().startsWith(prefix)) {
                columnValueMapString = prefix + columnValueMapString;
            }
            if (!columnValueMapString.trim().endsWith(suffix)) {
                columnValueMapString = columnValueMapString + suffix;
            }
            ${glMapListStringName} mapListString = createMapListString();
            entity.getDBMeta().acceptColumnValueMap(entity, mapListString.generateMap(columnValueMapString));
        }

        public static String extractPrimaryKeyMapString(${glEntityInterfaceName} entity) {
            final String startBrace = MAP_STRING_START_BRACE;
            final String endBrace = MAP_STRING_END_BRACE;
            final String delimiter = MAP_STRING_DELIMITER;
            final String equal = MAP_STRING_EQUAL;
            return entity.getDBMeta().extractPrimaryKeyMapString(entity, startBrace, endBrace, delimiter, equal);
        }

        public static String extractColumnValueMapString(${glEntityInterfaceName} entity) {
            final String startBrace = MAP_STRING_START_BRACE;
            final String endBrace = MAP_STRING_END_BRACE;
            final String delimiter = MAP_STRING_DELIMITER;
            final String equal = MAP_STRING_EQUAL;
            return entity.getDBMeta().extractColumnValueMapString(entity, startBrace, endBrace, delimiter, equal);
        }

        public static void checkTypeString(Object value, String propertyName, String typeName) {
            if (value == null) {
                throw new IllegalArgumentException("The value should not be null: " + propertyName);
            }
            if (!(value instanceof String)) {
                String msg = "The value of " + propertyName + " should be " + typeName + " or String: ";
                msg = msg + "valueType=" + value.getClass() + " value=" + value;
                throw new IllegalArgumentException(msg);
            }
        }

        public static long parseDateStringAsMillis(Object value, String propertyName, String typeName) {
            checkTypeString(value, propertyName, typeName);
            try {
                final String valueString = (String)value;
                if (valueString.indexOf("-") >= 0 && valueString.indexOf("-") != valueString.lastIndexOf("-")) {
                    return java.sql.Timestamp.valueOf(valueString).getTime();
                } else {
                    return getParseDateFormat().parse((String)value).getTime();
                }
            } catch (java.text.ParseException e) {
                String msg = "The value of " + propertyName + " should be " + typeName + ". but: " + value;
                throw new RuntimeException(msg + " threw the exception: value=[" + value + "]", e);
            } catch (RuntimeException e) {
                String msg = "The value of " + propertyName + " should be " + typeName + ". but: " + value;
                throw new RuntimeException(msg + " threw the exception: value=[" + value + "]", e);
            }
        }

        public static String formatDate(java.util.Date value) {
            return getFormatDateFormat().format(value);
        }

        public static String formatTimestamp(java.sql.Timestamp value) {
            return getFormatDateFormat().format(value);
        }

        public static java.text.DateFormat getParseDateFormat() {
            return java.text.DateFormat.getDateTimeInstance();
        }

        public static java.text.DateFormat getFormatDateFormat() {
            return new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
        }

        public static ${glMapListStringName} createMapListString() {
            final ${glMapListStringName} mapListString = new ${glMapListStringImplName}();
            mapListString.setMapMark(MAP_STRING_MAP_MARK);
            mapListString.setListMark(MAP_STRING_LIST_MARK);
            mapListString.setStartBrace(MAP_STRING_START_BRACE);
            mapListString.setEndBrace(MAP_STRING_END_BRACE);
            mapListString.setEqual(MAP_STRING_EQUAL);
            mapListString.setDelimiter(MAP_STRING_DELIMITER);
            return mapListString;
        }

        public static ${glMapStringBuilderName} createMapStringBuilder(java.util.List${database.filterGenericsString('String')} columnNameList) {
            ${glMapStringBuilderName} mapStringBuilder = new ${glMapStringBuilderImplName}();
            mapStringBuilder.setMsMapMark(MAP_STRING_MAP_MARK);
            mapStringBuilder.setMsStartBrace(MAP_STRING_START_BRACE);
            mapStringBuilder.setMsEndBrace(MAP_STRING_END_BRACE);
            mapStringBuilder.setMsEqual(MAP_STRING_EQUAL);
            mapStringBuilder.setMsDelimiter(MAP_STRING_DELIMITER);
            mapStringBuilder.setColumnNameList(columnNameList);
            return mapStringBuilder;
        }
    }

    /**
     * This class is for Internal. Don't use this!
     */
    protected static class MapAssertUtil {
        public static void assertPrimaryKeyMapNotNullAndNotEmpty(java.util.Map${database.filterGenericsString('String, ? extends Object')} primaryKeyMap) {
            if (primaryKeyMap == null) {
                String msg = "The argument[primaryKeyMap] should not be null.";
                throw new IllegalArgumentException(msg);
            }
            if (primaryKeyMap.isEmpty()) {
                String msg = "The argument[primaryKeyMap] should not be empty.";
                throw new IllegalArgumentException(msg);
            }
        }
        public static void assertColumnExistingInPrimaryKeyMap(java.util.Map${database.filterGenericsString('String, ? extends Object')} primaryKeyMap, String columnName) {
            if (!primaryKeyMap.containsKey(columnName)) {
                String msg = "The primaryKeyMap must have the value of " + columnName;
                throw new IllegalStateException(msg + ": primaryKeyMap --> " + primaryKeyMap);
            }
        }
        public static void assertColumnValueMapNotNullAndNotEmpty(java.util.Map${database.filterGenericsString('String, ? extends Object')} columnValueMap) {
            if (columnValueMap == null) {
                String msg = "The argument[columnValueMap] should not be null.";
                throw new IllegalArgumentException(msg);
            }
            if (columnValueMap.isEmpty()) {
                String msg = "The argument[columnValueMap] should not be empty.";
                throw new IllegalArgumentException(msg);
            }
        }
    }

#if ($database.isAvailableGenerics())

    /**
     * This class is for Internal. Don't use this!
     */
    protected static class MapStringValueAnalyzer {
        protected java.util.Map<String, ? extends Object> _valueMap;
        protected java.util.Set<String> _modifiedPropertyNames;
        protected String _columnName;
        protected String _uncapPropName;
        protected String _propertyName;

        public MapStringValueAnalyzer(java.util.Map<String, ? extends Object> valueMap, java.util.Set<String> modifiedPropertyNames) {
            this._valueMap = valueMap;
            this._modifiedPropertyNames = modifiedPropertyNames;
        }

        public boolean init(String columnName, String uncapPropName, String propertyName) {
            this._columnName = columnName;
            this._uncapPropName = uncapPropName;
            this._propertyName = propertyName;
            return _valueMap.containsKey(_columnName);
        }

        public <COLUMN_TYPE> COLUMN_TYPE analyzeString(Class<COLUMN_TYPE> javaType) {
            final Object obj = _valueMap.get(_columnName);
            if (obj == null) {
                _modifiedPropertyNames.remove(_propertyName);
                return null;
            }
            helpCheckingTypeString(obj, _uncapPropName, javaType.getName());
            return (COLUMN_TYPE)obj;
        }

        public <COLUMN_TYPE> COLUMN_TYPE analyzeNumber(Class<COLUMN_TYPE> javaType) {
            final Object obj = _valueMap.get(_columnName);
            if (obj == null) {
                _modifiedPropertyNames.remove(_propertyName);
                return null;
            }
            if (javaType.isAssignableFrom(obj.getClass())) {
                return (COLUMN_TYPE)obj;
            }
            return (COLUMN_TYPE)newInstanceByConstructor(javaType, String.class, obj.toString());
        }

        public <COLUMN_TYPE> COLUMN_TYPE analyzeDate(Class<COLUMN_TYPE> javaType) {
            final Object obj = _valueMap.get(_columnName);
            if (obj == null) {
                _modifiedPropertyNames.remove(_propertyName);
                return null;
            }
            if (javaType.isAssignableFrom(obj.getClass())) {
                return (COLUMN_TYPE)obj;
            }
            return (COLUMN_TYPE)newInstanceByConstructor(javaType, long.class, helpParsingDateString(obj, _uncapPropName, javaType.getName()));
        }

        public <COLUMN_TYPE> COLUMN_TYPE analyzeOther(Class<COLUMN_TYPE> javaType) {
            final Object obj = _valueMap.get(_columnName);
            if (obj == null) {
                _modifiedPropertyNames.remove(_propertyName);
                return null;
            }
            return (COLUMN_TYPE)obj;
        }

	    private void helpCheckingTypeString(Object value, String uncapPropName, String typeName) {
	        MapStringUtil.checkTypeString(value, uncapPropName, typeName);
	    }

	    private long helpParsingDateString(Object value, String uncapPropName, String typeName) {
	        return MapStringUtil.parseDateStringAsMillis(value, uncapPropName, typeName);
	    }

        protected Object newInstanceByConstructor(Class targetType, Class argType, Object arg) {
            java.lang.reflect.Constructor constructor;
            try {
                constructor = targetType.getConstructor(new Class[]{argType});
            } catch (SecurityException e) {
                String msg = "targetType=" + targetType + " argType=" + argType + " arg=" + arg;
                throw new RuntimeException(msg, e);
            } catch (NoSuchMethodException e) {
                String msg = "targetType=" + targetType + " argType=" + argType + " arg=" + arg;
                throw new RuntimeException(msg, e);
            }
            try {
                return constructor.newInstance(new Object[]{arg});
            } catch (IllegalArgumentException e) {
                String msg = "targetType=" + targetType + " argType=" + argType + " arg=" + arg;
                throw new RuntimeException(msg, e);
            } catch (InstantiationException e) {
                String msg = "targetType=" + targetType + " argType=" + argType + " arg=" + arg;
                throw new RuntimeException(msg, e);
            } catch (IllegalAccessException e) {
                String msg = "targetType=" + targetType + " argType=" + argType + " arg=" + arg;
                throw new RuntimeException(msg, e);
            } catch (java.lang.reflect.InvocationTargetException e) {
                String msg = "targetType=" + targetType + " argType=" + argType + " arg=" + arg;
                throw new RuntimeException(msg, e);
            }
        }
    }

#end

    // =====================================================================================
    //                                                                                Helper
    //                                                                                ======
    abstract protected void checkDowncast(${glEntityInterfaceName} entity);

    protected String helpGettingColumnStringValue(Object value) {
        if (value instanceof java.sql.Timestamp) {
            return (value != null ? helpFormatingTimestamp((java.sql.Timestamp)value) : "");
        } else if (value instanceof java.util.Date) {
            return (value != null ? helpFormatingDate((java.util.Date)value) : "");
        } else {
            return (value != null ? value.toString() : "");
        }
    }

    protected String helpFormatingDate(java.util.Date date) {
        return MapStringUtil.formatDate(date);
    }

    protected String helpFormatingTimestamp(java.sql.Timestamp timestamp) {
        return MapStringUtil.formatTimestamp(timestamp);
    }

    // ----------------------------------------------------------------
    //                                                    Assert Object
    //                                                    -------------
    /**
     * Assert that the argument is not null.
     * 
     * @param variableName Variable name. (NotNull)
     * @param arg Argument. (NotNull)
     */
    protected void assertObjectNotNull(String variableName, Object arg) {
        if (variableName == null) {
            String msg = "Argument[variableName] should not be null.";
            throw new IllegalArgumentException(msg);
        }
        if (arg == null) {
            String msg = "Argument[" + variableName + "] should not be null.";
            throw new IllegalArgumentException(msg);
        }
    }

    // ----------------------------------------------------------------
    //                                                    Assert String
    //                                                    -------------
    /**
     * Assert that the string is not null and not trimmed empty.
     * 
     * @param variableName Variable name. (NotNull)
     * @param value Value. (NotNull)
     */
    protected void assertStringNotNullAndNotTrimmedEmpty(String variableName, String value) {
        if (variableName == null) {
            String msg = "Variable[variableName] should not be null.";
            throw new IllegalArgumentException(msg);
        }
        if (value == null) {
            String msg = "Variable[" + variableName + "] should not be null.";
            throw new IllegalArgumentException(msg);
        }
        if (value.trim().length() == 0) {
            String msg = "Variable[" + variableName + "] should not be empty: [" + value + "]";
            throw new IllegalArgumentException(msg);
        }
    }
}
