${database.allClassCopyright}package ${glPackageBaseCommonSqlClause};

#set ($myClassName = "${glSqlClauseAbstractName}")

import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Set;
import java.util.Iterator;
import java.util.StringTokenizer;

import ${glPackageBaseCommonCKey}.*;
import ${glPackageBaseCommonCOption}.${glConditionOptionInterfaceName};
import ${glPackageBaseCommonCValue}.${glConditionValueName};
import ${glPackageBaseCommonDBMeta}.${glDBMetaInterfaceName};
import ${glPackageBaseCommonDBMeta}.${glDBMetaInstanceHandlerName};
import ${glPackageBaseCommonDBMetaInfo}.${glColumnInfoName};
import ${glPackageBaseCommonDBMetaInfo}.${glForeignInfoName};
import ${glPackageBaseCommonDBMetaInfo}.${glUniqueInfoName};
import ${glPackageBaseCommonUtil}.${glSimpleAssertUtil};
import ${glPackageBaseCommonUtil}.${glSimpleStringUtil};
import ${glPackageBaseCommonUtil}.${glSimpleSystemUtil};

/**
 * The abstract class of SqlClause.
 * 
 * @author ${database.ClassAuthor}
 */${database.outputSuppressWarningsAfterLineSeparator()}
public abstract class ${myClassName} implements ${glSqlClauseInterfaceName} {

    // ===================================================================================
    //                                                                           Attribute
    //                                                                           =========
    // -----------------------------------------------------
    //                                                 Basic
    //                                                 -----
    /** Target table name. */
    protected final String _tableName;

    // -----------------------------------------------------
    //                                       Clause Resource
    //                                       ---------------
	/** Selected select column map. map:{tableAliasName : map:{columnName : selectColumnInfo}}*/
    protected Map<String, Map<String, SelectedSelectColumnInfo>> _selectedSelectColumnMap = new LinkedHashMap<String, Map<String, SelectedSelectColumnInfo>>();
    
    /** Included select column map. */
    protected Map<String, String> _includedSelectColumnMap = new LinkedHashMap<String, String>();

	/** The map of real column and alias of select clause. map:{realColumnName : aliasName} */
	protected Map<String, String> _selectClauseRealColumnAliasMap = new HashMap<String, String>();// Without linked!
	
    /** Outer join map. */
    protected Map<String, LeftOuterJoinInfo> _outerJoinMap = new LinkedHashMap<String, LeftOuterJoinInfo>();

    /** Where list. */
    protected List<String> _whereList = new ArrayList<String>();

    /** Inline where list for BaseTable. */
    protected List<String> _baseTableInlineWhereList = new ArrayList<String>();

    /** Order-by clause. */
    protected final ${glOrderByClauseName} _orderByClause = new ${glOrderByClauseName}();

    /** Union clause list. */
    protected List<UnionQueryInfo> _unionQueryInfoList = new ArrayList<UnionQueryInfo>();

    /** Is included-select-column effective? Default value is false. */
    protected boolean _isIncludedSelectColumnEffective = false;

    /** Is order-by effective? Default value is false. */
    protected boolean _isOrderByEffective = false;

    // -----------------------------------------------------
    //                                        Fetch Property
    //                                        --------------
    /** Fetch start index. (for fetchXxx()) */
    protected int _fetchStartIndex = 0;

    /** Fetch size. (for fetchXxx()) */
    protected int _fetchSize = 0;

    /** Fetch page number. (for fetchXxx()) This value should be plus. */
    protected int _fetchPageNumber = 1;

    /** Is fetch-narrowing effective? Default value is false. */
    protected boolean _isFetchScopeEffective = false;

    // -----------------------------------------------------
    //                               AdditionalConditionAsOr
    //                               -----------------------
    /** Is additional condition as or effective?*/
    protected boolean _isAdditionalConditionAsOrEffective = false;

    // -----------------------------------------------------
    //                               WhereClauseSimpleFilter
    //                               -----------------------
    /** The filter for where clause. */
    protected List<${glWhereClauseSimpleFilterInterfaceName}> _whereClauseSimpleFilterList;

    // -----------------------------------------------------
    //                                 Selected Foreign Info
    //                                 ---------------------
    /** The information of selected foreign table. */
    protected Map<String, String> _selectedForeignInfo;
	
    // ===================================================================================
    //                                                                         Constructor
    //                                                                         ===========
    public ${myClassName}(String tableName) {
        if (tableName == null) {
            String msg = "Argument[tableName] must not be null.";
            throw new IllegalArgumentException(msg);
        }
        _tableName = tableName;
    }

    // ===================================================================================
    //                                                                              Clause
    //                                                                              ======
    public String getClause() {
        final StringBuilder sb = new StringBuilder(512);
		sb.append(getSelectClause());
        sb.append(" ");
        sb.append(buildClauseWithoutMainSelect(false));
        return sb.toString();
    }
	
	public String getClausePKOnly() {
        final StringBuilder sb = new StringBuilder(512);
		sb.append(getSelectClausePKOnly());
        sb.append(" ");
        sb.append(buildClauseWithoutMainSelect(true));
        return sb.toString();
	}
	
	protected String buildClauseWithoutMainSelect(boolean pkonly) {
	    final StringBuilder sb = new StringBuilder(512);
        sb.append(getFromClause());
        sb.append(getFromHint());
        sb.append(" ");
        sb.append(getWhereClause());
		String unionClause = buildUnionClause(pkonly ? getSelectClausePKOnly() : getSelectClause());
		
		// Delete template mark! (At the future this will be unnecessary.)
		unionClause = replaceString(unionClause, getUnionWhereClauseMark(), "");// Required!
		unionClause = replaceString(unionClause, getUnionWhereFirstConditionMark(), "");// Required!
		
        sb.append(unionClause);
        if (_isOrderByEffective && !_orderByClause.isEmpty()) {
            sb.append(" ");
            sb.append(getOrderByClause());
        }
        sb.append(" ");
        sb.append(getSqlSuffix());
        return sb.toString();
	}
	
    public String getClauseFromWhereWithUnionTemplate() {
	    return buildClauseFromWhereAsTemplate(false);
    }
	
    public String getClauseFromWhereWithWhereUnionTemplate() {
	    return buildClauseFromWhereAsTemplate(true);
	}
	
    protected String buildClauseFromWhereAsTemplate(boolean template) {
        final StringBuilder sb = new StringBuilder(512);
        sb.append(getFromClause());
        sb.append(getFromHint());
        sb.append(" ");
        sb.append(buildWhereClause(template));
        sb.append(buildUnionClause(getUnionSelectClauseMark()));
        return sb.toString();
	}
	
    protected String buildUnionClause(String selectClause) {
        final StringBuilder sb = new StringBuilder();
        for (final Iterator<UnionQueryInfo> ite = _unionQueryInfoList.iterator(); ite.hasNext(); ) {
            final UnionQueryInfo unionQueryInfo = (UnionQueryInfo)ite.next();
            final String unionQueryClause = unionQueryInfo.getUnionQueryClause();
            final boolean unionAll = unionQueryInfo.isUnionAll();
            sb.append(unionAll ? " union all " : " union ").append(selectClause).append(" ").append(unionQueryClause);
        }
        return sb.toString();
    }

    // ===================================================================================
    //                                                                        Clause Parts
    //                                                                        ============
	public String getSelectClause() {
	    final StringBuilder sb = new StringBuilder();
		final ${glDBMetaInterfaceName} dbmeta = ${glDBMetaInstanceHandlerName}.findDBMeta(_tableName);
		final List<${glColumnInfoName}> columnInfoList = dbmeta.getColumnInfoList();
		for (${glColumnInfoName} columnInfo : columnInfoList) {
		    final String columnName = columnInfo.getColumnDbName();
			if (sb.length() > 0) {
			    sb.append(", ");
			} else {
			    sb.append("select/*$dto.selectHint*/ ");
			}
			final String realColumnName = getLocalTableAliasName() + "." + columnName;
			sb.append(realColumnName).append(" as ").append(columnName);
			_selectClauseRealColumnAliasMap.put(realColumnName, columnName);
		}
	    final Set<String> tableAliasNameSet = _selectedSelectColumnMap.keySet();
		for (String tableAliasName : tableAliasNameSet) {
		    final Map<String, SelectedSelectColumnInfo> map = _selectedSelectColumnMap.get(tableAliasName);
			final Collection<SelectedSelectColumnInfo> selectColumnInfoList = map.values();
			for (SelectedSelectColumnInfo selectColumnInfo : selectColumnInfoList) {
			    final String realColumnName = selectColumnInfo.buildRealColumnName();
                sb.append(", ").append(realColumnName).append(" as ").append(selectColumnInfo.getColumnAliasName());
				_selectClauseRealColumnAliasMap.put(realColumnName, selectColumnInfo.getColumnAliasName());
			}
		}
		if (_isIncludedSelectColumnEffective && !_includedSelectColumnMap.isEmpty()) {
		    sb.append(getIncludedSelectColumnClause());
		}
		return sb.toString();
	}
	
	public String getSelectClausePKOnly() {
	    final StringBuffer sb = new StringBuffer();
		final ${glDBMetaInterfaceName} dbmeta = ${glDBMetaInstanceHandlerName}.findDBMeta(_tableName);
		final ${glUniqueInfoName} uniqueInfo = dbmeta.getPrimaryUniqueInfo();
		final List<${glColumnInfoName}> columnInfoList = uniqueInfo.getUniqueColumnList();
		for (${glColumnInfoName} columnInfo : columnInfoList) {
		    final String columnName = columnInfo.getColumnDbName();
			if (sb.length() > 0) {
			    sb.append(", ");
			} else {
			    sb.append("select/*$dto.selectHint*/ ");
			}
			final String realColumnName = getLocalTableAliasName() + "." + columnName;
			sb.append(realColumnName).append(" as ").append(columnName);
			_selectClauseRealColumnAliasMap.put(realColumnName, columnName);
		}
		if (_isIncludedSelectColumnEffective && !_includedSelectColumnMap.isEmpty()) {
		    sb.append(getIncludedSelectColumnClause());
		}
		return sb.toString();
	}
	
    public String getSelectHint() {
        return createSelectHint();
    }

    public String getIncludedSelectColumnClause() {
        final StringBuffer sb = new StringBuffer();
        int count = 0;
        for (final Iterator<String> ite = _includedSelectColumnMap.keySet().iterator(); ite.hasNext(); count++) {
            final String aliasName = ite.next();
            final String realColumnName = (String)_includedSelectColumnMap.get(aliasName);
            sb.append(", ").append(realColumnName).append(" as ").append(aliasName);
			_selectClauseRealColumnAliasMap.put(realColumnName, aliasName);
        }
        return sb.toString();
    }

    public String getFromClause() {
        final StringBuffer sb = new StringBuffer();
        sb.append("from ");
        if (_baseTableInlineWhereList.isEmpty()) {
            sb.append(_tableName).append(" dflocal");
        } else {
            sb.append(getInlineViewClause(_tableName, _baseTableInlineWhereList)).append(" dflocal");
        }
        sb.append(getFromBaseTableHint());
        sb.append(getLeftOuterJoinClause());
        return sb.toString();
    }

    protected String getLeftOuterJoinClause() {
        final StringBuffer sb = new StringBuffer();
        for (final Iterator<String> ite = _outerJoinMap.keySet().iterator(); ite.hasNext(); ) {
            final String aliasName = ite.next();
            final LeftOuterJoinInfo joinInfo = (LeftOuterJoinInfo)_outerJoinMap.get(aliasName);
            final String joinTableName = joinInfo.getJoinTableName();
            final List<String> inlineWhereClauseList = joinInfo.getInlineWhereClauseList();
            final List<String> additionalOnClauseList = joinInfo.getAdditionalOnClauseList();
            final Map<String, String> joinOnMap = joinInfo.getJoinOnMap();
            assertJoinOnMapNotEmpty(joinOnMap, aliasName);

            sb.append(" left outer join ");
            if (inlineWhereClauseList.isEmpty()) {
                sb.append(joinTableName);
            } else {
                sb.append(getInlineViewClause(joinTableName, inlineWhereClauseList));
            }
            sb.append(" ").append(aliasName).append(" on ");
            int count = 0;
            final Set<String> localColumnNameSet = joinOnMap.keySet();
            for (String localColumnName : localColumnNameSet) {
                final String foreignColumnName = (String)joinOnMap.get(localColumnName);
                if (count > 0) {
                    sb.append(" and ");
                }
                if (localColumnName.equals("$$fixedCondition$$")) {
                    sb.append(foreignColumnName);
                } else {
                    sb.append(localColumnName).append(" = ").append(foreignColumnName);
                }
                ++count;
            }
			for (String additionalOnClause : additionalOnClauseList) {
			    sb.append(" and ").append(additionalOnClause);
			}
        }
        return sb.toString();
    }

    protected String getInlineViewClause(String joinTableName, List<String> inlineWhereClauseList) {
        final StringBuffer sb = new StringBuffer();
        sb.append("(select * from ").append(joinTableName).append(" where ");
        int count = 0;
        for (final Iterator<String> ite = inlineWhereClauseList.iterator(); ite.hasNext(); ) {
            String clauseElement = ite.next();
            clauseElement = filterWhereClauseSimply(clauseElement);
            if (count > 0) {
                sb.append(" and ");
            }
            sb.append(clauseElement);
            ++count;
        }
        sb.append(")");
        return sb.toString();
    }

    public String getFromBaseTableHint() {
        return createFromBaseTableHint();
    }

    public String getFromHint() {
        return createFromHint();
    }

    public String getWhereClause() {
	    return buildWhereClause(false);
    }
	
	protected String buildWhereClause(boolean template) {
        final StringBuffer sb = new StringBuffer();
        int count = 0;
        for (final Iterator<String> ite = _whereList.iterator(); ite.hasNext(); count++) {
            String clauseElement = (String)ite.next();
            clauseElement = filterWhereClauseSimply(clauseElement);
            if (count == 0) {
                sb.append("where ").append(template  ? getWhereFirstConditionMark() : "").append(clauseElement);
            } else {
                sb.append(" and ").append(clauseElement);
            }
        }
		if (template && sb.length() == 0) {
		    sb.append(getWhereClauseMark());
		}
        return sb.toString();
    }
	
    public String getOrderByClause() {
        if (!_unionQueryInfoList.isEmpty()) {
            if (_selectClauseRealColumnAliasMap == null || _selectClauseRealColumnAliasMap.isEmpty()) {
                String msg = "The selectClauseColumnAliasMap should not be null or empty when union query exists: " + toString();
                throw new IllegalStateException(msg);
            }
            return _orderByClause.getOrderByClause(_selectClauseRealColumnAliasMap);
        } else {
            return _orderByClause.getOrderByClause();
        }
    }

    public String getSqlSuffix() {
        return createSqlSuffix();
    }

    // ===================================================================================
    //                                                                          Copy Parts
    //                                                                          ==========
    public void copyIncludedSelectColumn(${glSqlClauseInterfaceName} sqlClause) {
        final Set<String> keySet = _includedSelectColumnMap.keySet();
        for (final Iterator<String> ite = keySet.iterator(); ite.hasNext(); ) {
            final String aliasName = ite.next();
            final String realColumnName = (String)_includedSelectColumnMap.get(aliasName);
            sqlClause.registerIncludedSelectColumn(aliasName, realColumnName);
        }
    }

	// ===================================================================================
    //                                                                SelectedSelectColumn
    //                                                                ====================
    /**
     * Register selected select column.
     * 
     * @param foreignTableAliasName The alias name of foreign table. (NotNull)
	 * @param localTableName The table name of local. (NotNull)
	 * @param foreignPropertyName The property name of foreign table. (NotNull)
     * @param localRelationPath The path of local relation. (Nullable)
     */
    public void registerSelectedSelectColumn(String foreignTableAliasName
			                               , String localTableName
										   , String foreignPropertyName
										   , String localRelationPath) {
        _selectedSelectColumnMap.put(foreignTableAliasName, createSelectedSelectColumnInfo(foreignTableAliasName, localTableName, foreignPropertyName, localRelationPath));
    }
    
	protected Map<String, SelectedSelectColumnInfo> createSelectedSelectColumnInfo(String foreignTableAliasName
											                                     , String localTableName
													                             , String foreignPropertyName
													                             , String localRelationPath) {
		final ${glDBMetaInterfaceName} dbmeta = ${glDBMetaInstanceHandlerName}.findDBMeta(localTableName);
        final ${glForeignInfoName} foreignInfo = dbmeta.findForeignInfo(foreignPropertyName);
		final int relationNo = foreignInfo.getRelationNo();
		String nextRelationPath = "_" + relationNo;
        if (localRelationPath != null) {
            nextRelationPath = localRelationPath + nextRelationPath;
        }
		final Map<String, SelectedSelectColumnInfo> resultMap = new LinkedHashMap<String, SelectedSelectColumnInfo>();
		final ${glDBMetaInterfaceName} foreignDBMeta = foreignInfo.getForeignDBMeta();
        final List<${glColumnInfoName}> columnInfoList = foreignDBMeta.getColumnInfoList();
        for (${glColumnInfoName} columnInfo : columnInfoList) {
            final String columnDbName = columnInfo.getColumnDbName();
			final SelectedSelectColumnInfo selectColumnInfo = new SelectedSelectColumnInfo();
			selectColumnInfo.setTableAliasName(foreignTableAliasName);
			selectColumnInfo.setColumnName(columnDbName);
			selectColumnInfo.setColumnAliasName(columnDbName + nextRelationPath);
			resultMap.put(columnDbName, selectColumnInfo);
        }
		return resultMap;
	}

    public static class SelectedSelectColumnInfo {
        protected String tableAliasName;
        protected String columnName;
        protected String columnAliasName;
        public String buildRealColumnName() {
            if (tableAliasName != null) {
                return tableAliasName + "." + columnName;
            } else {
                return columnName;
            }
        }
        public String getTableAliasName() {
            return tableAliasName;
        }
        public void setTableAliasName(String tableAliasName) {
            this.tableAliasName = tableAliasName;
        }
        public String getColumnName() {
            return columnName;
        }
        public void setColumnName(String columnName) {
            this.columnName = columnName;
        }
        public String getColumnAliasName() {
            return columnAliasName;
        }
        public void setColumnAliasName(String columnAliasName) {
            this.columnAliasName = columnAliasName;
        }
    }
	
    // ===================================================================================
    //                                                                IncludedSelectColumn
    //                                                                ====================
    public void ignoreIncludedSelectColumn() {
        _isIncludedSelectColumnEffective = false;
    }

    public void makeIncludedSelectColumnEffective() {
        if (!_includedSelectColumnMap.isEmpty()) {
            _isIncludedSelectColumnEffective = true;
        }
    }

    public void registerIncludedSelectColumn(String aliasName, String realColumnName) {
        _isIncludedSelectColumnEffective = true;
        _includedSelectColumnMap.put(aliasName, realColumnName);
    }

    // ===================================================================================
    //                                                                           OuterJoin
    //                                                                           =========
    public void registerOuterJoin(String joinTableName, String aliasName, Map<String, String> joinOnMap) {
        assertAlreadyOuterJoin(aliasName);
        assertJoinOnMapNotEmpty(joinOnMap, aliasName);
        final LeftOuterJoinInfo joinInfo = new LeftOuterJoinInfo();
        joinInfo.setAliasName(aliasName);
        joinInfo.setJoinTableName(joinTableName);
        joinInfo.setJoinOnMap(joinOnMap);
        _outerJoinMap.put(aliasName, joinInfo);
    }

    protected static class LeftOuterJoinInfo {
        protected String _aliasName;
        protected String _joinTableName;
        protected List<String> _inlineWhereClauseList = new ArrayList<String>();
        protected List<String> _additionalOnClauseList = new ArrayList<String>();
        protected Map<String, String> _joinOnMap;
		protected boolean _onClauseInline;
        public String getAliasName() {
            return _aliasName;
        }
        public void setAliasName(String value) {
            _aliasName = value;
        }
        public String getJoinTableName() {
            return _joinTableName;
        }
        public void setJoinTableName(String value) {
            _joinTableName = value;
        }
        public List<String> getInlineWhereClauseList() {
            return _inlineWhereClauseList;
        }
        public void addInlineWhereClause(String value) {
            _inlineWhereClauseList.add(value);
        }
        public List<String> getAdditionalOnClauseList() {
            return _additionalOnClauseList;
        }
        public void addAdditionalOnClause(String value) {
            _additionalOnClauseList.add(value);
        }
        public Map<String, String> getJoinOnMap() {
            return _joinOnMap;
        }
        public void setJoinOnMap(Map<String, String> value) {
            _joinOnMap = value;
        }
        public boolean isOnClauseInline() {
            return _onClauseInline;
        }
        public void setOnClauseInline(boolean value) {
            _onClauseInline = value;
        }
    }

    protected void assertAlreadyOuterJoin(String aliasName) {
        if (_outerJoinMap.containsKey(aliasName)) {
            String msg = "The alias name have already registered in outer join: " + aliasName;
            throw new IllegalStateException(msg);
        }
    }

    protected void assertJoinOnMapNotEmpty(Map<String, String> joinOnMap, String aliasName) {
        if (joinOnMap.isEmpty()) {
            String msg = "The joinOnMap should not be empty: aliasName=" + aliasName;
            throw new IllegalStateException(msg);
        }
    }

    // ===================================================================================
    //                                                                               Where
    //                                                                               =====
    public void registerWhereClause(String columnFullName, ${glConditionKeyName} key, ${glConditionValueName} value) {
        assertStringNotNullAndNotTrimmedEmpty("columnFullName", columnFullName);
        key.addWhereClause(_whereList, columnFullName, value);
        arrangeWhereListAdditionalConditionAsOr(_whereList);
    }

    public void registerWhereClause(String columnFullName, ${glConditionKeyName} key, ${glConditionValueName} value, ${glConditionOptionInterfaceName} option) {
        assertStringNotNullAndNotTrimmedEmpty("columnFullName", columnFullName);
        assertObjectNotNull("option of " + columnFullName, option);
        key.addWhereClause(_whereList, columnFullName, value, option);
        arrangeWhereListAdditionalConditionAsOr(_whereList);
    }

    public void registerWhereClause(String clause) {
        assertStringNotNullAndNotTrimmedEmpty("clause", clause);
        _whereList.add(clause);
        arrangeWhereListAdditionalConditionAsOr(_whereList);
    }

    public void exchangeFirstWhereClauseForLastOne() {
        if (_whereList.size() > 1) {
            final String first = (String)_whereList.get(0);
            final String last = (String)_whereList.get(_whereList.size() - 1);
            _whereList.set(0, last);
            _whereList.set(_whereList.size() - 1, first);
        }
    }

    // ===================================================================================
    //                                                                         InlineWhere
    //                                                                         ===========
    public void registerBaseTableInlineWhereClause(String columnName, ${glConditionKeyName} key, ${glConditionValueName} value) {
        assertStringNotNullAndNotTrimmedEmpty("columnName", columnName);
        key.addWhereClause(_baseTableInlineWhereList, columnName, value);
        arrangeWhereListAdditionalConditionAsOr(_baseTableInlineWhereList);
    }

    public void registerBaseTableInlineWhereClause(String columnName, ${glConditionKeyName} key, ${glConditionValueName} value, ${glConditionOptionInterfaceName} option) {
        assertStringNotNullAndNotTrimmedEmpty("columnName", columnName);
        assertObjectNotNull("option of " + columnName, option);
        key.addWhereClause(_baseTableInlineWhereList, columnName, value, option);
        arrangeWhereListAdditionalConditionAsOr(_baseTableInlineWhereList);
    }

    public void registerBaseTableInlineWhereClause(String value) {
        _baseTableInlineWhereList.add(value);
    }

    public void registerOuterJoinInlineWhereClause(String aliasName, String columnName, ${glConditionKeyName} key, ${glConditionValueName} value, boolean onClauseInline) {
        assertNotYetOuterJoin(aliasName);
        assertStringNotNullAndNotTrimmedEmpty("columnName", columnName);
        final LeftOuterJoinInfo joinInfo = (LeftOuterJoinInfo)_outerJoinMap.get(aliasName);
		if (onClauseInline) {
            key.addWhereClause(joinInfo.getAdditionalOnClauseList(), aliasName + "." + columnName, value);
		} else {
            key.addWhereClause(joinInfo.getInlineWhereClauseList(), columnName, value);
		}
        arrangeWhereListAdditionalConditionAsOr(joinInfo.getInlineWhereClauseList());
    }

    public void registerOuterJoinInlineWhereClause(String aliasName, String columnName, ${glConditionKeyName} key, ${glConditionValueName} value, ${glConditionOptionInterfaceName} option, boolean onClauseInline) {
        assertNotYetOuterJoin(aliasName);
        assertStringNotNullAndNotTrimmedEmpty("columnName", columnName);
        final LeftOuterJoinInfo joinInfo = (LeftOuterJoinInfo)_outerJoinMap.get(aliasName);
		if (onClauseInline) {
            key.addWhereClause(joinInfo.getAdditionalOnClauseList(), aliasName + "." + columnName, value, option);
            arrangeWhereListAdditionalConditionAsOr(joinInfo.getAdditionalOnClauseList());
		} else {
            key.addWhereClause(joinInfo.getInlineWhereClauseList(), columnName, value, option);
            arrangeWhereListAdditionalConditionAsOr(joinInfo.getInlineWhereClauseList());
		}
    }

    public void registerOuterJoinInlineWhereClause(String aliasName, String value, boolean onClauseInline) {
        assertNotYetOuterJoin(aliasName);
        final LeftOuterJoinInfo joinInfo = (LeftOuterJoinInfo)_outerJoinMap.get(aliasName);
		if (onClauseInline) {
            joinInfo.addAdditionalOnClause(value);
            arrangeWhereListAdditionalConditionAsOr(joinInfo.getAdditionalOnClauseList());
		} else {
		    joinInfo.addInlineWhereClause(value);
            arrangeWhereListAdditionalConditionAsOr(joinInfo.getInlineWhereClauseList());
		}
    }

    protected void assertNotYetOuterJoin(String aliasName) {
        if (!_outerJoinMap.containsKey(aliasName)) {
            String msg = "The alias name have not registered in outer join yet: " + aliasName;
            throw new IllegalStateException(msg);
        }
    }

    // ===================================================================================
    //                                                             AdditionalConditionAsOr
    //                                                             =======================
    public void makeAdditionalConditionAsOrEffective() {
        _isAdditionalConditionAsOrEffective = true;
    }

    public void ignoreAdditionalConditionAsOr() {
        _isAdditionalConditionAsOrEffective = false;
    }

    protected void arrangeWhereListAdditionalConditionAsOr(List<String> whereList) {
        if (_isAdditionalConditionAsOrEffective) {
            if (whereList.size() < 2) {
                String msg = "The whereList should have two more elements when the isAdditionalConditionAsOrEffective is true: " + toString();
                throw new IllegalStateException(msg);
            }
            final String lastWhereClause = (String)whereList.remove(whereList.size() - 1);
            final String preWhereClause = (String)whereList.remove(whereList.size() - 1);
            if (preWhereClause.startsWith("(") && preWhereClause.endsWith(")")) {
                final String plainClause = preWhereClause.substring("(".length(), preWhereClause.length() - ")".length());
                whereList.add("(" + plainClause + " or " + lastWhereClause + ")");
            } else {
                whereList.add("(" + preWhereClause + " or " + lastWhereClause + ")");
            }
        }
    }

    // ===================================================================================
    //                                                                             OrderBy
    //                                                                             =======
    public ${glOrderByClauseName} getSqlComponentOfOrderByClause() {
        return _orderByClause;
    }

    public ${glSqlClauseInterfaceName} clearOrderBy() {
        _isOrderByEffective = false;
        _orderByClause.clear();
        return this;
    }

    public ${glSqlClauseInterfaceName} ignoreOrderBy() {
        _isOrderByEffective = false;
        return this;
    }

    public ${glSqlClauseInterfaceName} makeOrderByEffective() {
        if (!_orderByClause.isEmpty()) {
            _isOrderByEffective = true;
        }
        return this;
    }

    public void reverseOrderBy_Or_OverrideOrderBy(String orderByProperty, String registeredOrderByProperty, boolean ascOrDesc) {
        _isOrderByEffective = true;
        if (!_orderByClause.isSameOrderByColumn(orderByProperty)) {
            clearOrderBy();
            registerOrderBy(orderByProperty, registeredOrderByProperty, ascOrDesc);
        } else {
            _orderByClause.reverseAll();
        }
    }

    public void registerOrderBy(String orderByProperty, String registeredOrderByProperty, boolean ascOrDesc) {
        try {
            _isOrderByEffective = true;
            final List<String> orderByList = new ArrayList<String>();
            {
                final StringTokenizer st = new StringTokenizer(orderByProperty, "/");
                while (st.hasMoreElements()) {
                    orderByList.add(st.nextToken());
                }
            }

            if (registeredOrderByProperty == null || registeredOrderByProperty.trim().length() ==0) {
                registeredOrderByProperty = orderByProperty;
            }

            final List<String> registeredOrderByList = new ArrayList<String>();
            {
                final StringTokenizer st = new StringTokenizer(registeredOrderByProperty, "/");
                while (st.hasMoreElements()) {
                    registeredOrderByList.add(st.nextToken());
                }
            }

            int count = 0;
            for (final Iterator<String> ite = orderByList.iterator(); ite.hasNext(); ) {
                String orderBy = ite.next();
                String registeredOrderBy = (String)registeredOrderByList.get(count);

                _isOrderByEffective = true;
                String aliasName = null;
                String columnName = null;
                String registeredAliasName = null;
                String registeredColumnName = null;

                if (orderBy.indexOf(".") < 0) {
                    columnName = orderBy;
                } else {
                    aliasName = orderBy.substring(0, orderBy.lastIndexOf("."));
                    columnName = orderBy.substring(orderBy.lastIndexOf(".") + 1);
                }

                if (registeredOrderBy.indexOf(".") < 0) {
                    registeredColumnName = registeredOrderBy;
                } else {
                    registeredAliasName = registeredOrderBy.substring(0, registeredOrderBy.lastIndexOf("."));
                    registeredColumnName = registeredOrderBy.substring(registeredOrderBy.lastIndexOf(".") + 1);
                }

                ${glOrderByElementName} element = new ${glOrderByElementName}();
                element.setAliasName(aliasName);
                element.setColumnName(columnName);
                element.setRegisteredAliasName(registeredAliasName);
                element.setRegisteredColumnName(registeredColumnName);
                if (ascOrDesc) {
                    element.setupAsc();
                } else {
                    element.setupDesc();
                }
                _orderByClause.addOrderByElement(element);

                count++;
            }
        } catch (RuntimeException e) {
            String msg = "registerOrderBy() threw the exception: orderByProperty=" + orderByProperty;
            msg = msg + " registeredColumnFullName=" + registeredOrderByProperty;
            msg = msg + " ascOrDesc=" + ascOrDesc;
            msg = msg + " sqlClause=" + this.toString();
            throw new RuntimeException(msg, e);
        }
    }

    // ===================================================================================
    //                                                                          UnionQuery
    //                                                                          ==========
    public void registerUnionQuery(String unionQueryClause, boolean unionAll) {
        assertStringNotNullAndNotTrimmedEmpty("unionQueryClause", unionQueryClause);
        final UnionQueryInfo unionQueryInfo = new UnionQueryInfo();
        unionQueryInfo.setUnionQueryClause(unionQueryClause);
        unionQueryInfo.setUnionAll(unionAll);
        _unionQueryInfoList.add(unionQueryInfo);
    }

    protected static class UnionQueryInfo {
        protected String _unionQueryClause;
        protected boolean _unionAll;
        public String getUnionQueryClause() {
            return _unionQueryClause;
        }
        public void setUnionQueryClause(String unionQueryClause) {
            _unionQueryClause = unionQueryClause;
        }
        public boolean isUnionAll() {
            return _unionAll;
        }
        public void setUnionAll(boolean unionAll) {
            _unionAll = unionAll;
        }
    }

    // ===================================================================================
    //                                                                             Advance
    //                                                                             =======
    /**
     * @param fetchSize Fetch-size. (NotMinus & NotZero)
     * @return this. (NotNull)
     */
    public ${glSqlClauseInterfaceName} fetchFirst(int fetchSize) {
        _isFetchScopeEffective = true;
        if (fetchSize <= 0) {
            String msg = "Argument[fetchSize] must be plus: " + fetchSize;
            throw new IllegalArgumentException(msg);
        }
        _fetchStartIndex = 0;
        _fetchSize = fetchSize;
        _fetchPageNumber = 1;
        doClearFetchPageClause();
        doFetchFirst();
        return this;
    }

    /**
     * @param fetchStartIndex Fetch-start-index. 0 origin. (NotMinus)
     * @param fetchSize Fetch size. (NotMinus)
     * @return this. (NotNull)
     */
    public ${glSqlClauseInterfaceName} fetchScope(int fetchStartIndex, int fetchSize) {
        _isFetchScopeEffective = true;
        if (fetchStartIndex < 0) {
            String msg = "Argument[fetchStartIndex] must be plus or zero: " + fetchStartIndex;
            throw new IllegalArgumentException(msg);
        }
        if (fetchSize <= 0) {
            String msg = "Argument[fetchSize] must be plus: " + fetchSize;
            throw new IllegalArgumentException(msg);
        }
        _fetchStartIndex = fetchStartIndex;
        _fetchSize = fetchSize;
        return fetchPage(1);
    }

    /**
     * @param fetchPageNumber Page-number. 1 origin. (NotMinus & NotZero: If minus or zero, set one.)
     * @return this. (NotNull)
     */
    public ${glSqlClauseInterfaceName} fetchPage(int fetchPageNumber) {
        _isFetchScopeEffective = true;
        if (fetchPageNumber <= 0) {
            fetchPageNumber = 1;
        }
        if (_fetchSize <= 0) {
            String msg = "Fetch size should not be minus or zero!" + getLineSeparator();
            msg = msg + "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *" + getLineSeparator();
            msg = msg + "When you invoke this method, it is necessary to invoke 'fetchFirst()' or 'fetchScope()' ahead of that. " + getLineSeparator();
            msg = msg + "Please confirm your program. Does it really invoke 'fetchPage()' with 'fetchFirst()' or 'fetchScope()'?" + getLineSeparator();
            msg = msg + "- - - - -" + getLineSeparator();
            msg = msg + "fetchPageNumber=" + fetchPageNumber + " _fetchSize=" + _fetchSize + getLineSeparator();
            msg = msg + "* * * * * * * * * */" + getLineSeparator();
            throw new IllegalStateException(msg);
        }
        _fetchPageNumber = fetchPageNumber;
        if (_fetchPageNumber == 1 && _fetchStartIndex == 0) {
            return fetchFirst(_fetchSize);
        }
        doClearFetchPageClause();
        doFetchPage();
        return this;
    }

    abstract protected void doFetchFirst();
    abstract protected void doFetchPage();
    abstract protected void doClearFetchPageClause();

    public int getFetchStartIndex() {
        return _fetchStartIndex;
    }

    public int getFetchSize() {
        return _fetchSize;
    }

    public int getFetchPageNumber() {
        return _fetchPageNumber;
    }

    /**
     * @return Page start index. 0 origin. (NotMinus)
     */
    public int getPageStartIndex() {
        if (_fetchPageNumber <= 0) {
            String msg = "_fetchPageNumber must be plus: " + _fetchPageNumber;
            throw new IllegalStateException(msg);
        }
        return _fetchStartIndex + (_fetchSize * (_fetchPageNumber - 1));
    }

    /**
     * @return Page end index. 0 origin. (NotMinus)
     */
    public int getPageEndIndex() {
        if (_fetchPageNumber <= 0) {
            String msg = "_fetchPageNumber must be plus: " + _fetchPageNumber;
            throw new IllegalStateException(msg);
        }
        return _fetchStartIndex + (_fetchSize * _fetchPageNumber);
    }

    public boolean isFetchScopeEffective() {
        return _isFetchScopeEffective;
    }

    public ${glSqlClauseInterfaceName} ignoreFetchScope() {
        _isFetchScopeEffective = false;
        doClearFetchPageClause();
        return this;
    }

    public ${glSqlClauseInterfaceName} makeFetchScopeEffective() {
        if (getFetchSize() > 0 && getFetchPageNumber() > 0) {
            fetchPage(getFetchPageNumber());
        }
        return this;
    }
	
    public boolean isFetchStartIndexSupported() {
        return true; // Default
    }

    public boolean isFetchSizeSupported() {
        return true; // Default
    }

    abstract protected String createSelectHint();
    abstract protected String createFromBaseTableHint();
    abstract protected String createFromHint();
    abstract protected String createSqlSuffix();

    // ===================================================================================
    //                                                                     Fetch Narrowing
    //                                                                     ===============
    /**
     * ${database.ImplementComment}
     * 
     * @return Fetch-narrowing start-index.
     */
    public int getFetchNarrowingSkipStartIndex() {
        return getPageStartIndex();
    }

    /**
     * ${database.ImplementComment}
     * 
     * @return Fetch-narrowing size.
     */
    public int getFetchNarrowingLoopCount() {
        return getFetchSize();
    }

    /**
     * ${database.ImplementComment}
     * 
     * @return Determiantion.
     */
    public boolean isFetchNarrowingEffective() {
        return _isFetchScopeEffective;
    }

    // ===================================================================================
    //                                                                            Resolver
    //                                                                            ========
    public String resolveJoinAliasName(String relationPath, int cqNestNo) {
        return resolveNestLevelExpression("dfrelation" + relationPath, cqNestNo);
    }

    public String resolveNestLevelExpression(String name, int cqNestNo) {
        // if (cqNestNo > 1) {
        //     return name + "_n" + cqNestNo;
        // } else {
        //     return name;
        // }
		return name;
    }

    public int resolveRelationNo(String localTableName, String foreignPropertyName) {
        final ${glDBMetaInterfaceName} dbmeta = ${glDBMetaInstanceHandlerName}.findDBMeta(localTableName);
        final ${glForeignInfoName} foreignInfo = dbmeta.findForeignInfo(foreignPropertyName);
        return foreignInfo.getRelationNo();
    }

	// ===================================================================================
    //                                                                    Table Alias Info
    //                                                                    ================
	public String getLocalTableAliasName() {
	    return "dflocal";
	}
	
	public String getForeignTableAliasPrefix() {
	    return "dfrelation";
	}

	// ===================================================================================
    //                                                                       Template Mark
    //                                                                       =============
	public String getWhereClauseMark() {
	    return "#df:whereClause#";
	}
	
	public String getWhereFirstConditionMark() {
	    return "#df:whereFirstCondition#";
	}
	
	public String getUnionSelectClauseMark() {
	    return "#df:unionSelectClause#";
	}
	
	public String getUnionWhereClauseMark() {
	    return "#df:unionWhereClause#";
	}
	
	public String getUnionWhereFirstConditionMark() {
	    return "#df:unionWhereFirstCondition#";
	}
	
    // =====================================================================================
    //                                                            Where Clause Simple Filter
    //                                                            ==========================
    public void addWhereClauseSimpleFilter(${glWhereClauseSimpleFilterInterfaceName} whereClauseSimpleFilter) {
		if (_whereClauseSimpleFilterList == null) {
		    _whereClauseSimpleFilterList = new ArrayList<${glWhereClauseSimpleFilterInterfaceName}>();
		}
        _whereClauseSimpleFilterList.add(whereClauseSimpleFilter);
    }

    protected String filterWhereClauseSimply(String clauseElement) {
        if (_whereClauseSimpleFilterList == null || _whereClauseSimpleFilterList.isEmpty()) {
            return clauseElement;
        }
        for (final Iterator<${glWhereClauseSimpleFilterInterfaceName}> ite = _whereClauseSimpleFilterList.iterator(); ite.hasNext(); ) {
            final ${glWhereClauseSimpleFilterInterfaceName} filter = ite.next();
            if (filter == null) {
                String msg = "The list of filter should not have null: _whereClauseSimpleFilterList=" + _whereClauseSimpleFilterList;
                throw new IllegalStateException(msg);
            }
            clauseElement = filter.filterClauseElement(clauseElement);
        }
        return clauseElement;
    }
	
    // =====================================================================================
    //                                                                 Selected Foreign Info
    //                                                                 =====================
	public boolean hasSelectedForeignInfo(String relationPath) {
		if (_selectedForeignInfo == null) {
		    return false;
		}
	    return _selectedForeignInfo.containsKey(relationPath);
	}

	public void registerSelectedForeignInfo(String relationPath, String foreignPropertyName) {
		if (_selectedForeignInfo == null) {
		    _selectedForeignInfo = new HashMap<String, String>();
		}
		_selectedForeignInfo.put(relationPath, foreignPropertyName);
	}
	
    // ===================================================================================
    //                                                                              Helper
    //                                                                              ======
    protected final String replaceString(String text, String fromText, String toText) {
	    return ${glSimpleStringUtil}.replace(text, fromText, toText);
    }
	
    protected String getLineSeparator() {
        return ${glSimpleSystemUtil}.getLineSeparator();
    }

    // -----------------------------------------------------
    //                                         Assert Object
    //                                         -------------
    protected void assertObjectNotNull(String variableName, Object value) {
	    ${glSimpleAssertUtil}.assertObjectNotNull(variableName, value);
    }

    // -----------------------------------------------------
    //                                         Assert String
    //                                         -------------
    protected void assertStringNotNullAndNotTrimmedEmpty(String variableName, String value) {
	    ${glSimpleAssertUtil}.assertStringNotNullAndNotTrimmedEmpty(variableName, value);
    }
}
