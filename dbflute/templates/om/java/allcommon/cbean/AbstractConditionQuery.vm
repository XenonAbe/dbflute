${database.allClassCopyright}package ${glPackageBaseCommonCBean};

#set ($myClassName = "${glConditionQueryAbstractName}")
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.LinkedHashMap;
import java.util.Iterator;

import ${glPackageBaseCommonCKey}.${glConditionKeyName};
import ${glPackageBaseCommonCOption}.${glConditionOptionInterfaceName};
import ${glPackageBaseCommonCOption}.${glConditionOptionFromToName};
import ${glPackageBaseCommonCOption}.${glConditionOptionLikeSearchName};
import ${glPackageBaseCommonCOption}.${glConditionOptionInScopeName};
import ${glPackageBaseCommonCValue}.${glConditionValueName};
import ${glPackageBaseCommonDBMeta}.${glDBMetaInterfaceName};
import ${glPackageBaseCommonDBMeta}.${glDBMetaInstanceHandlerName};
import ${glPackageBaseCommonSqlClause}.${glSqlClauseName};
import ${glPackageBaseCommonException}.${glRequiredOptionNotFoundException};
import ${glPackageBaseCommonUtil}.${glSimpleStringUtil};
import ${glPackageBaseCommonUtil}.${glSimpleSystemUtil};

/**
 * The abstract class of condition-query.
 * @author ${database.ClassAuthor}
 */
public abstract class ${myClassName} implements ${glConditionQueryInterfaceName} {

    // ===================================================================================
    //                                                                           Attribute
    //                                                                           =========
    /** Condition value for DUMMY. */
    protected static final ${glConditionValueName} DUMMY_CONDITION_VALUE = new ${glConditionValueName}();

    /** Object for DUMMY. */
    protected static final Object DUMMY_OBJECT = new Object();
	
    /** The property of condition-query. */
	protected static final String CQ_PROPERTY = "conditionQuery";

    /** SQL clause. */
    protected final ${glSqlClauseName} _sqlClause;

    /** My alias name. */
    protected final String _aliasName;

    /** The level of nest. */
    protected final int _nestLevel;
	
	/** The level of subQuery. */
	protected int _subQueryLevel;

    // -----------------------------------------------------
    //                                          Foreign Info
    //                                          ------------
    /** The property name of foreign. */
    protected String _foreignPropertyName;

    /** The path of relation. */
    protected String _relationPath;

    /** The query of child. */
    protected final ${glConditionQueryInterfaceName} _childQuery;

    // -----------------------------------------------------
    //                                                Inline
    //                                                ------
	/** Is it the inline for on-clause. (Property for Inline Only) */
	protected boolean _onClauseInline;
	
    // ===================================================================================
    //                                                                         Constructor
    //                                                                         ===========
    /**
     * Constructor.
     * @param childQuery Child query. (Nullable: If null, this is base instance.)
     * @param sqlClause SQL clause instance. (NotNull)
     * @param aliasName My alias name. (NotNull)
     * @param nestLevel Nest level.
     */
    public ${myClassName}(${glConditionQueryInterfaceName} childQuery, ${glSqlClauseName} sqlClause, String aliasName, int nestLevel) {
        _childQuery = childQuery;
        _sqlClause = sqlClause;
        _aliasName = aliasName;
        _nestLevel = nestLevel;
    }

    // ===================================================================================
    //                                                                  Important Accessor
    //                                                                  ==================
    /**
     * Get child query.
     * @return Child query. (Nullable)
     */
    public ${glConditionQueryInterfaceName} getChildQuery() {
        return _childQuery;
    }

    /**
     * Get sql clause.
     * @return Sql clause. (NotNull)
     */
    public ${glSqlClauseName} getSqlClause() {
        return _sqlClause;
    }

    /**
     * Get alias name.
     * @return Alias name. (NotNull)
     */
    public String getAliasName() {
        return _aliasName;
    }

    /**
     * Get nest level.
     * @return Nest level.
     */
    public int getNestLevel() {
        return _nestLevel;
    }

    /**
     * Get next nest level.
     * @return Next nest level.
     */
    public int getNextNestLevel() {
        return _nestLevel+1;
    }

    /**
     * Is base query?
     * @param query Condition query. (NotNull)
     * @return Determination.
     */
    public boolean isBaseQuery(${glConditionQueryInterfaceName} query) {
        return (query.getChildQuery() == null);
    }

	/**
	 * Get the level of subQuery.
	 * @return The level of subQuery.
	 */
	public int getSubQueryLevel() {
	    return _subQueryLevel;
	}
	
    // -----------------------------------------------------
    //                                             Real Name
    //                                             ---------
    /**
     * Get real alias name(that has nest level mark).
     * @return Real alias name.
     */
    public String getRealAliasName() {
        return getAliasName();
    }

    /**
     * Get real column name(with real alias name).
     * @param columnName Column name without alias name. This should not contain comma. (NotNull)
     * @return Real column name.
     */
    public String getRealColumnName(String columnName) {
        assertColumnName(columnName);
        return buildRealColumnName(getRealAliasName(), columnName);
    }

    /**
     * Build real column name.
     * @param aliasName Alias name. (NotNull)
     * @param columnName Column name. (NotNull)
     * @return Real column name. (NotNull)
     */
    protected String buildRealColumnName(String aliasName, String columnName) {
        return aliasName + "." + columnName;
    }

    // -----------------------------------------------------
    //                                          Foreign Info
    //                                          ------------
    public String getForeignPropertyName() {
        return _foreignPropertyName;
    }

    public void xsetForeignPropertyName(String foreignPropertyName) {
        this._foreignPropertyName = foreignPropertyName;
    }

    public String getRelationPath() {
        return _relationPath;
    }

    public void xsetRelationPath(String relationPath) {
        this._relationPath = relationPath;
    }

    // -----------------------------------------------------
    //                                                Inline
    //                                                ------
	public void xsetOnClauseInline(boolean onClauseInline) {
	    _onClauseInline = onClauseInline;
	}
	
    // ===================================================================================
    //                                                                            Location
    //                                                                            ========
    /**
     * Get location.
     * @param columnPropertyName Column property name.
     * @param key Condition key.
     * @return Next nest level.
     */
    protected String getLocation(String columnPropertyName, ${glConditionKeyName} key) {
        return getLocationBase(columnPropertyName) + "." + key.getConditionKey();
    }

    protected String getLocationBase() {
        final StringBuffer sb = new StringBuffer();
        ${glConditionQueryInterfaceName} query = this;
        while (true) {
            if (query.isBaseQuery(query)) {
                sb.insert(0, CQ_PROPERTY + ".");
                break;
            } else {
                final String foreignPropertyName = query.getForeignPropertyName();
                if (foreignPropertyName == null) {
                    String msg = "The foreignPropertyName of the query should not be null:";
                    msg = msg + " query=" + query;
                    throw new IllegalStateException(msg);
                }
                sb.insert(0, CQ_PROPERTY + initCap(foreignPropertyName) + ".");
            }
            query = query.getChildQuery();
        }
        return sb.toString();
    }

    protected String getLocationBase(String columnPropertyName) {
        return getLocationBase() + columnPropertyName;
    }

    // ===================================================================================
    //                                                                         Union Query
    //                                                                         ===========
    /** The map of union query. */
    protected Map<String, ${glConditionQueryInterfaceName}> _unionQueryMap;

    /**
     * Get the map of union query.
     * 
     * @return The map of union query. (NotNull)
     */
    public Map<String, ${glConditionQueryInterfaceName}> getUnionQueryMap() {// for Internal
		if (_unionQueryMap == null) {
		    _unionQueryMap = new LinkedHashMap<String, ${glConditionQueryInterfaceName}>();
		}
        return _unionQueryMap;
    }

    /**
     * Set union query. {Internal}
     * <pre>
     * Add union query to condition bean.
     * </pre>
     * @param unionQuery Union query. (NotNull)
     */
    public void xsetUnionQuery(${glConditionQueryInterfaceName} unionQuery) {
        xsetupUnion(unionQuery, false, getUnionQueryMap());
    }

    /** The map of union all query. */
    protected Map<String, ${glConditionQueryInterfaceName}> _unionAllQueryMap;

    /**
     * Get the map of union all query.
     * 
     * @return The map of union all query. (NotNull)
     */
    public Map<String, ${glConditionQueryInterfaceName}> getUnionAllQueryMap() {// for Internal
		if (_unionAllQueryMap == null) {
		    _unionAllQueryMap = new LinkedHashMap<String, ${glConditionQueryInterfaceName}>();
		}
        return _unionAllQueryMap;
    }

    /**
     * Set union all query. {Internal}
     * <pre>
     * Add union all query to condition bean.
     * </pre>
     * @param unionAllQuery Union all query. (NotNull)
     */
    public void xsetUnionAllQuery(${glConditionQueryInterfaceName} unionAllQuery) {
        xsetupUnion(unionAllQuery, true, getUnionAllQueryMap());
    }

    protected void xsetupUnion(${glConditionQueryInterfaceName} unionQuery, boolean unionAll, Map<String, ${glConditionQueryInterfaceName}> unionQueryMap) {
        if (unionQuery == null) {
            String msg = "The argument[unionQuery] should not be null.";
            throw new IllegalArgumentException(msg);
        }
        reflectRelationOnUnionQuery(this, unionQuery);// Reflect Relation!
        getSqlClause().copyIncludedSelectColumn(unionQuery.getSqlClause());// Reflect IncludedSelectColumn!
		if (getSqlClause().isFormatClauseEffective()) {
		    unionQuery.getSqlClause().makeFormatClauseEffective();// Reflect FormatClause!
		}
        final String key = (unionAll ? "unionAllQuery" : "unionQuery") + unionQueryMap.size();
        unionQueryMap.put(key, unionQuery);
        registerUnionQuery(unionQuery, unionAll, (unionAll ? "unionAllQueryMap" : "unionQueryMap") + "." + key);
    }

    /**
     * Reflect relation on union query.
     * 
     * @param baseQueryAsSuper Base query as super. (NotNull)
     * @param unionQueryAsSuper Union query as super. (NotNull)
     */
    abstract protected void reflectRelationOnUnionQuery(${glConditionQueryInterfaceName} baseQueryAsSuper, ${glConditionQueryInterfaceName} unionQueryAsSuper);

    /**
     * Has union query or union all query?
     * 
     * @return Determination.
     */
    public boolean hasUnionQueryOrUnionAllQuery() {
        return (_unionQueryMap != null && !_unionQueryMap.isEmpty()) || (_unionAllQueryMap != null && !_unionAllQueryMap.isEmpty());
    }

    /**
     * Get the list of union query.
     * 
     * @return The list of union query. (NotNull)
     */
    public List<${glConditionQueryInterfaceName}> getUnionQueryList() {
		if (_unionQueryMap == null) { return new ArrayList<${glConditionQueryInterfaceName}>(); }
        return new ArrayList<${glConditionQueryInterfaceName}>(_unionQueryMap.values());
    }

    /**
     * Get the list of union all query.
     * 
     * @return The list of union all query. (NotNull)
     */
    public List<${glConditionQueryInterfaceName}> getUnionAllQueryList() {
		if (_unionAllQueryMap == null) { return new ArrayList<${glConditionQueryInterfaceName}>(); }
        return new ArrayList<${glConditionQueryInterfaceName}>(_unionAllQueryMap.values());
    }

    // ===================================================================================
    //                                                                            Register
    //                                                                            ========
    // -----------------------------------------------------
    //                                       Include-As-Mine
    //                                       ---------------
    /**
     * Register included-select-column.
     * 
     * @param aliasName Alias name. This should not contain comma. (NotNull)
     * @param realColumnName Real column name. This should not contain comma. (NotNull)
     */
    protected void registerIncludedSelectColumn(String aliasName, String realColumnName) {
        assertAliasName(aliasName);
        assertColumnName(realColumnName);
        getSqlClause().registerIncludedSelectColumn(aliasName, realColumnName);
    }

    // -----------------------------------------------------
    //                                                 Query
    //                                                 -----
    protected void registerQuery(${glConditionKeyName} key, Object value, ${glConditionValueName} cvalue
                                 , String colName, String capPropName, String uncapPropName) {
        if (key.isValidRegistration(cvalue, value, key.getConditionKey() + " of " + getRealAliasName() + "." + colName)) {
            setupConditionValueAndRegisterWhereClause(key, value, cvalue, colName, capPropName, uncapPropName);
        }
    }

    protected void registerQuery(${glConditionKeyName} key, Object value, ${glConditionValueName} cvalue
                                 , String colName, String capPropName, String uncapPropName, ${glConditionOptionInterfaceName} option) {
        if (key.isValidRegistration(cvalue, value, key.getConditionKey() + " of " + getRealAliasName() + "." + colName)) {
            setupConditionValueAndRegisterWhereClause(key, value, cvalue, colName, capPropName, uncapPropName, option);
        }
    }

    // -----------------------------------------------------
    //                                          FromTo Query
    //                                          ------------
    protected void registerFromToQuery(java.util.Date fromDate, java.util.Date toDate, ${glConditionValueName} cvalue
                                 , String colName, String capPropName, String uncapPropName, ${glConditionOptionFromToName} option) {
        {
            final java.util.Date filteredFromDate = option.filterFromDate(fromDate);
            final ${glConditionKeyName} fromKey = option.getFromDateConditionKey();
            if (fromKey.isValidRegistration(cvalue, filteredFromDate, fromKey.getConditionKey() + " of " + getRealAliasName() + "." + uncapPropName)) {
                setupConditionValueAndRegisterWhereClause(fromKey, filteredFromDate, cvalue, colName, capPropName, uncapPropName);
            }
        }
        {
            final java.util.Date filteredToDate = option.filterToDate(toDate);
            final ${glConditionKeyName} toKey = option.getToDateConditionKey();
            if (toKey.isValidRegistration(cvalue, filteredToDate, toKey.getConditionKey() + " of " + getRealAliasName() + "." + uncapPropName)) {
                setupConditionValueAndRegisterWhereClause(toKey, filteredToDate, cvalue, colName, capPropName, uncapPropName);
            }
        }
    }

    // -----------------------------------------------------
    //                                      LikeSearch Query
    //                                      ----------------
    protected void registerLikeSearchQuery(${glConditionKeyName} key
	                                     , String value
										 , ${glConditionValueName} cvalue
										 , String colName
										 , String capPropName
										 , String uncapPropName
										 , ${glConditionOptionLikeSearchName} option) {
        final String validationMsg = key.getConditionKey() + " of " + getRealAliasName() + "." + colName;
        if (!key.isValidRegistration(cvalue, value, validationMsg)) {
            return;
        }
        if (option == null) {
            throwLikeSearchOptionNotFoundException(capPropName, value);
			return;// Unreachable!
        }
        if (value == null || !option.isSplit()) {
            // As Normal Condition.
            setupConditionValueAndRegisterWhereClause(key, value, cvalue, colName, capPropName, uncapPropName, option);
			return;
        }
        // - - - - - - - - -
        // Use splitByXxx().
        // - - - - - - - - -
        final String[] strArray = option.generateSplitValueArray(value);
        if (!option.isAsOrSplit()) {
            // As 'and' Condition
            for (int i = 0; i < strArray.length; i++) {
                final String currentValue = strArray[i];
                setupConditionValueAndRegisterWhereClause(key, currentValue, cvalue, colName, capPropName, uncapPropName, option);
                
                // Callback for LikeAsOr!
                final List<${glConditionOptionLikeSearchName}.LikeAsOrCallback> callbackList = option.getLikeAsOrCallbackList();
                if (!callbackList.isEmpty()) {
                    getSqlClause().makeAdditionalConditionAsOrEffective();
                    for (Iterator<${glConditionOptionLikeSearchName}.LikeAsOrCallback> ite = callbackList.iterator(); ite.hasNext();) {
                        final ${glConditionOptionLikeSearchName}.LikeAsOrCallback likeAsOrCallback = (${glConditionOptionLikeSearchName}.LikeAsOrCallback) ite.next();
                        final String additionalTargetPropertyName = likeAsOrCallback.getAdditionalTargetPropertyName();
                        final String filteredValue = likeAsOrCallback.filterValue(currentValue);
                        final ${glConditionOptionLikeSearchName} optionDeepCopy = (${glConditionOptionLikeSearchName}) option.createDeepCopy();
                        optionDeepCopy.clearLikeAsOrCallback();
                        final ${glConditionOptionLikeSearchName} filteredOption = likeAsOrCallback.filterOption(optionDeepCopy);
                        invokeSetterLikeSearch(additionalTargetPropertyName, filteredValue, filteredOption);
                    }
                    getSqlClause().ignoreAdditionalConditionAsOr();
                }
            }
        } else {
            // As 'or' Condition
            for (int i = 0; i < strArray.length; i++) {
                final String currentValue = strArray[i];
                if (i == 0) {
                    setupConditionValueAndRegisterWhereClause(key, currentValue, cvalue, colName, capPropName, uncapPropName, option);
                } else {
                    getSqlClause().makeAdditionalConditionAsOrEffective();
                    invokeSetterLikeSearch(uncapPropName, currentValue, option);
                }
            }
            
            // @jflute -- Callback for LikeAsOr!
            // final List<${glConditionOptionLikeSearchName}.LikeAsOrCallback> callbackList = option.getLikeAsOrCallbackList();
            // ...
            
            getSqlClause().ignoreAdditionalConditionAsOr();
        }
    }

    protected void throwLikeSearchOptionNotFoundException(String capPropName, String value) {
        String msg = "Look! Read the message below." + getLineSeparator();
        msg = msg + "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *" + getLineSeparator();
        msg = msg + "The likeSearchOption was Not Found! (Should not be null!)" + getLineSeparator();
        msg = msg + getLineSeparator();
        msg = msg + "[Advice]" + getLineSeparator();
        msg = msg + "Please confirm your method call:"  + getLineSeparator();
		final String beanName = getClass().getSimpleName();
		final String methodName = "set" + capPropName + "_LikeSearch('" + value + "', likeSearchOption);";
        msg = msg + "    " + beanName + "." + methodName + getLineSeparator();
        msg = msg + "* * * * * * * * * */" + getLineSeparator();
        throw new ${glRequiredOptionNotFoundException}(msg);
    }
		
    protected void invokeSetterLikeSearch(String columnFlexibleName, Object value, ${glConditionOptionLikeSearchName} option) {
        if (value == null) {
            return;
        }
        final ${glDBMetaInterfaceName} dbmeta = ${glDBMetaInstanceHandlerName}.findDBMeta(getTableDbName());
        final String columnCapPropName = initCap(dbmeta.findPropertyName(columnFlexibleName));
        String methodName = "set" + columnCapPropName + "_" + "likeSearch".substring(0, 1).toUpperCase() + "likeSearch".substring(1);
        java.lang.reflect.Method method = null;
        try {
            method = this.getClass().getMethod(methodName, new Class[]{value.getClass(), ${glConditionOptionLikeSearchName}.class});
        } catch (NoSuchMethodException e) {
            String msg = "The columnFlexibleName is not existing in this table: columnFlexibleName=" + columnFlexibleName;
            msg = msg + " tableName=" + getTableDbName() + " methodName=" + methodName;
            throw new RuntimeException(msg, e);
        }
        try {
            method.invoke(this, new Object[]{value, option});
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (java.lang.reflect.InvocationTargetException e) {
            throw new RuntimeException(e.getCause());
        }
    }

    // -----------------------------------------------------
    //                                         InScope Query
    //                                         -------------
    protected void registerInScopeQuery(${glConditionKeyName} key, String value, ${glConditionValueName} cvalue
                                     , String colName, String capPropName, String uncapPropName, ${glConditionOptionInScopeName} option) {
        if (key.isValidRegistration(cvalue, value, key.getConditionKey() + " of " + getRealAliasName() + "." + colName)) {
            if (value != null && option.isSplit()) {
                final String[] strArray = option.generateSplitValueArray(value);
                final List<String> realValueList = new ArrayList<String>();
                for (int i=0; i < strArray.length; i++) {
                    final String currentValue = strArray[i];
                    realValueList.add(currentValue);
                }
                setupConditionValueAndRegisterWhereClause(key, realValueList, cvalue, colName, capPropName, uncapPropName, option);
            } else {
                setupConditionValueAndRegisterWhereClause(key, value, cvalue, colName, capPropName, uncapPropName, option);
            }
        }
    }

    // -----------------------------------------------------
    //                                          Inline Query
    //                                          ------------
    protected void registerInlineQuery(${glConditionKeyName} key, Object value, ${glConditionValueName} cvalue
                                       , String colName, String capPropName, String uncapPropName) {
        if (key.isValidRegistration(cvalue, value, key.getConditionKey() + " of " + getRealAliasName() + "." + colName)) {
            key.setupConditionValue(cvalue, value, getLocation(uncapPropName, key));// If Java, it is necessary to use uncapPropName!
            if (isBaseQuery(this)) {
                getSqlClause().registerBaseTableInlineWhereClause(colName, key, cvalue);
            } else {
                getSqlClause().registerOuterJoinInlineWhereClause(getRealAliasName(), colName, key, cvalue, _onClauseInline);
            }
        }
    }

    protected void registerInlineQuery(${glConditionKeyName} key, Object value, ${glConditionValueName} cvalue
                                       , String colName, String capPropName, String uncapPropName, ${glConditionOptionInterfaceName} option) {
        if (key.isValidRegistration(cvalue, value, key.getConditionKey() + " of " + getRealAliasName() + "." + colName)) {
            key.setupConditionValue(cvalue, value, getLocation(uncapPropName, key), option);// If Java, it is necessary to use uncapPropName!
            if (isBaseQuery(this)) {
                getSqlClause().registerBaseTableInlineWhereClause(colName, key, cvalue, option);
            } else {
				getSqlClause().registerOuterJoinInlineWhereClause(getRealAliasName(), colName, key, cvalue, option, _onClauseInline);
            }
        }
    }

    // -----------------------------------------------------
    //                                       InScopeSubQuery
    //                                       ---------------
    protected void registerInScopeSubQuery(${glConditionQueryInterfaceName} subQuery
                                 , String columnName, String relatedColumnName, String propertyName) {
        final String realColumnName = getInScopeSubQueryRealColumnName(columnName);
        final String subQueryClause = getInScopeSubQuerySql(subQuery, relatedColumnName, propertyName);
		final String clause;
        if (getSqlClause().isFormatClauseEffective()) {
		    final String ln = getLineSeparator();
            final int subQueryLevel = subQuery.getSubQueryLevel();
            final String subQueryIdentity = propertyName + "[" + subQueryLevel + "]";
            final String beginMark = getSqlClause().resolveSubQueryBeginMark(subQueryIdentity) + ln;
            final String endMark = getSqlClause().resolveSubQueryEndMark(subQueryIdentity);
            final String endIndent = "       ";
			clause = realColumnName + " in (" + beginMark + subQueryClause + ln + endIndent + ")" + endMark;
        } else {
		    clause = realColumnName + " in (" + subQueryClause + ")";
        }
        registerWhereClause(clause);
    }

    protected String getInScopeSubQuerySql(${glConditionQueryInterfaceName} subQuery
                                 , String relatedColumnName, String propertyName) {
        final String selectClause = "select " + getSqlClause().getLocalTableAliasName() + "." + relatedColumnName;
        String fromWhereClause = subQuery.getSqlClause().getClauseFromWhereWithUnionTemplate();
        fromWhereClause = replaceString(fromWhereClause, ".conditionQuery.", "." + getLocationBase(propertyName) + ".");// Very Important!
		
		// Replace template marks. These are very important!
		fromWhereClause = replaceString(fromWhereClause, getSqlClause().getUnionSelectClauseMark(), selectClause);
		fromWhereClause = replaceString(fromWhereClause, getSqlClause().getUnionWhereClauseMark(), "");
		fromWhereClause = replaceString(fromWhereClause, getSqlClause().getUnionWhereFirstConditionMark(), "");
		
        return selectClause + " " + fromWhereClause;
    }

    protected String getInScopeSubQueryRealColumnName(String columnName) {
        return getRealColumnName(columnName);
    }
    
    // -----------------------------------------------------
    //                                        ExistsSubQuery
    //                                        --------------
    protected void registerExistsSubQuery(${glConditionQueryInterfaceName} subQuery
                                 , String columnName, String relatedColumnName, String propertyName) {
        final String realColumnName = getExistsSubQueryRealColumnName(columnName);
        final String subQueryClause = getExistsSubQuerySql(subQuery, realColumnName, relatedColumnName, propertyName);
		final String clause;
        if (getSqlClause().isFormatClauseEffective()) {
		    final String ln = getLineSeparator();
            final int subQueryLevel = subQuery.getSubQueryLevel();
            final String subQueryIdentity = propertyName + "[" + subQueryLevel + "]";
            final String beginMark = getSqlClause().resolveSubQueryBeginMark(subQueryIdentity) + ln;
            final String endMark = getSqlClause().resolveSubQueryEndMark(subQueryIdentity);
            final String endIndent = "       ";
			clause = "exists (" + beginMark + subQueryClause + ln + endIndent + ")" + endMark;
        } else {
		    clause = "exists (" + subQueryClause + ")";
        }
		registerWhereClause(clause);
    }

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    // *Unsupport ExistsSubQuery as inline because it's so dangerous.
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

    protected String getExistsSubQuerySql(${glConditionQueryInterfaceName} subQuery
                                 , String realColumnName, String relatedColumnName, String propertyName) {
		final int subQueryLevel = subQuery.getSubQueryLevel();
		if (_subQueryLevel <= subQueryLevel) {
			_subQueryLevel = subQueryLevel + 1;
		}
		final String tableAliasName = "dfsublocal_" + subQueryLevel;
        final String selectClause = "select " + tableAliasName + "." + relatedColumnName;
        String fromWhereClause = subQuery.getSqlClause().getClauseFromWhereWithWhereUnionTemplate();
		fromWhereClause = replaceString(fromWhereClause, "dflocal", tableAliasName);// Very Important!
        fromWhereClause = replaceString(fromWhereClause, ".conditionQuery.", "." + getLocationBase(propertyName) + ".");// Very Important!
		
        final String joinCondition = tableAliasName + "." + relatedColumnName + " = " + realColumnName;
        String firstConditionAfter = " and ";
        if (getSqlClause().isFormatClauseEffective()) {
            firstConditionAfter = getLineSeparator() + "   and ";
        }
        
		// Replace template marks. These are very important!
		fromWhereClause = replaceString(fromWhereClause, getSqlClause().getWhereClauseMark(), "where " + joinCondition);
		fromWhereClause = replaceString(fromWhereClause, getSqlClause().getWhereFirstConditionMark(), joinCondition + firstConditionAfter);
		fromWhereClause = replaceString(fromWhereClause, getSqlClause().getUnionSelectClauseMark(), selectClause);
		fromWhereClause = replaceString(fromWhereClause, getSqlClause().getUnionWhereClauseMark(), "where " + joinCondition);
		fromWhereClause = replaceString(fromWhereClause, getSqlClause().getUnionWhereFirstConditionMark(), joinCondition + firstConditionAfter);
		
		return selectClause + " " + fromWhereClause;
    }

    protected String getExistsSubQueryRealColumnName(String columnName) {
        return getRealColumnName(columnName);
    }

    // -----------------------------------------------------
    //                                          Where Clause
    //                                          ------------
    protected void setupConditionValueAndRegisterWhereClause(${glConditionKeyName} key, Object value, ${glConditionValueName} cvalue
                                                             , String colName, String capPropName, String uncapPropName) {
        key.setupConditionValue(cvalue, value, getLocation(uncapPropName, key));// If Java, it is necessary to use uncapPropName!
        getSqlClause().registerWhereClause(getRealColumnName(colName), key, cvalue);
    }

    protected void setupConditionValueAndRegisterWhereClause(${glConditionKeyName} key, Object value, ${glConditionValueName} cvalue
                                                             , String colName, String capPropName, String uncapPropName, ${glConditionOptionInterfaceName} option) {
        key.setupConditionValue(cvalue, value, getLocation(uncapPropName, key), option);// If Java, it is necessary to use uncapPropName!
        getSqlClause().registerWhereClause(getRealColumnName(colName), key, cvalue, option);
    }

    protected void registerWhereClause(String whereClause) {
        getSqlClause().registerWhereClause(whereClause);
    }

    protected void registerInlineWhereClause(String whereClause) {
        if (isBaseQuery(this)) {
            getSqlClause().registerBaseTableInlineWhereClause(whereClause);
        } else {
            getSqlClause().registerOuterJoinInlineWhereClause(getRealAliasName(), whereClause, _onClauseInline);
        }
    }

    // -----------------------------------------------------
    //                                           Union Query
    //                                           -----------
    public void registerUnionQuery(${glConditionQueryInterfaceName} unionQuery, boolean unionAll, String unionQueryPropertyName) {
        final String unionQueryClause = getUnionQuerySql(unionQuery, unionQueryPropertyName);
		
		// At the future, building SQL will be moved to sqlClause.
        getSqlClause().registerUnionQuery(unionQueryClause, unionAll);
    }

    protected String getUnionQuerySql(${glConditionQueryInterfaceName} unionQuery, String unionQueryPropertyName) {
	    final String fromClause = unionQuery.getSqlClause().getFromClause();
		final String whereClause = unionQuery.getSqlClause().getWhereClause();
		final String unionQueryClause;
		if (whereClause.trim().length() <= 0) {
		    unionQueryClause = fromClause + " " + getSqlClause().getUnionWhereClauseMark();
		} else {
		    final int whereIndex = whereClause.indexOf("where ");
		    if (whereIndex < 0) {
				String msg = "The whereClause should have 'where' string: " + whereClause;
			    throw new IllegalStateException(msg);
			}
			final int clauseIndex = whereIndex + "where ".length();
			final String mark = getSqlClause().getUnionWhereFirstConditionMark();
			unionQueryClause = fromClause + " " + whereClause.substring(0, clauseIndex) + mark + whereClause.substring(clauseIndex);
		}
        final String oldStr = ".conditionQuery.";
        final String newStr = ".conditionQuery." + unionQueryPropertyName + ".";
        return replaceString(unionQueryClause, oldStr, newStr);// Very Important!
    }

    // -----------------------------------------------------
    //                                               OrderBy
    //                                               -------
	public void withNullsFirst() {// is User Public!
	    getSqlClause().addNullsFirstToPreviousOrderBy();
	}
	
	public void withNullsLast() {// is User Public!
	    getSqlClause().addNullsLastToPreviousOrderBy();
	}
	
    protected void registerOrderBy(String columnName, boolean ascOrDesc) {
        getSqlClause().registerOrderBy(getRealColumnName(columnName), null, ascOrDesc);
    }
	
    // ===================================================================================
    //                                                                       Name Resolver
    //                                                                       =============
    /**
     * Resolve join alias name.
     * @param relationPath Relation path. (NotNull)
     * @param nestLevel Nest level.
     * @return Resolved join alias name. (NotNull)
     */
    protected String resolveJoinAliasName(String relationPath, int nestLevel) {
        return getSqlClause().resolveJoinAliasName(relationPath, nestLevel);
    }

    protected String resolveNestLevelExpression(String name) {
        return getSqlClause().resolveNestLevelExpression(name, getNestLevel());
    }

	protected String resolveNextRelationPath(String tableName, String relationPropertyName) {
	    final int relationNo = getSqlClause().resolveRelationNo(tableName, relationPropertyName);
        String nextRelationPath = "_" + relationNo;
        if (_relationPath != null) {
            nextRelationPath = _relationPath + nextRelationPath;
        }
		return nextRelationPath;
	}
	
    // ===================================================================================
    //                                                                     Fixed Condition
    //                                                                     ===============
    protected String prepareFixedCondition(String fixedCondition, String localAliasName, String foreignAliasName) {
        fixedCondition = replaceString(fixedCondition, "$$alias$$", foreignAliasName);
        fixedCondition = replaceString(fixedCondition, "$$foreignAlias$$", foreignAliasName);
        fixedCondition = replaceString(fixedCondition, "$$localAlias$$", localAliasName);
        return fixedCondition;
    }

    // ===================================================================================
    //                                                                              Invoke
    //                                                                              ======
    /**
     * ${database.ImplementComment}
     * 
     * @param columnFlexibleName The flexible name of the column. (NotNull and NotEmpty)
     * @return The conditionValue. (NotNull)
     */
    public ${glConditionValueName} invokeValue(String columnFlexibleName) {
        final ${glDBMetaInterfaceName} dbmeta = ${glDBMetaInstanceHandlerName}.findDBMeta(getTableDbName());
        final String columnCapPropName = initCap(dbmeta.findPropertyName(columnFlexibleName));
        String methodName = "get" + columnCapPropName;
        java.lang.reflect.Method method = null;
        try {
            method = this.getClass().getMethod(methodName, new Class[]{});
        } catch (NoSuchMethodException e) {
            String msg = "The columnFlexibleName is not existing in this table: columnFlexibleName=" + columnFlexibleName;
            msg = msg + " tableName=" + getTableDbName() + " methodName=" + methodName;
            throw new RuntimeException(msg, e);
        }
        try {
            final Object result = method.invoke(this, new Object[]{});
            return (${glConditionValueName})result;
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (java.lang.reflect.InvocationTargetException e) {
            throw new RuntimeException(e.getCause());
        }
    }

    /**
     * Invoke setting query.
     * 
     * @param columnFlexibleName The flexible name of the column. (NotNull and NotEmpty)
     * @param conditionKeyName The name of the conditionKey. (NotNull)
     * @param value The value of the condition. (NotNull)
     */
    public void invokeQuery(String columnFlexibleName, String conditionKeyName, Object value) {
        if (value == null) {
            return;
        }
        final ${glDBMetaInterfaceName} dbmeta = ${glDBMetaInstanceHandlerName}.findDBMeta(getTableDbName());
        final String columnCapPropName = initCap(dbmeta.findPropertyName(columnFlexibleName));
        String methodName = "set" + columnCapPropName + "_" + conditionKeyName.substring(0, 1).toUpperCase() + conditionKeyName.substring(1);
        java.lang.reflect.Method method = null;
        try {
            method = this.getClass().getMethod(methodName, new Class[]{value.getClass()});
        } catch (NoSuchMethodException e) {
            String msg = "The columnFlexibleName is not existing in this table: columnFlexibleName=" + columnFlexibleName;
            msg = msg + " tableName=" + getTableDbName() + " methodName=" + methodName;
            throw new RuntimeException(msg, e);
        }
        try {
            method.invoke(this, new Object[]{value});
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (java.lang.reflect.InvocationTargetException e) {
            throw new RuntimeException(e.getCause());
        }
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param columnFlexibleName The flexible name of a column. (NotNull and NotEmpty)
     * @param isAsc Is it ascend?
     */
    public void invokeOrderBy(String columnFlexibleName, boolean isAsc) {
        String ascDesc = null;
        if (isAsc) {
            ascDesc = "Asc";
        } else {
            ascDesc = "Desc";
        }
        final ${glDBMetaInterfaceName} dbmeta = ${glDBMetaInstanceHandlerName}.findDBMeta(getTableDbName());
        final String columnCapPropName = initCap(dbmeta.findPropertyName(columnFlexibleName));
        final String methodName = "addOrderBy_" + columnCapPropName + "_" + ascDesc;

        java.lang.reflect.Method method = null;
        try {
            method = this.getClass().getMethod(methodName, new Class[]{});
        } catch (NoSuchMethodException e) {
            String msg = "The columnFlexibleName is not existing in this table: columnFlexibleName=" + columnFlexibleName;
            msg = msg + " tableName=" + getTableDbName() + " methodName=" + methodName;
            throw new RuntimeException(msg, e);
        }
        try {
            method.invoke(this, new Object[]{});
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (java.lang.reflect.InvocationTargetException e) {
            throw new RuntimeException(e.getCause());
        }
    }

    /**
     * ${database.ImplementComment}
     * 
     * @param foreignPropertyName The property name of foreign. (NotNull and NotEmpty)
     * @return The conditionQuery of foreign as interface. (NotNull)
     */
    public ${glConditionQueryInterfaceName} invokeForeignCQ(String foreignPropertyName) {
        final String methodName = "query" + foreignPropertyName.substring(0, 1).toUpperCase() + foreignPropertyName.substring(1);
        java.lang.reflect.Method method = null;
        try {
            method = this.getClass().getMethod(methodName, new Class[]{});
        } catch (NoSuchMethodException e) {
            String msg = "The foreignPropertyName is not existing in this table: foreignPropertyName=" + foreignPropertyName;
            msg = msg + " tableName=" + getTableDbName() + " methodName=" + methodName;
            throw new RuntimeException(msg, e);
        }
        try {
            return (${glConditionQueryInterfaceName})method.invoke(this, new Object[]{});
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (java.lang.reflect.InvocationTargetException e) {
            throw new RuntimeException(e.getCause());
        }
    }

    // ===================================================================================
    //                                                                       Assist Helper
    //                                                                       =============
    /**
     * @param value Query-value-string. (Nullable)
     * @return Filtered value. (Nullable)
     */
    protected String filterRemoveEmptyString(String value) {
        return ((value != null && !"".equals(value)) ? value : null);
    }
	
    /**
     * @param col Target collection. (Nullable)
     * @param <PROPERTY_TYPE> The type of property.
     * @return List. (Nullable: If the argument is null, returns null.)
     */
    protected <PROPERTY_TYPE> List<PROPERTY_TYPE> convertToList(Collection<PROPERTY_TYPE> col) {
        if (col == null) {
            return null;
        }
        if (col instanceof List) {
            return filterRemoveNullOrEmptyValueFromList((List<PROPERTY_TYPE>)col);
        }
        return filterRemoveNullOrEmptyValueFromList(new ArrayList<PROPERTY_TYPE>(col));
    }

    private <PROPERTY_TYPE> List<PROPERTY_TYPE> filterRemoveNullOrEmptyValueFromList(List<PROPERTY_TYPE> ls) {
        if (ls == null) {
            return null;
        }
        List<PROPERTY_TYPE> newList = new ArrayList<PROPERTY_TYPE>();
        for (Iterator<PROPERTY_TYPE> ite = ls.iterator(); ite.hasNext(); ) {
            final PROPERTY_TYPE element = ite.next();
            if (element == null) {
                continue;
            }
			if (element instanceof String) {
			    if (((String)element).length() == 0) {
				    continue;
				}
			}
            newList.add(element);
        }
        return newList;
    }
	
    public void doNss(NssCall callback) {// Very Internal
        String foreignPropertyName = callback.qf().getForeignPropertyName();
        String foreignTableAliasName = callback.qf().getRealAliasName();
        getSqlClause().registerSelectedSelectColumn(foreignTableAliasName, getTableDbName(), foreignPropertyName, getRelationPath());
        getSqlClause().registerSelectedForeignInfo(callback.qf().getRelationPath(), foreignPropertyName);
    }
    
    public static interface NssCall {// Very Internal
        public ${glConditionQueryInterfaceName} qf();
    }

    // ===================================================================================
    //                                                                      General Helper
    //                                                                      ==============
    protected final String replaceString(String text, String fromText, String toText) {
	    return ${glSimpleStringUtil}.replace(text, fromText, toText);
    }

    protected String initCap(String str) {
	    return ${glSimpleStringUtil}.initCap(str);
    }

    protected String getLineSeparator() {
	    return ${glSimpleSystemUtil}.getLineSeparator();
    }
		
    // -----------------------------------------------------
    //                                         Assert Object
    //                                         -------------
    /**
     * Assert that the object is not null.
     * 
     * @param variableName Variable name. (NotNull)
     * @param value Value. (NotNull)
     * @exception IllegalArgumentException
     */
    protected void assertObjectNotNull(String variableName, Object value) {
        if (variableName == null) {
            String msg = "The value should not be null: variableName=" + variableName + " value=" + value;
            throw new IllegalArgumentException(msg);
        }
        if (value == null) {
            String msg = "The value should not be null: variableName=" + variableName;
            throw new IllegalArgumentException(msg);
        }
    }

    /**
     * Assert that the column-name is not null and is not empty and does not contain comma.
     * 
     * @param columnName Column-name. (NotNull)
     * @exception IllegalArgumentException
     */
    protected void assertColumnName(String columnName) {
        if (columnName == null) {
            String msg = "The columnName should not be null.";
            throw new IllegalArgumentException(msg);
        }
        if (columnName.trim().length() == 0) {
            String msg = "The columnName should not be empty-string.";
            throw new IllegalArgumentException(msg);
        }
        if (columnName.indexOf(",") >= 0) {
            String msg = "The columnName should not contain comma ',': " + columnName;
            throw new IllegalArgumentException(msg);
        }
    }

    /**
     * Assert that the alias-name is not null and is not empty and does not contain comma.
     * 
     * @param aliasName Alias-name. (NotNull)
     * @exception IllegalArgumentException
     */
    protected void assertAliasName(String aliasName) {
        if (aliasName == null) {
            String msg = "The aliasName should not be null.";
            throw new IllegalArgumentException(msg);
        }
        if (aliasName.trim().length() == 0) {
            String msg = "The aliasName should not be empty-string.";
            throw new IllegalArgumentException(msg);
        }
        if (aliasName.indexOf(",") >= 0) {
            String msg = "The aliasName should not contain comma ',': " + aliasName;
            throw new IllegalArgumentException(msg);
        }
    }

    // -----------------------------------------------------
    //                                         Assert String
    //                                         -------------
    /**
     * Assert that the entity is not null and not trimmed empty.
     * 
     * @param variableName Variable name. (NotNull)
     * @param value Value. (NotNull)
     */
    protected void assertStringNotNullAndNotTrimmedEmpty(String variableName, String value) {
        assertObjectNotNull("variableName", variableName);
        assertObjectNotNull("value", value);
        if (value.trim().length() ==0) {
            String msg = "The value should not be empty: variableName=" + variableName + " value=" + value;
            throw new IllegalArgumentException(msg);
        }
    }
	
    // ===================================================================================
    //                                                                      Basic Override
    //                                                                      ==============
	@Override
    public String toString() {
        return getClass().getSimpleName() + ":{aliasName=" + _aliasName + ", nestLevel=" + _nestLevel
		     + ", subQueryLevel=" + _subQueryLevel + ", foreignPropertyName=" + _foreignPropertyName
			 + ", relationPath=" + _relationPath + ", onClauseInline=" + _onClauseInline + "}";
    }
}
