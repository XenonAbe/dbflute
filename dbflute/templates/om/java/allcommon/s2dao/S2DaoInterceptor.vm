${database.allClassCopyright}package ${glPackageBaseCommonS2Dao};

import org.aopalliance.intercept.MethodInvocation;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import ${glPackageBaseCommon}.${glEntityInterfaceName};
import ${glPackageBaseCommonCBean}.${glConditionBeanInterfaceName};
import ${glPackageBaseCommonCBean}.${glConditionBeanContextName};
import ${glPackageBaseCommonCBean}.${glFetchNarrowingBeanContextName};
import ${glPackageBaseCommonCBean}.${glFetchNarrowingBeanInterfaceName};
#if ($database.isAvailableGenerics())
import ${glPackageBaseCommonCBeanOutsidesql}.${glOutsideSqlContextName};
import ${glPackageBaseCommonAnnotation}.${glOutsideSqlAnnotation};
#end


/**
 * My-DaoInterceptor.
 * Customises original class 'S2DaoInterceptor'.
 * 
 * @author ${database.ClassAuthor}
 */
public class ${glDaoInterceptor} extends org.seasar.framework.aop.interceptors.AbstractInterceptor {

    /** Serial version UID. (Default) */
    private static final long serialVersionUID = 1L;

    /** Log-instance. */
    private static final Log _log = LogFactory.getLog(${glDaoInterceptor}.class);

    // ===================================================================================
    //                                                                           Attribute
    //                                                                           =========
    /** Dao meta data factory. */
    private org.seasar.dao.DaoMetaDataFactory daoMetaDataFactory_;

    // ===================================================================================
    //                                                                         Constructor
    //                                                                         ===========
    /**
     * Constructor.
     * 
     * @param daoMetaDataFactory Dao meta data factory.
     */
    public ${glDaoInterceptor}(org.seasar.dao.DaoMetaDataFactory daoMetaDataFactory) {
        daoMetaDataFactory_ = daoMetaDataFactory;
    }

    // ===================================================================================
    //                                                                                Main
    //                                                                                ====
    /**
     * Invoke.
     * 
     * @param invocation Method invocation.
     * @return Result of the method.
     * @throws Throwable
     */
    public Object invoke(MethodInvocation invocation) throws Throwable {
        final java.lang.reflect.Method method = invocation.getMethod();
        if (!org.seasar.framework.util.MethodUtil.isAbstract(method)) {
            return invocation.proceed();
        }
        traceMethod(invocation);
        final long before = System.currentTimeMillis();

        final org.seasar.dao.SqlCommand cmd;
        {
            final long beforeCmd = System.currentTimeMillis();
            final Class targetClass = getTargetClass(invocation);
            final org.seasar.dao.DaoMetaData dmd = daoMetaDataFactory_.getDaoMetaData(targetClass);
            cmd = dmd.getSqlCommand(method.getName());
            final long afterCmd = System.currentTimeMillis();
            traceSqlCommand(invocation, cmd, beforeCmd, afterCmd);
        }

        final ${glConditionBeanInterfaceName} ${glAttachedCBArgsVariableName} = preprocessConditionBean(invocation, cmd);
        Object ret = null;

        try {
            ret = cmd.execute(invocation.getArguments());
        } catch (Exception e) {
            _log.info("Dao threw the exception: " + e.getClass() + " msg=" + e.getMessage());
            _log.info("    method   --> " + invocation.getMethod());
            _log.info("    argument --> " + getObjectArrayString(invocation.getArguments()));
            if (e instanceof org.seasar.framework.exception.SQLRuntimeException) {
                final Throwable causeException = ((org.seasar.framework.exception.SQLRuntimeException)e).getCause();
                if (causeException instanceof org.seasar.framework.exception.SSQLException) {
                    final String sql = ((org.seasar.framework.exception.SSQLException)causeException).getSql();
                    _log.info("    sql      --> " + sql);
                }
            }
            throw e;
        } finally {
            postprocessConditionBean(invocation, ${glAttachedCBArgsVariableName});
        }
        final long after = System.currentTimeMillis();

        final Class retType = method.getReturnType();
        assertRetType(retType, ret);
        traceReturn(invocation, retType, ret, before, after);

        if (retType.isPrimitive()) {
            return org.seasar.framework.util.NumberConversionUtil.convertPrimitiveWrapper(retType, ret);
        } else if (Number.class.isAssignableFrom(retType)) {
            return org.seasar.framework.util.NumberConversionUtil.convertNumber(retType, ret);
        } else {
            return ret;
        }
    }

    // -----------------------------------------------------
    //                                          Trace Method
    //                                          ------------
    protected void traceMethod(MethodInvocation invocation) {
        if (_log.isDebugEnabled()) {
            final java.lang.reflect.Method method = invocation.getMethod();
            final String name = getShortClassName(method.getDeclaringClass());
            final String invokeNameWithoutKakko = removeBasePrefixIfNeeds(name)  + "." + method.getName();
            final String equalBorder = buildFitBorder("", "=", invokeNameWithoutKakko, false);
            final String daoInvokeName = invokeNameWithoutKakko + "()";

            _log.debug("/=====================================================" + equalBorder + "==");
            _log.debug("                                                      " + daoInvokeName);
            _log.debug("                                                      " + equalBorder + "=/");

            tracePath();
        }
    }

    protected void tracePath() {
        final StackTraceElement[] stackTrace = new Exception().getStackTrace();
        final InvokeNameExtractingResult behaviorResult = extractBehaviorInvokeName(stackTrace);
        final InvokeNameExtractingResult clientResult = extractClientInvokeName(stackTrace, behaviorResult.getNextStartIndex());
        final String behaviorInvokeName = behaviorResult.getInvokeName();
        final String clientInvokeName = clientResult.getInvokeName();
        if (clientInvokeName.trim().length() == 0 && behaviorInvokeName.trim().length() == 0) {
            return;
        }
        final String path = clientInvokeName + behaviorInvokeName + "...";
        final String hyphenBorder = buildFitBorder("/", "-", path, true);
        _log.debug(hyphenBorder);
        _log.debug(path);
        _log.debug("- - - - - - - - - -/");
    }

    protected String buildFitBorder(String prefix, String element, String lengthTargetString, boolean space) {
        final int length = space ? lengthTargetString.length() / 2 : lengthTargetString.length();
        final StringBuffer sb = new StringBuffer();
        sb.append(prefix);
        for (int i = 0; i < length; i++) {
            sb.append(element);
            if (space) {
                sb.append(" ");
            }
        }
        if (space) {
            sb.append(element);
        }
        return sb.toString();
    }

    protected InvokeNameExtractingResult extractClientInvokeName(StackTraceElement[] stackTrace, final int startIndex) {
        final InvokeNameExtractingCallback callback = new InvokeNameExtractingCallback() {
            public boolean isTargetElement(String className, String methodName) {
                return className.endsWith("Page") || className.endsWith("Action");
            }
            public String filterSimpleClassName(String simpleClassName) {
                return simpleClassName;
            }
            public boolean isUseAdditionalInfo() {
                return true;
            }
            public int getStartIndex() {
                return startIndex;
            }
        };
        return extractInvokeName(callback, stackTrace);
    }

    protected InvokeNameExtractingResult extractBehaviorInvokeName(StackTraceElement[] stackTrace) {
        final InvokeNameExtractingCallback callback = new InvokeNameExtractingCallback() {
            public boolean isTargetElement(String className, String methodName) {
                return className.endsWith("Bhv") || className.endsWith("BehaviorReadable") || className.endsWith("BehaviorWritable");
            }
            public String filterSimpleClassName(String simpleClassName) {
                return removeBasePrefixIfNeeds(simpleClassName);
            }
            public boolean isUseAdditionalInfo() {
                return false;
            }
            public int getStartIndex() {
                return 0;
            }
        };
        return extractInvokeName(callback, stackTrace);
    }

    protected InvokeNameExtractingResult extractInvokeName(InvokeNameExtractingCallback callback, StackTraceElement[] stackTrace) {
        String targetSimpleClassName = null;
        String targetMethodName = null;
        int lineNumber = 0;
        int foundIndex = 0;
        boolean onTarget = false;
        for (int i=callback.getStartIndex(); i < stackTrace.length; i++) {
            final StackTraceElement element = stackTrace[i];
            if (i >= 20) {
                break;
            }
            final String className = element.getClassName();
            if (className.startsWith("sun.") || className.startsWith("java.")) {
                if (onTarget) {
                    break;
                }
                continue;
            }
            final String methodName = element.getMethodName();
            if (callback.isTargetElement(className, methodName)) {
                if (methodName.equals("invoke")) {
                    continue;
                }
                targetSimpleClassName = className.substring(className.lastIndexOf(".") + 1);
                targetMethodName = methodName;
                if (callback.isUseAdditionalInfo()) {
                    lineNumber = element.getLineNumber();
                }
                foundIndex = i;
                onTarget = true;
                continue;
            }
            if (onTarget) {
                break;
            }
        }
        final InvokeNameExtractingResult result = new InvokeNameExtractingResult();
        if (targetSimpleClassName == null) {
            result.setInvokeName("");
            return result;
        }
        if (lineNumber > 0) {
            result.setInvokeName(callback.filterSimpleClassName(targetSimpleClassName) + "." + targetMethodName + "():" + lineNumber + " --> ");
        } else {
            result.setInvokeName(callback.filterSimpleClassName(targetSimpleClassName) + "." + targetMethodName + "() --> ");
        }
        result.setFoundIndex(foundIndex);
        return result;
    }

    protected static interface InvokeNameExtractingCallback {
        public boolean isTargetElement(String className, String methodName);
        public String filterSimpleClassName(String simpleClassName);
        public boolean isUseAdditionalInfo();
        public int getStartIndex();
    }

    protected static class InvokeNameExtractingResult {
        protected String _invokeName;
        protected int _foundIndex;

        public int getNextStartIndex() {
            return _foundIndex + 1;
        }

        public String getInvokeName() {
            return _invokeName;
        }
        public void setInvokeName(String invokeName) {
            this._invokeName = invokeName;
        }
        public int getFoundIndex() {
            return _foundIndex;
        }
        public void setFoundIndex(int foundIndex) {
            this._foundIndex = foundIndex;
        }
    }

    protected String removeBasePrefixIfNeeds(String name) {
        if (!name.startsWith("${glProjectPrefix}${glBasePrefix}")) {
            return name;
        }
        final int prefixLength = "${glProjectPrefix}${glBasePrefix}".length();
        if (!Character.isUpperCase(name.substring(prefixLength).charAt(0))) {
            return name;
        }
        if (name.length() <= prefixLength) {
            return name;
        }
        return "${glProjectPrefix}" + name.substring(prefixLength);
    }

    // -----------------------------------------------------
    //                                      Trace SqlCommand
    //                                      ----------------
    protected void traceSqlCommand(MethodInvocation invocation, org.seasar.dao.SqlCommand cmd, long beforeCmd, long afterCmd) {
        if (_log.isDebugEnabled()) {
            _log.debug("SqlCommand Initialization Cost: [" + getPerformanceView(afterCmd - beforeCmd) + "]");
        }
    }

    protected void assertRetType(Class retType, Object ret) {
        if (java.util.List.class.isAssignableFrom(retType)) {
            if (ret != null && !(ret instanceof java.util.List)) {
                String msg = "The retType is difference from actual return: ";
                msg = msg + "retType=" + retType + " ret.getClass()=" + ret.getClass() + " ref=" + ret;
                throw new IllegalStateException(msg);
            }
        } else if (${glEntityInterfaceName}.class.isAssignableFrom(retType)) {
            if (ret != null && !(ret instanceof ${glEntityInterfaceName})) {
                String msg = "The retType is difference from actual return: ";
                msg = msg + "retType=" + retType + " ret.getClass()=" + ret.getClass() + " ref=" + ret;
                throw new IllegalStateException(msg);
            }
        }
    }

    // -----------------------------------------------------
    //                                          Trace Return
    //                                          ------------
    protected void traceReturn(MethodInvocation invocation, Class retType, Object ret, long before, long after)
            throws Throwable {
        if (_log.isDebugEnabled()) {
            try {
                final String daoResultPrefix = "===========/ [" + getPerformanceView(after - before) + " - ";
                if (java.util.List.class.isAssignableFrom(retType)) {
                    if (ret == null) {
                        _log.debug(daoResultPrefix + "Selected count: null]");
                    } else {
                        final java.util.List ls = (java.util.List) ret;
                        if (ls.isEmpty()) {
                            _log.debug(daoResultPrefix + "Selected count: 0]");
                        } else {
                            _log.debug(daoResultPrefix + "Selected count: " + ls.size() + " first=" + ls.get(0) + "]");
                        }
                    }
                } else if (${glEntityInterfaceName}.class.isAssignableFrom(retType)) {
                    if (ret == null) {
                        _log.debug(daoResultPrefix + "Selected entity: null" + "]");
                    } else {
                        final ${glEntityInterfaceName} entity = (${glEntityInterfaceName}) ret;
                        _log.debug(daoResultPrefix + "Selected entity: " + entity + "]");
                    }
                } else {
                    if (isSelectCountIgnoreFetchScopeMethod(invocation)) {
                        _log.debug(daoResultPrefix + "Selected count: " + ret + "]");
                    } else {
                        _log.debug(daoResultPrefix + "Result: " + ret + "]");
                    }
                }
                _log.debug(" ");
            } catch (Exception e) {
                String msg = "Result object debug threw the exception: methodName=";
                msg = msg + invocation.getMethod().getName() + " retType=" + retType;
                msg = msg + " ret=" + ret;
                _log.warn(msg, e);
                throw e;
            }
        }
    }

    // ===================================================================================
    //                                                                    Pre Post Process
    //                                                                    ================
    /**
     * Preprocess condition-bean.
     * <p>
     * If this method is condition bean select target, make dynamic sql.
     * Else nothing.
     * 
     * @param invocation Method invocation. (NotNull)
     * @param cmd Sql command. (NotNull)
     * @return Condition-bean. (Nullable)
     */
    protected ${glConditionBeanInterfaceName} preprocessConditionBean(MethodInvocation invocation, org.seasar.dao.SqlCommand cmd) {
        clearThreadLocal();

#if ($database.isAvailableGenerics())
        final OutsideSql outsideSql = invocation.getMethod().getAnnotation(OutsideSql.class);
        if (outsideSql != null && outsideSql.dynamicAnalysis()) {
            final ${glOutsideSqlContextName} outsideSqlContext = new ${glOutsideSqlContextName}();
            outsideSqlContext.setDynamicAnalysis(true);
            ${glOutsideSqlContextName}.setOutsideSqlContextOnThread(outsideSqlContext);
        }
#end

        final ${glConditionBeanInterfaceName} ${glAttachedCBArgsVariableName};
        {
            final Object[] args = invocation.getArguments();
            if (args == null || !(args.length >= 1)) {
                return null;
            }

            final Object arg0 = args[0];
            if (arg0 == null) {
                return null;
            }

            if (!${glConditionBeanContextName}.isTheTypeConditionBean(arg0.getClass())) {// The argument is not condition-bean...
                if (${glFetchNarrowingBeanContextName}.isTheTypeFetchNarrowingBean(arg0.getClass()) && !isSelectCountIgnoreFetchScopeMethod(invocation)) {
                    // Fetch-narrowing-bean and Not select count!
                    ${glFetchNarrowingBeanContextName}.setFetchNarrowingBeanOnThread((${glFetchNarrowingBeanInterfaceName})arg0);
                }
                return null;
            }

            ${glAttachedCBArgsVariableName} = (${glConditionBeanInterfaceName})arg0;
        }

        if (!(cmd instanceof ${glSelectDynamicCommand})) {// The argument is condition-bean, but this method use outer-sql-file...
            ${glFetchNarrowingBeanContextName}.setFetchNarrowingBeanOnThread(${glAttachedCBArgsVariableName});
            return null;
        }

        if (isSelectCountIgnoreFetchScopeMethod(invocation)) {
            ${glAttachedCBArgsVariableName}.xsetupSelectCountIgnoreFetchScope();
        } else {
            ${glFetchNarrowingBeanContextName}.setFetchNarrowingBeanOnThread(cb);
        }

        ${glConditionBeanContextName}.setConditionBeanOnThread(cb);
        return ${glAttachedCBArgsVariableName};
    }

    /**
     * Postprocess condition-bean.
     * 
     * @param invocation Method invocation. (NotNull)
     * @param ${glAttachedCBArgsVariableName} Condition-bean. (Nullable)
     */
    public void postprocessConditionBean(MethodInvocation invocation, ${glConditionBeanInterfaceName} ${glAttachedCBArgsVariableName}) {
        clearThreadLocal();

        if (${glAttachedCBArgsVariableName} != null && isSelectCountIgnoreFetchScopeMethod(invocation)) {
            ${glAttachedCBArgsVariableName}.xafterCareSelectCountIgnoreFetchScope();
        }
    }

    protected void clearThreadLocal() {
#if ($database.isAvailableGenerics())
        if (${glOutsideSqlContextName}.isExistOutsideSqlContextOnThread()) {
            ${glOutsideSqlContextName}.clearOutsideSqlContextOnThread();
        }
#end
        if (${glFetchNarrowingBeanContextName}.isExistFetchNarrowingBeanOnThread()) {
            ${glFetchNarrowingBeanContextName}.clearFetchNarrowingBeanOnThread();
        }
        if (${glConditionBeanContextName}.isExistConditionBeanOnThread()) {
            ${glConditionBeanContextName}.clearConditionBeanOnThread();
        }
    }

    // ===================================================================================
    //                                                                       Determination
    //                                                                       =============
    /**
     * Is select count ignore-fetch-scope method?
     * 
     * @param invocation Method invocation. (NotNull)
     * @return Determination.
     */
    protected boolean isSelectCountIgnoreFetchScopeMethod(MethodInvocation invocation) {
        final String name = invocation.getMethod().getName();
        if (name.startsWith("readCount")
                || name.startsWith("selectCount")
                || name.startsWith("readCountIgnoreFetchScope")
                || name.startsWith("selectCountIgnoreFetchScope")) {
            return true;
        } else {
            return false;
        }
    }

    // ===================================================================================
    //                                                                              Helper
    //                                                                              ======
    /**
     * Get short class name.
     * 
     * @param clazz Class instance. (NotNull)
     * @return Short class name. (NotNull)
     */
    protected String getShortClassName(Class clazz) {
        String s = clazz.getName();
        int i = s.lastIndexOf('.');
        if (i > 0) {
            return s.substring(i + 1);
        }
        return s;
    }

    /**
     * Change object array to string divided with comma.
     * 
     * @param objArray Object array. (Nullable)
     * @return String (NotNull: If the argument is null, returns empty string.)
     */
    protected String getObjectArrayString(Object[] objArray) {
        if (objArray == null) {
            return "";
        }
        final StringBuffer sb = new StringBuffer();
        for (int i = 0; i < objArray.length; i++) {
            if (i == 0) {
                sb.append(objArray[i]);
            } else {
                sb.append(", ").append(objArray[i]);
            }
        }
        return sb.toString();
    }

    /**
     * Get performance view.
     * 
     * @param mil The value of millisecound.
     * @return Performance view. (ex. 1m23s456ms) (NotNull)
     */
    protected String getPerformanceView(long mil) {
        if (mil < 0) {
            return String.valueOf(mil);
        }

        long sec = mil / 1000;
        long min = sec / 60;
        sec = sec % 60;
        mil = mil % 1000;

        StringBuffer sb = new StringBuffer();
        if (min >= 10) { // Minute
            sb.append(min).append("m");
        } else if (min < 10 && min >= 0) {
            sb.append("0").append(min).append("m");
        }
        if (sec >= 10) { // Second
            sb.append(sec).append("s");
        } else if (sec < 10 && sec >= 0) {
            sb.append("0").append(sec).append("s");
        }
        if (mil >= 100) { // Millisecond
            sb.append(mil).append("ms");
        } else if (mil < 100 && mil >= 10) {
            sb.append("0").append(mil).append("ms");
        } else if (mil < 10 && mil >= 0) {
            sb.append("00").append(mil).append("ms");
        }

        return sb.toString();
    }
}