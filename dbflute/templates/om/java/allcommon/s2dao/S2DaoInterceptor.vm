${database.allClassCopyright}package ${glPackageBaseCommonS2Dao};

import java.util.Arrays;
import java.util.List;

import org.aopalliance.intercept.MethodInvocation;
import org.seasar.dao.DaoMetaData;
import org.seasar.dao.DaoMetaDataFactory;
import org.seasar.dao.SqlCommand;

import ${glPackageBaseCommon}.${glEntityInterfaceName};
import ${glPackageBaseCommonCBean}.${glConditionBeanInterfaceName};
import ${glPackageBaseCommonCBean}.${glConditionBeanContextName};
import ${glPackageBaseCommonCBean}.${glFetchNarrowingBeanContextName};
import ${glPackageBaseCommonCBean}.${glFetchNarrowingBeanInterfaceName};
import ${glPackageBaseCommonCBeanOutsidesql}.${glOutsideSqlContextName};
import ${glPackageBaseCommonCBeanOutsidesql}.${glOutsideSqlDaoName};
import ${glPackageBaseCommonCBeanOutsidesql}.${glOutsideSqlOptionName};
import ${glPackageBaseCommonUtil}.${glTraceViewUtilName};

/**
 * My-DaoInterceptor.
 * Customises original class 'S2DaoInterceptor'.
 * 
 * @author ${database.ClassAuthor}
 */
public class ${glDaoInterceptor} extends org.seasar.framework.aop.interceptors.AbstractInterceptor {

    /** Serial version UID. (Default) */
    private static final long serialVersionUID = 1L;

    /** Log instance. */
    private static final org.apache.commons.logging.Log _log = org.apache.commons.logging.LogFactory.getLog(${glDaoInterceptor}.class);

    // ===================================================================================
    //                                                                           Attribute
    //                                                                           =========
    /** The factory of dao meta data. */
    private DaoMetaDataFactory daoMetaDataFactory_;

    // ===================================================================================
    //                                                                         Constructor
    //                                                                         ===========
    /**
     * Constructor.
     * 
     * @param daoMetaDataFactory The factory of dao meta data. (NotNull)
     */
    public ${glDaoInterceptor}(DaoMetaDataFactory daoMetaDataFactory) {
        daoMetaDataFactory_ = daoMetaDataFactory;
    }

    // ===================================================================================
    //                                                                              Invoke
    //                                                                              ======
    /**
     * Invoke the method.
     * 
     * @param invocation The methodinvocation. (NotNull)
     * @return The result of the method. (Nullable)
     * @throws Throwable
     */
    public Object invoke(MethodInvocation invocation) throws Throwable {
        clearThreadLocal();
        try {
            return dispatchInvoking(invocation);
        } finally {
            clearThreadLocal();
        }
    }

    /**
     * Dispatch invoking the method.
     * 
     * @param invocation The methodinvocation. (NotNull)
     * @return The result of the method. (Nullable)
     * @throws Throwable
     */
    protected Object dispatchInvoking(MethodInvocation invocation) throws Throwable {
        final java.lang.reflect.Method method = invocation.getMethod();
        if (!org.seasar.framework.util.MethodUtil.isAbstract(method)) {
            return invocation.proceed();
        }

        if (_log.isDebugEnabled()) {
            traceMethod(invocation);
        }

        long before = 0;
        if (_log.isDebugEnabled()) {
            before = System.currentTimeMillis();
        }

        // - - - - - - - - - - -
        // Preprocess outsideSql
        // - - - - - - - - - - -
        preprocessOutsideSql(invocation);

        // - - - - - - - - -
        // Set up sqlCommand
        // - - - - - - - - -
        final SqlCommand cmd;
        {
            long beforeCmd = 0;
            if (_log.isDebugEnabled()) {
                beforeCmd = System.currentTimeMillis();
            }
            cmd = findSqlCommand(invocation);
            if (_log.isDebugEnabled()) {
                final long afterCmd = System.currentTimeMillis();
                if (beforeCmd != afterCmd) {
                    traceSqlCommand(invocation, cmd, beforeCmd, afterCmd);
                }
            }
        }

        // - - - - - - - - - - - - -
        // Preprocess conditionBean
        // - - - - - - - - - - - - -
        final ${glConditionBeanInterfaceName} cb = preprocessConditionBean(invocation, cmd);

        // - - - - - - - - - -
        // Execute sqlCommand!
        // - - - - - - - - - -
        Object ret = null;
        try {
            ret = cmd.execute(invocation.getArguments());
        } catch (org.seasar.dao.NotSingleRowUpdatedRuntimeException notSingleRow) {
            throw new ${glPackageBaseCommonException}.${glEntityAlreadyUpdatedException}(notSingleRow);
        } catch (Exception e) {
            if (_log.isDebugEnabled()) {
                final Class<?> targetType = getTargetClass(invocation);
                final StringBuilder sb = new StringBuilder();
                sb.append(targetType.getSimpleName() + " was interrupted by " + e.getClass().getSimpleName()).append(getLineSeparator());
                sb.append("[Interrupted Target]").append(getLineSeparator());
                sb.append("  dao    = " + targetType.getSimpleName()).append(getLineSeparator());
                sb.append("  method = " + invocation.getMethod()).append(getLineSeparator());
                sb.append("  args   = " + ${glTraceViewUtilName}.convertObjectArrayToStringView(invocation.getArguments()));
                _log.debug(sb);
            }
            throw e;
        } finally {
            postprocessConditionBean(invocation, cb);
        }
        final Class<?> retType = method.getReturnType();
        assertRetType(retType, ret);

        if (_log.isDebugEnabled()) {
            final long after = System.currentTimeMillis();
            traceReturn(invocation, retType, ret, before, after);
        }

        // - - - - - - - - - -
        // Convert and Return!
        // - - - - - - - - - -
        if (retType.isPrimitive()) {
            return org.seasar.framework.util.NumberConversionUtil.convertPrimitiveWrapper(retType, ret);
        } else if (Number.class.isAssignableFrom(retType)) {
            return org.seasar.framework.util.NumberConversionUtil.convertNumber(retType, ret);
        } else {
            return ret;
        }
    }

    // ===================================================================================
    //                                                                          SqlCommand
    //                                                                          ==========
    protected SqlCommand findSqlCommand(MethodInvocation invocation) {
        final SqlCommand cmd;
        final Class<?> targetType = getTargetClass(invocation);
        final DaoMetaData dmd = daoMetaDataFactory_.getDaoMetaData(targetType);
        if (${glOutsideSqlDaoName}.class.isAssignableFrom(targetType)) {
            cmd = dmd.getSqlCommand(generateSpecifiedOutsideSqlUniqueKey(invocation));
        } else {
            cmd = dmd.getSqlCommand(invocation.getMethod().getName());
        }
        return cmd;
    }

    protected String generateSpecifiedOutsideSqlUniqueKey(MethodInvocation invocation) {
        final Object[] args = invocation.getArguments();
        final String path = (String)args[0];
        final ${glOutsideSqlOptionName} option = (${glOutsideSqlOptionName})args[2];
        Object resultTypeSpecification = null;
        if (args.length > 3) {
            resultTypeSpecification = args[3];
        }
        return ${glOutsideSqlContextName}.generateSpecifiedOutsideSqlUniqueKey(invocation.getMethod().getName(), path, option, resultTypeSpecification);
    }

    // ===================================================================================
    //                                                                        Trace Method
    //                                                                        ============
    protected void traceMethod(org.aopalliance.intercept.MethodInvocation invocation) {
        final java.lang.reflect.Method method = invocation.getMethod();
        final String name = method.getDeclaringClass().getSimpleName();
        final String invokeNameWithoutKakko = removeBasePrefixIfNeeds(name)  + "." + method.getName();
        final String equalBorder = buildFitBorder("", "=", invokeNameWithoutKakko, false);
        final String daoInvokeName = invokeNameWithoutKakko + "()";

        _log.debug("/=====================================================" + equalBorder + "==");
        _log.debug("                                                      " + daoInvokeName);
        _log.debug("                                                      " + equalBorder + "=/");

        tracePath();

        // Specified OutsideSql
        if (${glOutsideSqlDaoName}.class.isAssignableFrom(getTargetClass(invocation))) {
            Object[] args = invocation.getArguments();
            if (args != null && args.length != 0 && args[0] instanceof String) {
                _log.debug("OutsideSql: " + args[0]);
            }
        }
    }

    protected void tracePath() {
        final StackTraceElement[] stackTrace = new Exception().getStackTrace();
        final InvokeNameExtractingResult behaviorResult = extractBehaviorInvokeName(stackTrace);
        final int bhvNextIndex = behaviorResult.getNextStartIndex();
        final InvokeNameExtractingResult clientResult = extractClientInvokeName(stackTrace, bhvNextIndex);
        final int clientFirstIndex = clientResult.getFoundFirstIndex();
        final InvokeNameExtractingResult byPassResult = extractByPassInvokeName(stackTrace, bhvNextIndex, clientFirstIndex - bhvNextIndex);

        final String clientInvokeName = clientResult.getInvokeName();
        final String byPassInvokeName = byPassResult.getInvokeName();
        final String behaviorInvokeName = behaviorResult.getInvokeName();
        if (clientInvokeName.trim().length() == 0 && byPassInvokeName.trim().length() == 0 && behaviorInvokeName.trim().length() == 0) {
            return;
        }
        final String path = clientInvokeName + byPassInvokeName + behaviorInvokeName + "...";
        // *I will delete this at the future.
        // final String hyphenBorder = buildFitBorder("/", "-", path, true);
        // _log.debug(hyphenBorder);
        _log.debug(path);
        // _log.debug("- - - - - - - - - -/");
    }

    protected String buildFitBorder(String prefix, String element, String lengthTargetString, boolean space) {
        final int length = space ? lengthTargetString.length() / 2 : lengthTargetString.length();
        final StringBuffer sb = new StringBuffer();
        sb.append(prefix);
        for (int i = 0; i < length; i++) {
            sb.append(element);
            if (space) {
                sb.append(" ");
            }
        }
        if (space) {
            sb.append(element);
        }
        return sb.toString();
    }

    protected InvokeNameExtractingResult extractClientInvokeName(StackTraceElement[] stackTrace, final int startIndex) {
        final List<String> suffixList = Arrays.asList(new String[]{"Page", "Action"});
        final InvokeNameExtractingCallback callback = new InvokeNameExtractingCallback() {
            public boolean isTargetElement(String className, String methodName) {
                return isClassNameEndsWith(className, suffixList);
            }
            public String filterSimpleClassName(String simpleClassName) {
                return simpleClassName;
            }
            public boolean isUseAdditionalInfo() {
                return true;
            }
            public int getStartIndex() {
                return startIndex;
            }
            public int getLoopSize() {
                return 25;
            }
        };
        return extractInvokeName(callback, stackTrace);
    }

    protected InvokeNameExtractingResult extractByPassInvokeName(StackTraceElement[] stackTrace, final int startIndex, final int loopSize) {
        final List<String> suffixList = Arrays.asList(new String[]{"Service", "ServiceImpl", "Facade", "FacadeImpl"});
        final InvokeNameExtractingCallback callback = new InvokeNameExtractingCallback() {
            public boolean isTargetElement(String className, String methodName) {
                return isClassNameEndsWith(className, suffixList);
            }
            public String filterSimpleClassName(String simpleClassName) {
                return simpleClassName;
            }
            public boolean isUseAdditionalInfo() {
                return true;
            }
            public int getStartIndex() {
                return startIndex;
            }
            public int getLoopSize() {
                return loopSize >= 0 ? loopSize : 25;
            }
        };
        return extractInvokeName(callback, stackTrace);
    }

    protected InvokeNameExtractingResult extractBehaviorInvokeName(StackTraceElement[] stackTrace) {
        final List<String> suffixList = Arrays.asList(new String[]{"Bhv", "Bhv$", "BehaviorReadable", "BehaviorWritable"});
        final InvokeNameExtractingCallback callback = new InvokeNameExtractingCallback() {
            public boolean isTargetElement(String className, String methodName) {
                return isClassNameEndsWith(className, suffixList);
            }
            public String filterSimpleClassName(String simpleClassName) {
                return removeBasePrefixIfNeeds(simpleClassName);
            }
            public boolean isUseAdditionalInfo() {
                return false;
            }
            public int getStartIndex() {
                return 0;
            }
            public int getLoopSize() {
                return 25;
            }
        };
        return extractInvokeName(callback, stackTrace);
    }

    protected boolean isClassNameEndsWith(String className, List<String> suffixList) {
        for (String suffix : suffixList) {
            if (className.endsWith(suffix)) {
                return true;
            }
        }
        return false;
    }

    /**
     * @param callback Callback. (NotNull)
     * @param stackTrace Stack trace. (NotNull)
     * @return Invoke name. (NotNull: If not found, returns empty string.)
     */
    protected InvokeNameExtractingResult extractInvokeName(InvokeNameExtractingCallback callback, StackTraceElement[] stackTrace) {
        String targetSimpleClassName = null;
        String targetMethodName = null;
        int lineNumber = 0;
        int foundIndex = -1;// The minus one means 'not found'.
        int foundFirstIndex = -1;// The minus one means 'not found'.
        boolean onTarget = false;
        for (int i=callback.getStartIndex(); i < stackTrace.length; i++) {
            final StackTraceElement element = stackTrace[i];
            if (i > callback.getStartIndex() + callback.getLoopSize()) {
                break;
            }
            final String className = element.getClassName();
            if (className.startsWith("sun.") || className.startsWith("java.")) {
                if (onTarget) {
                    break;
                }
                continue;
            }
            final String methodName = element.getMethodName();
            if (callback.isTargetElement(className, methodName)) {
                if (methodName.equals("invoke")) {
                    continue;
                }
                targetSimpleClassName = className.substring(className.lastIndexOf(".") + 1);
                targetMethodName = methodName;
                if (callback.isUseAdditionalInfo()) {
                    lineNumber = element.getLineNumber();
                }
                foundIndex = i;
                if (foundFirstIndex == -1) {
                    foundFirstIndex = i;
                }
                onTarget = true;
                continue;
            }
            if (onTarget) {
                break;
            }
        }
        final InvokeNameExtractingResult result = new InvokeNameExtractingResult();
        if (targetSimpleClassName == null) {
            result.setInvokeName("");
            return result;
        }
        if (lineNumber > 0) {
            result.setInvokeName(callback.filterSimpleClassName(targetSimpleClassName) + "." + targetMethodName + "():" + lineNumber + " --> ");
        } else {
            result.setInvokeName(callback.filterSimpleClassName(targetSimpleClassName) + "." + targetMethodName + "() --> ");
        }
        result.setFoundIndex(foundIndex);
        result.setFoundFirstIndex(foundFirstIndex);
        return result;
    }

    protected static interface InvokeNameExtractingCallback {
        public boolean isTargetElement(String className, String methodName);
        public String filterSimpleClassName(String simpleClassName);
        public boolean isUseAdditionalInfo();
        public int getStartIndex();
        public int getLoopSize();
    }

    protected static class InvokeNameExtractingResult {
        protected String _invokeName;
        protected int _foundIndex;
        protected int _foundFirstIndex;

        public int getNextStartIndex() {
            return _foundIndex + 1;
        }

        public String getInvokeName() {
            return _invokeName;
        }
        public void setInvokeName(String invokeName) {
            this._invokeName = invokeName;
        }
        public int getFoundIndex() {
            return _foundIndex;
        }
        public void setFoundIndex(int foundIndex) {
            this._foundIndex = foundIndex;
        }
        public int getFoundFirstIndex() {
            return _foundFirstIndex;
        }
        public void setFoundFirstIndex(int foundFirstIndex) {
            this._foundFirstIndex = foundFirstIndex;
        }
    }

    protected String removeBasePrefixIfNeeds(String name) {
        if (!name.startsWith("${glProjectPrefix}${glBasePrefix}")) {
            return name;
        }
        final int prefixLength = "${glProjectPrefix}${glBasePrefix}".length();
        if (!Character.isUpperCase(name.substring(prefixLength).charAt(0))) {
            return name;
        }
        if (name.length() <= prefixLength) {
            return name;
        }
        return "${glProjectPrefix}" + name.substring(prefixLength);
    }

    // ===================================================================================
    //                                                                    Trace SqlCommand
    //                                                                    ================
    protected void traceSqlCommand(org.aopalliance.intercept.MethodInvocation invocation, org.seasar.dao.SqlCommand cmd, long beforeCmd, long afterCmd) {
        _log.debug("SqlCommand Initialization Cost: [" + ${glTraceViewUtilName}.convertToPerformanceView(afterCmd - beforeCmd) + "]");
    }

    protected void assertRetType(Class retType, Object ret) {
        if (java.util.List.class.isAssignableFrom(retType)) {
            if (ret != null && !(ret instanceof java.util.List)) {
                String msg = "The retType is difference from actual return: ";
                msg = msg + "retType=" + retType + " ret.getClass()=" + ret.getClass() + " ref=" + ret;
                throw new IllegalStateException(msg);
            }
        } else if (${glEntityInterfaceName}.class.isAssignableFrom(retType)) {
            if (ret != null && !(ret instanceof ${glEntityInterfaceName})) {
                String msg = "The retType is difference from actual return: ";
                msg = msg + "retType=" + retType + " ret.getClass()=" + ret.getClass() + " ref=" + ret;
                throw new IllegalStateException(msg);
            }
        }
    }

    // ===================================================================================
    //                                                                        Trace Return
    //                                                                        ============
    protected void traceReturn(org.aopalliance.intercept.MethodInvocation invocation, Class retType, Object ret, long before, long after) throws Throwable {
        try {
            final String daoResultPrefix = "===========/ [" + ${glTraceViewUtilName}.convertToPerformanceView(after - before) + " - ";
            if (java.util.List.class.isAssignableFrom(retType)) {
                if (ret == null) {
                    _log.debug(daoResultPrefix + "Selected list: null]");
                } else {
                    final java.util.List ls = (java.util.List) ret;
                    if (ls.isEmpty()) {
                        _log.debug(daoResultPrefix + "Selected list: 0]");
                    } else if (ls.size() == 1 && ls.get(0) instanceof Number) {
                        _log.debug(daoResultPrefix + "Selected count: " + ls.get(0) + "]");
                    } else {
                        _log.debug(daoResultPrefix + "Selected list: " + ls.size() + " first=" + ls.get(0) + "]");
                    }
                }
            } else if (${glEntityInterfaceName}.class.isAssignableFrom(retType)) {
                if (ret == null) {
                    _log.debug(daoResultPrefix + "Selected entity: null" + "]");
                } else {
                    final ${glEntityInterfaceName} entity = (${glEntityInterfaceName}) ret;
                    _log.debug(daoResultPrefix + "Selected entity: " + entity + "]");
                }
            } else {
                if (isSelectCountIgnoreFetchScopeMethod(invocation)) {
                    _log.debug(daoResultPrefix + "Selected count: " + ret + "]");
                } else {
                    _log.debug(daoResultPrefix + "Result: " + ret + "]");
                }
            }
            _log.debug(" ");
        } catch (Exception e) {
            String msg = "Result object debug threw the exception: methodName=";
            msg = msg + invocation.getMethod().getName() + " retType=" + retType;
            msg = msg + " ret=" + ret;
            _log.warn(msg, e);
            throw e;
        }
    }

    // ===================================================================================
    //                                                                    Pre Post Process
    //                                                                    ================
    // -----------------------------------------------------
    //                                            OutsideSql
    //                                            ----------
    protected void preprocessOutsideSql(MethodInvocation invocation) {
        final Class<${glPackageBaseCommonAnnotation}.${glOutsideSqlAnnotation}> outsideSqlType = ${glPackageBaseCommonAnnotation}.${glOutsideSqlAnnotation}.class;
        final ${glPackageBaseCommonAnnotation}.${glOutsideSqlAnnotation} outsideSql = invocation.getMethod().getAnnotation(outsideSqlType);

        // Traditional OutsideSql
        if (outsideSql != null && (outsideSql.dynamicBinding() || outsideSql.offsetByCursor() || outsideSql.offsetByCursor() || outsideSql.limitByCursor())) {
            final ${glOutsideSqlContextName} outsideSqlContext = new ${glOutsideSqlContextName}();
            outsideSqlContext.setDynamicBinding(outsideSql.dynamicBinding());
            outsideSqlContext.setOffsetByCursorForcedly(outsideSql.offsetByCursor());
            outsideSqlContext.setLimitByCursorForcedly(outsideSql.limitByCursor());
            ${glOutsideSqlContextName}.setOutsideSqlContextOnThread(outsideSqlContext);

            // Set up fetchNarrowingBean.
            final Object[] args = invocation.getArguments();
            if (args == null || args.length == 0) {
                return;
            }
            if (${glFetchNarrowingBeanContextName}.isTheTypeFetchNarrowingBean(args[0].getClass())) {
                ${glFetchNarrowingBeanContextName}.setFetchNarrowingBeanOnThread((${glFetchNarrowingBeanInterfaceName})args[0]);
            }
            return;
        }

        // Specified OutsideSql
        if (${glOutsideSqlDaoName}.class.isAssignableFrom(getTargetClass(invocation))) {
            if (isOutsideSqlDaoMethodSelect(invocation)) {
                setupOutsideSqlContextSelect(invocation);
            } else {
                setupOutsideSqlContextExecute(invocation);
            }
            return;
        }
    }

    // - - - - - - - - - - - -
    //                  Select
    //                   - - -
    protected boolean isOutsideSqlDaoMethodSelect(MethodInvocation invocation) {
        return invocation.getMethod().getName().startsWith("select");
    }

    protected void setupOutsideSqlContextSelect(MethodInvocation invocation) {
        final Object[] args = invocation.getArguments();
        if (args.length != 4) {
            String msg = "Internal Error! OutsideSqlDao.selectXxx() should have 4 arguements: args.length=" + args.length;
            throw new IllegalStateException(msg);
        }
        final String path = (String)args[0];
        final Object pmb = args[1];
        final ${glOutsideSqlOptionName} option = (${glOutsideSqlOptionName})args[2];
        final Object resultTypeSpecification = args[3];
        final ${glOutsideSqlContextName} outsideSqlContext = new ${glOutsideSqlContextName}();
        outsideSqlContext.setDynamicBinding(option.isDynamicBinding());
        outsideSqlContext.setOffsetByCursorForcedly(option.isAutoPaging());
        outsideSqlContext.setLimitByCursorForcedly(option.isAutoPaging());
        outsideSqlContext.setOutsideSqlPath(path);
        outsideSqlContext.setParameterBean(pmb);
        outsideSqlContext.setResultTypeSpecification(resultTypeSpecification);
        outsideSqlContext.setMethodName(invocation.getMethod().getName());
        ${glOutsideSqlContextName}.setOutsideSqlContextOnThread(outsideSqlContext);

        // Set up fetchNarrowingBean.
        setupOutsideSqlFetchNarrowingBean(pmb, option);
    }

    // - - - - - - - - - - - -
    //                 Execute
    //                 - - - -
    protected void setupOutsideSqlContextExecute(MethodInvocation invocation) {
        final Object[] args = invocation.getArguments();
        if (args.length != 3) {
            String msg = "Internal Error! OutsideSqlDao.execute() should have 3 arguements: args.length=" + args.length;
            throw new IllegalStateException(msg);
        }
        final String path = (String)args[0];
        final Object pmb = args[1];
        final ${glOutsideSqlOptionName} option = (${glOutsideSqlOptionName})args[2];
        final ${glOutsideSqlContextName} outsideSqlContext = new ${glOutsideSqlContextName}();
        outsideSqlContext.setDynamicBinding(option.isDynamicBinding());
        outsideSqlContext.setOffsetByCursorForcedly(option.isAutoPaging());
        outsideSqlContext.setLimitByCursorForcedly(option.isAutoPaging());
        outsideSqlContext.setOutsideSqlPath(path);
        outsideSqlContext.setParameterBean(pmb);
        outsideSqlContext.setMethodName(invocation.getMethod().getName());
        ${glOutsideSqlContextName}.setOutsideSqlContextOnThread(outsideSqlContext);

        // Set up fetchNarrowingBean.
        setupOutsideSqlFetchNarrowingBean(pmb, option);
    }

    // - - - - - - - - - - - -
    //                  Common
    //                   - - -
    protected void setupOutsideSqlFetchNarrowingBean(Object pmb, ${glOutsideSqlOptionName} option) {
        if (pmb == null || !${glFetchNarrowingBeanContextName}.isTheTypeFetchNarrowingBean(pmb.getClass())) {
            return;
        }
        final ${glFetchNarrowingBeanInterfaceName} fetchNarrowingBean = (${glFetchNarrowingBeanInterfaceName})pmb;
        if (option.isManualPaging()) {
            fetchNarrowingBean.ignoreFetchNarrowing();
        }
        ${glFetchNarrowingBeanContextName}.setFetchNarrowingBeanOnThread(fetchNarrowingBean);
    }

    // -----------------------------------------------------
    //                                         ConditionBean
    //                                         -------------
    /**
     * Preprocess conditionBean.
     * <p>
     * If this method is condition bean select target, make dynamic SQL.
     * Else nothing.
     * 
     * @param invocation Method invocation. (NotNull)
     * @param cmd SqlCommand. (NotNull)
     * @return ConditionBean. (Nullable)
     */
    protected ${glConditionBeanInterfaceName} preprocessConditionBean(org.aopalliance.intercept.MethodInvocation invocation, org.seasar.dao.SqlCommand cmd) {
        final ${glOutsideSqlContextName} outsideSqlContext = getOutsideSqlContext();
        if (outsideSqlContext != null) {
            return null; // Because it has already finished setting up fetchNarrowingBean for outsideSql here.
        }
        final ${glConditionBeanInterfaceName} cb;
        {
            final Object[] args = invocation.getArguments();
            if (args == null || args.length == 0) {
                return null;
            }
            final Object arg0 = args[0];
            if (arg0 == null) {
                return null;
            }
            if (!${glConditionBeanContextName}.isTheTypeConditionBean(arg0.getClass())) {// The argument is not condition-bean...
                if (${glFetchNarrowingBeanContextName}.isTheTypeFetchNarrowingBean(arg0.getClass()) && !isSelectCountIgnoreFetchScopeMethod(invocation)) {
                    // Fetch-narrowing-bean and Not select count!
                    ${glFetchNarrowingBeanContextName}.setFetchNarrowingBeanOnThread((${glFetchNarrowingBeanInterfaceName})arg0);
                }
                return null;
            }
            cb = (${glConditionBeanInterfaceName})arg0;
        }

        if (!(cmd instanceof ${glSelectDynamicCommand})) {// The argument is condition-bean, but this method use outer-sql-file...
            ${glFetchNarrowingBeanContextName}.setFetchNarrowingBeanOnThread(cb);
            return null;
        }

        if (isSelectCountIgnoreFetchScopeMethod(invocation)) {
            cb.xsetupSelectCountIgnoreFetchScope();
        } else {
            ${glFetchNarrowingBeanContextName}.setFetchNarrowingBeanOnThread(cb);
        }

        ${glConditionBeanContextName}.setConditionBeanOnThread(cb);
        return cb;
    }

    /**
     * Postprocess condition-bean.
     * 
     * @param invocation Method invocation. (NotNull)
     * @param cb Condition-bean. (Nullable)
     */
    protected void postprocessConditionBean(org.aopalliance.intercept.MethodInvocation invocation, ${glConditionBeanInterfaceName} cb) {
        if (cb == null) {
            return;
        }
        if (isSelectCountIgnoreFetchScopeMethod(invocation)) {
            cb.xafterCareSelectCountIgnoreFetchScope();
        }
    }

    // -----------------------------------------------------
    //                                    Clear Thread Local
    //                                    ------------------
    protected void clearThreadLocal() {
        if (${glOutsideSqlContextName}.isExistOutsideSqlContextOnThread()) {
            ${glOutsideSqlContextName}.clearOutsideSqlContextOnThread();
        }
        if (${glFetchNarrowingBeanContextName}.isExistFetchNarrowingBeanOnThread()) {
            // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            // Because there is possible that fetch narrowing has been ignored for manualPaging of outsideSql.
            // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            ${glFetchNarrowingBeanContextName}.getFetchNarrowingBeanOnThread().restoreIgnoredFetchNarrowing();

            ${glFetchNarrowingBeanContextName}.clearFetchNarrowingBeanOnThread();
        }
        if (${glConditionBeanContextName}.isExistConditionBeanOnThread()) {
            ${glConditionBeanContextName}.clearConditionBeanOnThread();
        }
    }

    // ===================================================================================
    //                                                                      Context Helper
    //                                                                      ==============
    protected ${glOutsideSqlContextName} getOutsideSqlContext() {
        if (!${glOutsideSqlContextName}.isExistOutsideSqlContextOnThread()) {
            return null;
        }
        return ${glOutsideSqlContextName}.getOutsideSqlContextOnThread();
    }
    
    protected boolean isSpecifiedOutsideSql() {
        final ${glOutsideSqlContextName} outsideSqlContext = getOutsideSqlContext();
        return outsideSqlContext != null && outsideSqlContext.isSpecifiedOutsideSql();
    }

    // ===================================================================================
    //                                                                       Determination
    //                                                                       =============
    /**
     * Is select count ignore-fetch-scope method?
     * 
     * @param invocation Method invocation. (NotNull)
     * @return Determination.
     */
    protected boolean isSelectCountIgnoreFetchScopeMethod(org.aopalliance.intercept.MethodInvocation invocation) {
        final String name = invocation.getMethod().getName();
        return name.startsWith("readCount") || name.startsWith("selectCount");
    }

    // ===================================================================================
    //                                                                              Helper
    //                                                                              ======
    /**
     * Get the value of line separator.
     * 
     * @return The value of line separator. (NotNull)
     */
    protected String getLineSeparator() {
        return System.getProperty("line.separator");
    }
}