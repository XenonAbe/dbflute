${database.allClassCopyright}package ${glPackageBaseCommonS2Dao};

import java.lang.reflect.Method;
import java.util.Map;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import javax.sql.DataSource;

import org.seasar.dao.CommandContext;
import org.seasar.dao.EndCommentNotFoundRuntimeException;
import org.seasar.dao.IfConditionNotFoundRuntimeException;
import org.seasar.dao.Node;
import org.seasar.dao.SqlParser;
import org.seasar.dao.SqlTokenizer;
import org.seasar.dao.impl.SelectDynamicCommand;
import org.seasar.dao.node.AbstractNode;
import org.seasar.dao.node.BeginNode;
import org.seasar.dao.node.ContainerNode;
import org.seasar.dao.node.ElseNode;
import org.seasar.dao.node.ParenBindVariableNode;
import org.seasar.dao.node.PrefixSqlNode;
import org.seasar.dao.node.SqlNode;
import org.seasar.dao.parser.SqlTokenizerImpl;
import org.seasar.extension.jdbc.ResultSetFactory;
import org.seasar.extension.jdbc.ResultSetHandler;
import org.seasar.extension.jdbc.StatementFactory;
import org.seasar.extension.jdbc.ValueType;
import org.seasar.extension.jdbc.impl.BasicSelectHandler;
import org.seasar.extension.jdbc.types.ValueTypes;
import org.seasar.framework.beans.BeanDesc;
import org.seasar.framework.beans.PropertyDesc;
import org.seasar.framework.beans.factory.BeanDescFactory;
import org.seasar.framework.exception.SQLRuntimeException;
import org.seasar.framework.util.OgnlUtil;

import ${glPackageBaseCommonCBean}.${glConditionBeanInterfaceName};
import ${glPackageBaseCommonCBean}.${glConditionBeanContextName};
import ${glPackageBaseCommonCBean}.${glMapParameterBeanInterfaceName};
import ${glPackageBaseCommonCBeanOutsidesql}.${glOutsideSqlContextName};
import ${glPackageBaseCommonSqlClause}.${glSqlClauseInterfaceName};
import ${glPackageBaseCommonException}.${glBindVariableCommentNotFoundPropertyException};
import ${glPackageBaseCommonException}.${glEmbeddedValueCommentNotFoundPropertyException};
import ${glPackageBaseCommonException}.${glIfCommentNotBooleanResultException};
import ${glPackageBaseCommonException}.${glIfCommentWrongExpressionException};

/**
 * SelectDynamicCommand for DBFlute.
 * 
 * @author ${database.ClassAuthor}
 */${database.outputSuppressWarningsAfterLineSeparator()}
public class ${glSelectDynamicCommand} extends SelectDynamicCommand {

    // ===================================================================================
    //                                                                           Attribute
    //                                                                           =========
    /** Root node. */
    protected Node rootNode;// Override!

    /** Result-set handler. */
    protected ResultSetHandler resultSetHandler;

    /** Result-set factory. */
    protected ResultSetFactory resultSetFactory;

    /** Cache of select clause command. */
    protected ${glSelectDynamicCommand} _selectClauseCommand;

    /** Cache of select clause PK-only command. */
    protected ${glSelectDynamicCommand} _selectClausePKOnlyCommand;

#if ($database.isVersionAfter1046())
    /** DBFlute does not use this class! */
    protected org.seasar.dao.pager.PagingSqlRewriter pagingSqlRewriter;
#end

    // ===================================================================================
    //                                                                         Constructor
    //                                                                         ===========
    /**
     * Constructor.
     * 
     * @param dataSource Data source.
     * @param statementFactory Statement factory.
     * @param resultSetHandler Result-set handler.
     * @param resultSetFactory Result-set factory.
     */
    public ${glSelectDynamicCommand}(DataSource dataSource,
            StatementFactory statementFactory,
            ResultSetHandler resultSetHandler, ResultSetFactory resultSetFactory) {
#if ($database.isVersionAfter1046())
        this(dataSource, statementFactory, resultSetHandler, resultSetFactory, null);
#else
        super(dataSource, statementFactory, resultSetHandler, resultSetFactory);
        this.resultSetHandler = resultSetHandler;
        this.resultSetFactory = resultSetFactory;
#end
    }

#if ($database.isVersionAfter1046())
    /**
     * Constructor.
     * 
     * @param dataSource Data source.
     * @param statementFactory Statement factory.
     * @param resultSetHandler Result-set handler.
     * @param resultSetFactory Result-set factory.
     * @param pagingSqlRewriter Paging sql rewriter.
     */
    public ${glSelectDynamicCommand}(DataSource dataSource,
            StatementFactory statementFactory,
            ResultSetHandler resultSetHandler, ResultSetFactory resultSetFactory, org.seasar.dao.pager.PagingSqlRewriter pagingSqlRewriter) {
        super(dataSource, statementFactory, resultSetHandler, resultSetFactory, pagingSqlRewriter);
        this.resultSetHandler = resultSetHandler;
        this.resultSetFactory = resultSetFactory;
        this.pagingSqlRewriter = pagingSqlRewriter;
    }
#end

    // ===================================================================================
    //                                                            Very Important Extension
    //                                                            ========================
    // -----------------------------------------------------
    //                                              Override
    //                                              --------
    /**
     * The override for extension.
     * 
     * @param sql SQL. (NotNull)
     */
    @Override
    public void setSql(String sql) {// Override!
        super.setSql(sql);
        this.rootNode = new InternalSqlParserImpl(sql).parse();// Use internal sql parser.
    }

    /**
     * The override for extension.
     * 
     * @param args The array of argument. (NotNull)
     */
    @Override
    protected CommandContext apply(Object[] args) {// Override!
        CommandContext ctx = createCommandContext(args);
        rootNode.accept(ctx);
        return ctx;
    }

    /**
     * The override for extension.
     * 
     * @param argNames The array of argument name. (NotNull)
     */
    @Override
    public void setArgNames(String[] argNames) {
        if (_selectClauseCommand != null) {
            _selectClauseCommand.setArgNames(argNames);
        }
        if (_selectClausePKOnlyCommand != null) {
            _selectClausePKOnlyCommand.setArgNames(argNames);
        }
        super.setArgNames(argNames);
    }

    /**
     * The override for extension.
     * 
     * @param argTypes The array of argument type. (NotNull)
     */
    @Override
    public void setArgTypes(Class[] argTypes) {
        if (_selectClauseCommand != null) {
            _selectClauseCommand.setArgTypes(argTypes);
        }
        if (_selectClausePKOnlyCommand != null) {
            _selectClausePKOnlyCommand.setArgTypes(argTypes);
        }
        super.setArgTypes(argTypes);
    }

    // -----------------------------------------------------
    //                                            For Public
    //                                            ----------
    /**
     * Do apply as public. {for delegating to apply()}
     * 
     * @param args Arguments. (NotNull)
     * @return Command context. (NotNull)
     */
    public CommandContext doApply(Object[] args) {
        return apply(args);
    }

    // -----------------------------------------------------
    //                                         Select Clause
    //                                         -------------
    /**
     * Set select clause.
     * 
     * @param value Select clause. (Nullable)
     * @return this. (NotNull)
     */
    public ${glSelectDynamicCommand} setSelectClause(String value) {
        _selectClauseCommand = createMySelectDynamicCommand();
        _selectClauseCommand.setSql(value);
        return this;
    }

    /**
     * Set select clause PK only.
     * 
     * @param value Select clause PK only. (Nullable)
     * @return this. (NotNull)
     */
    public ${glSelectDynamicCommand} setSelectClausePKOnly(String value) {
        _selectClausePKOnlyCommand = createMySelectDynamicCommand();
        _selectClausePKOnlyCommand.setSql(value);
        return this;
    }

    // -----------------------------------------------------
    //                         SelectDynamicCommand Creation
    //                         -----------------------------
    protected ${glSelectDynamicCommand} createMySelectDynamicCommand() {
        return new ${glSelectDynamicCommand}(getDataSource(), getStatementFactory(), resultSetHandler, resultSetFactory);
    }

    // ===================================================================================
    //                                                                             Execute
    //                                                                             =======
    // -----------------------------------------------------
    //                                           Top Execute
    //                                           -----------
    /**
     * The override for extension.
     * 
     * @param args The array of argument. (Nullable)
     * @return Result. (Nullable)
     */
    @Override
    public Object execute(Object[] args) {
        // - - - - - - - - - - - -
        // This is top execution.
        // - - - - - - - - - - - -

        if (!${glConditionBeanContextName}.isExistConditionBeanOnThread()) {
            // - - - - - - - - - -
            // Execute outsideSql.
            // - - - - - - - - - -
            if (${glOutsideSqlContextName}.isExistOutsideSqlContextOnThread()) {
                final ${glOutsideSqlContextName} outsideSqlContext = ${glOutsideSqlContextName}.getOutsideSqlContextOnThread();
                if (outsideSqlContext.isDynamicBinding()) {
                    return executeOutsideSqlAsDynamic(args, outsideSqlContext);
                } else {
                    return executeOutsideSqlAsStatic(args, outsideSqlContext);
                }
            }

            // - - - - - - - - -
            // Execute default.
            // - - - - - - - - -
            return executeDefault(args);
        }

        // - - - - - - - - - - - -
        // Execute conditionBean.
        // - - - - - - - - - - - -
        assertSelectClauseCommand();
        final List${database.filterGenericsString('Object')} bindVariableList = new ArrayList${database.filterGenericsString('Object')}();
        final List${database.filterGenericsString('Class')} bindVariableTypeList = new ArrayList${database.filterGenericsString('Class')}();

        final ${glConditionBeanInterfaceName} cb = ${glConditionBeanContextName}.getConditionBeanOnThread();
        final String finalClause;
        if (cb.hasUnionQueryOrUnionAllQuery()) {
            final String selectClause = setupRealSelectClause(args, bindVariableList, bindVariableTypeList);
            final String fromWhereClause = setupRealFromWhereClause(args, bindVariableList, bindVariableTypeList);
            if (cb.isSelectCountIgnoreFetchScope()) {
                // If the query uses union and it selects count, the way of select-count is as follows.
                // (Then it needs included-select-column)
                finalClause = "select count(*) from (" + InternalStringUtil.replace(fromWhereClause, ${glSqlClauseInterfaceName}.INCLUDE_SELECT_CLAUSE_MARK, selectClause) + ") base";
            } else {
                finalClause = InternalStringUtil.replace(fromWhereClause, ${glSqlClauseInterfaceName}.INCLUDE_SELECT_CLAUSE_MARK, selectClause);
            }
        } else {
            final String selectClause;
            if (cb.isSelectCountIgnoreFetchScope()) {
                selectClause = "select count(*)";
            } else {
                selectClause = setupRealSelectClause(args, bindVariableList, bindVariableTypeList);
            }
            final String fromWhereClause = setupRealFromWhereClause(args, bindVariableList, bindVariableTypeList);
            finalClause = InternalStringUtil.replace(fromWhereClause, ${glSqlClauseInterfaceName}.INCLUDE_SELECT_CLAUSE_MARK, selectClause);
        }

        final BasicSelectHandler selectHandler = createBasicSelectHandler(finalClause, this.resultSetHandler);
        return selectHandler.execute(bindVariableList.toArray(), toClassArray(bindVariableTypeList));
    }

    // -----------------------------------------------------
    //                                       Default Execute
    //                                       ---------------
    /**
     * Execute default.
     * 
     * @param args The array of argument. (Nullable)
     * @return Result. (Nullable)
     */
    protected Object executeDefault(Object args[]) {
        // - - - - - - - - - - - - - - - - -
        // Find specified resultSetHandler.
        // - - - - - - - - - - - - - - - - -
        final ResultSetHandler specifiedResultSetHandler = findSpecifiedResultSetHandler(args);

        // - - - - - - - - -
        // Filter arguments.
        // - - - - - - - - -
        final Object[] filteredArgs = filterArgumentsForResultSetHandler(args);

        final org.seasar.dao.CommandContext ctx = apply(filteredArgs);
        final BasicSelectHandler selectHandler = createBasicSelectHandler(ctx.getSql(), specifiedResultSetHandler);
        return selectHandler.execute(ctx.getBindVariables(), ctx.getBindVariableTypes());
    }

    // -----------------------------------------------------
    //                                    OutsideSql Execute
    //                                    ------------------
    /**
     * Execute outsideSql as static.
     * 
     * @param args The array of argument. (Nullable)
     * @param outsideSqlContext The context of outsideSql. (NotNull)
     * @return Result. (Nullable)
     */
    protected Object executeOutsideSqlAsStatic(Object[] args, ${glOutsideSqlContextName} outsideSqlContext) {
        // - - - - - - - - - - - - - - - - -
        // Find specified resultSetHandler.
        // - - - - - - - - - - - - - - - - -
        final ResultSetHandler specifiedResultSetHandler = findSpecifiedResultSetHandler(args);

        // - - - - - - - - -
        // Filter arguments.
        // - - - - - - - - -
        final Object[] filteredArgs;
        if (outsideSqlContext.isSpecifiedOutsideSql()) {
            final Object parameterBean = outsideSqlContext.getParameterBean();
            filteredArgs = new Object[] {parameterBean};
        } else {
            filteredArgs = filterArgumentsForResultSetHandler(args);
        }

        final org.seasar.dao.CommandContext ctx = apply(filteredArgs);
        final BasicSelectHandler selectHandler = createBasicSelectHandler(ctx.getSql(), specifiedResultSetHandler);
        return selectHandler.execute(ctx.getBindVariables(), ctx.getBindVariableTypes());
    }

    /**
     * Execute outsideSql as Dynamic.
     * 
     * @param args The array of argument. (Nullable)
     * @param outsideSqlContext The context of outsideSql. (NotNull)
     * @return Result. (Nullable)
     */
    protected Object executeOutsideSqlAsDynamic(Object[] args, ${glOutsideSqlContextName} outsideSqlContext) {
        final Object firstArg = args[0];
        final BeanDesc beanDesc = BeanDescFactory.getBeanDesc(firstArg.getClass());
        String filteredSql = getSql();

        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // Resolve embedded comment for parsing bind variable comment in embedded comment.
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        for (int i = 0; i < beanDesc.getPropertyDescSize(); i++) {
            final PropertyDesc propertyDesc = beanDesc.getPropertyDesc(i);
            final Class propertyType = propertyDesc.getPropertyType();
            if (!propertyType.equals(String.class)) {
                continue;
            }
            final String outsideSqlPiece = (String) propertyDesc.getValue(firstArg);
            if (outsideSqlPiece == null) {
                continue;
            }
            final String embeddedComment = "/*$pmb." + propertyDesc.getPropertyName() + "*/";
            filteredSql = InternalStringUtil.replace(filteredSql, embeddedComment, outsideSqlPiece);
        }
        final ${glSelectDynamicCommand} outsideSqlCommand = createMySelectDynamicCommand();
        outsideSqlCommand.setArgNames(getArgNames());
        outsideSqlCommand.setArgTypes(getArgTypes());
        outsideSqlCommand.setSql(filteredSql);

        // - - - - - - - - - - - - - - - - -
        // Find specified resultSetHandler.
        // - - - - - - - - - - - - - - - - -
        final ResultSetHandler specifiedResultSetHandler = findSpecifiedResultSetHandler(args);

        // - - - - - - - - -
        // Filter arguments.
        // - - - - - - - - -
        final Object[] filteredArgs;
        if (outsideSqlContext.isSpecifiedOutsideSql()) {
            final Object parameterBean = outsideSqlContext.getParameterBean();
            filteredArgs = new Object[] {parameterBean};
        } else {
            filteredArgs = filterArgumentsForResultSetHandler(args);
        }

        final org.seasar.dao.CommandContext ctx = outsideSqlCommand.doApply(filteredArgs);
        final java.util.List<Object> bindVariableList = new java.util.ArrayList<Object>();
        final java.util.List<Class> bindVariableTypeList = new java.util.ArrayList<Class>();
        addBindVariableInfo(ctx, bindVariableList, bindVariableTypeList);
        final BasicSelectHandler selectHandler = createBasicSelectHandler(ctx.getSql(), specifiedResultSetHandler);
        return selectHandler.execute(bindVariableList.toArray(), toClassArray(bindVariableTypeList));
    }

    protected Object[] filterArgumentsForResultSetHandler(Object[] args) {
        if (args == null || args.length == 0) {
            return args;
        }
        final Object[] filteredArgs;
        if (args[args.length - 1] instanceof ${glPackageBaseCommonJdbc}.${glCursorHandlerName}) {
            filteredArgs = new Object[args.length - 1];
            for (int i=0; i < args.length - 1; i++) {
                filteredArgs[i] = args[i];
            }
        } else {
            filteredArgs = args;
        }
        return filteredArgs;
    }

    protected ResultSetHandler findSpecifiedResultSetHandler(Object[] args) {
        if (args == null || args.length == 0) {
            return this.resultSetHandler;
        }
        if (args[args.length-1] instanceof ${glPackageBaseCommonJdbc}.${glCursorHandlerName}) {
            final ${glPackageBaseCommonJdbc}.${glCursorHandlerName} cursorHandler = (${glPackageBaseCommonJdbc}.${glCursorHandlerName})args[args.length-1];
            return new ResultSetHandler() { public Object handle(java.sql.ResultSet rs) throws java.sql.SQLException { return cursorHandler.handle(rs); } };
        }
        if (getArgTypes().length+1 == args.length && args[args.length-1] == null) {
            String msg = "System Level Exception!" + getLineSeparator();
            msg = msg + "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *" + getLineSeparator();
            msg = msg + "The size of arg types have not been same as the size of arg objects:";
            msg = msg + " argTypes=" + getArgTypes().length + " args=" + args.length + getLineSeparator();
            msg = msg + "If the arguments contain ResultSetHandler, the argument value should not be null!" + getLineSeparator();
            for (int i=0; i < args.length - 1; i++) {
                msg = msg + "  args[" + i + "] -- " + args[i] + getLineSeparator();
            }
            msg = msg + "* * * * * * * * * */" + getLineSeparator();
            throw new IllegalStateException(msg);
        }
        return this.resultSetHandler;
    }

    // -----------------------------------------------------
    //                                          Setup Clause
    //                                          ------------
    protected String setupRealSelectClause(Object[] args, List${database.filterGenericsString('Object')} bindVariableList, List${database.filterGenericsString('Class')} bindVariableTypeList) {
        final ${glConditionBeanInterfaceName} cb = ${glConditionBeanContextName}.getConditionBeanOnThread();
        final String realSelectClause;
        {
            final CommandContext ctx;
            if (cb.isLimitSelect_PKOnly()) {
                ctx = _selectClausePKOnlyCommand.doApply(args);
            } else {
                ctx = _selectClauseCommand.doApply(args);
            }
            realSelectClause = ctx.getSql();
            addBindVariableInfo(ctx, bindVariableList, bindVariableTypeList);
        }
        return realSelectClause;
    }

    protected String setupRealFromWhereClause(Object[] args, java.util.List${database.filterGenericsString('Object')} bindVariableList, List${database.filterGenericsString('Class')} bindVariableTypeList) {
        final ${glConditionBeanInterfaceName} cb = ${glConditionBeanContextName}.getConditionBeanOnThread();
        final String realFromWhereClause;
        {
            final ${glSelectDynamicCommand} fromWhereCommand = createMySelectDynamicCommand();
            fromWhereCommand.setArgNames(getArgNames());
            fromWhereCommand.setArgTypes(getArgTypes());

            // for Union
            cb.getSqlClause().setSelectClauseColumnAliasMap(${glConditionBeanContextName}.getSelectClauseColumnAliasMap(cb.getClass()));

            fromWhereCommand.setSql(cb.getSqlClause().getClause());
            final CommandContext ctx = fromWhereCommand.doApply(args);
            realFromWhereClause = ctx.getSql();
            addBindVariableInfo(ctx, bindVariableList, bindVariableTypeList);
        }
        return realFromWhereClause;
    }

    protected BasicSelectHandler createBasicSelectHandler(String realSql, ResultSetHandler specifiedResultSetHandler) {
        final BasicSelectHandler selectHandler = newBasicSelectHandler(realSql, specifiedResultSetHandler, getStatementFactory(), resultSetFactory);
        selectHandler.setFetchSize(-1);
        return selectHandler;
    }

    protected BasicSelectHandler newBasicSelectHandler(String sql, ResultSetHandler resultSetHandler, StatementFactory statementFactory, ResultSetFactory resultSetFactory) {
        return new BasicSelectHandler(getDataSource(), sql, resultSetHandler, statementFactory, resultSetFactory) {
            @Override
            protected void bindArgs(java.sql.PreparedStatement ps, Object[] args, Class[] argTypes) {
                if (args == null) {
                    return;
                }
                for (int i = 0; i < args.length; ++i) {
                    final ValueType valueType = findValueType(argTypes[i], args[i]);
                    try {
                        valueType.bindValue(ps, i + 1, args[i]);
                    } catch (java.sql.SQLException ex) {
                        throw new SQLRuntimeException(ex);
                    }
                }
            }
            protected ValueType findValueType(Class argType, Object arg) {
                ValueType valueType = ValueTypes.getValueType(arg);
                if (valueType != null) {
                    return valueType;
                }
                valueType = ValueTypes.getValueType(argType);
                if (valueType != null) {
                    return valueType;
                }
                String msg = "Unknown type：argType=" + argType + " args=" + arg;
                throw new IllegalStateException(msg);
            }
        };
    }

    // -----------------------------------------------------
    //                                          Setup Helper
    //                                          ------------
    protected Class[] toClassArray(List${database.filterGenericsString('Class')} bindVariableTypeList) {
        final Class[] bindVariableTypesArray = new Class[bindVariableTypeList.size()];
        for (int i = 0; i < bindVariableTypeList.size(); i++) {
            final Class bindVariableType = (Class) bindVariableTypeList.get(i);
            bindVariableTypesArray[i] = bindVariableType;
        }
        return bindVariableTypesArray;
    }

    protected void addBindVariableInfo(CommandContext ctx, List${database.filterGenericsString('Object')} bindVariableList, List${database.filterGenericsString('Class')} bindVariableTypeList) {
        final Object[] bindVariables = ctx.getBindVariables();
        addBindVariableList(bindVariableList, bindVariables);
        final Class[] bindVariableTypes = ctx.getBindVariableTypes();
        addBindVariableTypeList(bindVariableTypeList, bindVariableTypes);
    }

    protected void addBindVariableList(List${database.filterGenericsString('Object')} bindVariableList, Object[] bindVariables) {
        for (int i=0; i < bindVariables.length; i++) {
            bindVariableList.add(bindVariables[i]);
        }
    }

    protected void addBindVariableTypeList(List${database.filterGenericsString('Class')} bindVariableTypeList, Class[] bindVariableTypes) {
        for (int i=0; i < bindVariableTypes.length; i++) {
            bindVariableTypeList.add(bindVariableTypes[i]);
        }
    }

    protected void assertSelectClauseCommand() {
        if (_selectClauseCommand == null) {
            String msg = "Select clause command should not be null.";
            throw new IllegalStateException(msg);
        }
    }

    // ===================================================================================
    //                                                                              Helper
    //                                                                              ======
    /**
     * Get the value of line separator.
     * 
     * @return The value of line separator. (NotNull)
     */
    protected String getLineSeparator() {
        return System.getProperty("line.separator");
    }

    // ===================================================================================
    //                                                               Internal Static Class
    //                                                               =====================
    // -----------------------------------------------------
    //                                             SqlParser
    //                                             ---------
    protected static class InternalSqlParserImpl implements SqlParser {

        private SqlTokenizer tokenizer;

        private Stack nodeStack = new Stack();

        private String specifiedSql;// Extension!

        public InternalSqlParserImpl(String sql) {
            sql = sql.trim();
            if (sql.endsWith(";")) {
                sql = sql.substring(0, sql.length() - 1);
            }
            specifiedSql = sql;// Extension!
            tokenizer = new SqlTokenizerImpl(sql);
        }

        public Node parse() {
            push(new ContainerNode());
            while (SqlTokenizer.EOF != tokenizer.next()) {
                parseToken();
            }
            return pop();
        }

        protected void parseToken() {
            switch (tokenizer.getTokenType()) {
            case SqlTokenizer.SQL:
                parseSql();
                break;
            case SqlTokenizer.COMMENT:
                parseComment();
                break;
            case SqlTokenizer.ELSE:
                parseElse();
                break;
            case SqlTokenizer.BIND_VARIABLE:
                parseBindVariable();
                break;
            }
        }

        protected void parseSql() {
            String sql = tokenizer.getToken();
            if (isElseMode()) {
                sql = InternalStringUtil.replace(sql, "--", "");
            }
            Node node = peek();
            if ((node instanceof InternalIfNode || node instanceof ElseNode) && node.getChildSize() == 0) {

                SqlTokenizer st = new SqlTokenizerImpl(sql);
                st.skipWhitespace();
                String token = st.skipToken();
                st.skipWhitespace();
                if (sql.startsWith(",")) {
                    if (sql.startsWith(", ")) {
                        node.addChild(new PrefixSqlNode(", ", sql.substring(2)));
                    } else {
                        node.addChild(new PrefixSqlNode(",", sql.substring(1)));
                    }
                } else if ("AND".equalsIgnoreCase(token) || "OR".equalsIgnoreCase(token)) {
                    node.addChild(new PrefixSqlNode(st.getBefore(), st.getAfter()));
                } else {
                    node.addChild(new SqlNode(sql));
                }
            } else {
                node.addChild(new SqlNode(sql));
            }
        }

        protected void parseComment() {
            String comment = tokenizer.getToken();
            if (isTargetComment(comment)) {
                if (isIfComment(comment)) {
                    parseIf();
                } else if (isBeginComment(comment)) {
                    parseBegin();
                } else if (isEndComment(comment)) {
                    return;
                } else {
                    parseCommentBindVariable();
                }
            } else if (comment != null && 0 < comment.length()) {
                String before = tokenizer.getBefore();
                peek().addChild(new SqlNode(before.substring(before.lastIndexOf("/*"))));
            }
        }

        protected void parseIf() {
            String condition = tokenizer.getToken().substring(2).trim();
            if (InternalStringUtil.isEmpty(condition)) {
                throw new IfConditionNotFoundRuntimeException();
            }
            final ContainerNode ifNode = createIfNode(condition);
            peek().addChild(ifNode);
            push(ifNode);
            parseEnd();
        }

        protected void parseBegin() {
            BeginNode beginNode = new BeginNode();
            peek().addChild(beginNode);
            push(beginNode);
            parseEnd();
        }

        protected void parseEnd() {
            while (SqlTokenizer.EOF != tokenizer.next()) {
                if (tokenizer.getTokenType() == SqlTokenizer.COMMENT && isEndComment(tokenizer.getToken())) {

                    pop();
                    return;
                }
                parseToken();
            }
            throw new EndCommentNotFoundRuntimeException();
        }

        protected void parseElse() {
            final Node parent = peek();
            if (!(parent instanceof InternalIfNode)) {
                return;
            }
            final InternalIfNode ifNode = (InternalIfNode) pop();
            final InternalElseNode elseNode = new InternalElseNode();
            ifNode.setElseNode(elseNode);
            push(elseNode);
            tokenizer.skipWhitespace();
        }

        protected void parseCommentBindVariable() {
            final String expr = tokenizer.getToken();
            final String s = tokenizer.skipToken();
            if (s.startsWith("(") && s.endsWith(")")) {
                peek().addChild(new ParenBindVariableNode(expr));
            } else if (expr.startsWith("$")) {
                peek().addChild(createEmbeddedValueNode(expr.substring(1)));// Extension!
            } else {
                peek().addChild(createBindVariableNode(expr));// Extension!
            }
        }

        protected void parseBindVariable() {
            final String expr = tokenizer.getToken();
            peek().addChild(createBindVariableNode(expr));// Extension!
        }

        protected Node pop() {
            return (Node) nodeStack.pop();
        }

        protected Node peek() {
            return (Node) nodeStack.peek();
        }

        protected void push(Node node) {
            nodeStack.push(node);
        }

        protected boolean isElseMode() {
            for (int i = 0; i < nodeStack.size(); ++i) {
                if (nodeStack.get(i) instanceof InternalElseNode) {
                    return true;
                }
            }
            return false;
        }

        private static boolean isTargetComment(String comment) {
            return comment != null && comment.length() > 0 && Character.isJavaIdentifierStart(comment.charAt(0));
        }

        private static boolean isIfComment(String comment) {
            return comment.startsWith("IF");
        }

        private static boolean isBeginComment(String content) {
            return content != null && "BEGIN".equals(content);
        }

        private static boolean isEndComment(String content) {
            return content != null && "END".equals(content);
        }

        protected AbstractNode createBindVariableNode(String expr) {// Extension!
            return new InternalBindVariableNode(expr, specifiedSql);
        }

        protected AbstractNode createEmbeddedValueNode(String expr) {// Extension!
            return new InternalEmbeddedValueNode(expr, specifiedSql);
        }

        protected ContainerNode createIfNode(String expr) {// Extension!
            return new InternalIfNode(expr, specifiedSql);
        }
    }

    // -----------------------------------------------------
    //                                      BindVariableNode
    //                                      ----------------
    protected static class InternalBindVariableNode extends AbstractNode {
        protected String _expression;
        protected String[] _names;
        protected String _specifiedSql;

        public InternalBindVariableNode(String expression, String specifiedSql) {
            this._expression = expression;
            this._names = InternalStringUtil.split(expression, ".");
            this._specifiedSql = specifiedSql;
        }

        public void accept(CommandContext ctx) {
            final Object value = ctx.getArg(_names[0]);
            final Class clazz = ctx.getArgType(_names[0]);
            final InternalValueAndType valueAndType = new InternalValueAndType();
            valueAndType.setTargetValue(value);
            valueAndType.setTargetType(clazz);
            setupValueAndType(valueAndType);
            ctx.addSql("?", valueAndType.getTargetValue(), valueAndType.getTargetType());
        }

        protected void setupValueAndType(InternalValueAndType valueAndType) {
            final InternalValueAndTypeSetuper valueAndTypeSetuper = new InternalValueAndTypeSetuper(_expression, _names, _specifiedSql, true);
            valueAndTypeSetuper.setupValueAndType(valueAndType);
        }
    }

    // -----------------------------------------------------
    //                                     EmbeddedValueNode
    //                                     -----------------
    protected static class InternalEmbeddedValueNode extends AbstractNode {
        protected String _expression;
        protected String[] _names;
        protected String _specifiedSql;

        public InternalEmbeddedValueNode(String expression, String specifiedSql) {
            this._expression = expression;
            this._names = InternalStringUtil.split(expression, ".");
            this._specifiedSql = specifiedSql;
        }

        public void accept(CommandContext ctx) {
            final Object value = ctx.getArg(_names[0]);
            final Class clazz = ctx.getArgType(_names[0]);
            final InternalValueAndType valueAndType = new InternalValueAndType();
            valueAndType.setTargetValue(value);
            valueAndType.setTargetType(clazz);
            setupValueAndType(valueAndType);
            if (valueAndType.getTargetValue() != null && valueAndType.getTargetValue().toString().indexOf("?") > -1) {
                throw new org.seasar.framework.exception.SRuntimeException("EDAO0023");
            }
            ctx.addSql(valueAndType.getTargetValue() != null ? valueAndType.getTargetValue().toString() : null);
        }

        protected void setupValueAndType(InternalValueAndType valueAndType) {
            final InternalValueAndTypeSetuper valueAndTypeSetuper = new InternalValueAndTypeSetuper(_expression, _names, _specifiedSql, false);
            valueAndTypeSetuper.setupValueAndType(valueAndType);
        }
    }

    // -----------------------------------------------------
    //                                        Value and Type
    //                                        --------------
    protected static class InternalValueAndType {
        public Object _targetValue;
        public Class _targetType;

        public Object getTargetValue() {
            return _targetValue;
        }
        public void setTargetValue(Object targetValue) {
            this._targetValue = targetValue;
        }
        public Class getTargetType() {
            return _targetType;
        }
        public void setTargetType(Class targetType) {
            this._targetType = targetType;
        }
    }

    protected static class InternalValueAndTypeSetuper {
        protected String _expression;
        protected String[] _names;
        protected String _specifiedSql;
        protected boolean _bind;

        public InternalValueAndTypeSetuper(String expression, String[] names, String specifiedSql, boolean bind) {
            this._expression = expression;
            this._names = names;
            this._specifiedSql = specifiedSql;
            this._bind = bind;
        }

        protected void setupValueAndType(InternalValueAndType valueAndType) {
            Object value = valueAndType.getTargetValue();
            Class clazz = valueAndType.getTargetType();
            for (int pos = 1; pos < _names.length; ++pos) {
                if (value == null) {
                    break;
                }
                if (Map.class.isInstance(value)) {
                    final Map map = (Map) value;
                    value = map.get(_names[pos]);
                    if (value == null) {
                        break;
                    }
                    clazz = value.getClass();
                    continue;
                }
                final BeanDesc beanDesc = BeanDescFactory.getBeanDesc(clazz);
                final String currentName = _names[pos];
                if (beanDesc.hasPropertyDesc(currentName)) {
                    final PropertyDesc pd = beanDesc.getPropertyDesc(currentName);
                    value = pd.getValue(value);
                    clazz = (value != null ? value.getClass() : pd.getPropertyType());
                    continue;
                }
                final String methodName = "get" + initCap(currentName);
                if (beanDesc.hasMethod(methodName)) {
                    final Method method = beanDesc.getMethod(methodName);
                    value = invokeGetter(method, value);
                    clazz = method.getReturnType();
                    continue;
                }
                if (pos == 1 && ${glMapParameterBeanInterfaceName}.class.isAssignableFrom(clazz)) {
                    final ${glMapParameterBeanInterfaceName} pmb = (${glMapParameterBeanInterfaceName})value;
                    final Map<String, Object> map = pmb.getParameterMap();
                    final Object elementValue = (map != null ? map.get(_names[pos]) : null);
                    if (elementValue != null) {
                        value = elementValue;
                        clazz = elementValue.getClass();
                        continue;
                    }
                }
                throwBindOrEmbeddedCommentNotFoundPropertyException(_expression, clazz, currentName, _specifiedSql, _bind);
            }
            valueAndType.setTargetValue(value);
            valueAndType.setTargetType(clazz);
        }
        
        protected String initCap(String name) {
            return name.substring(0, 1).toUpperCase() + name.substring(1);
        }

        protected Object invokeGetter(Method method, Object target) {
            try {
                return method.invoke(target, (Object[]) null);
            } catch (IllegalArgumentException e) {
                throw new RuntimeException(e);
            } catch (IllegalAccessException e) {
                throw new RuntimeException(e);
            } catch (java.lang.reflect.InvocationTargetException e) {
                throw new RuntimeException(e);
            }
        }

        protected void throwBindOrEmbeddedCommentNotFoundPropertyException(String expression, Class targetType, String notFoundProperty, String specifiedSql, boolean bind) {
            String msg = "Look! Read the message below." + getLineSeparator();
            msg = msg + "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *" + getLineSeparator();
            msg = msg + "The property on the " + (bind ? "bind variable" : "embedded value") + " comment was Not Found!" + getLineSeparator();
            msg = msg + getLineSeparator();
            msg = msg + "[Advice]" + getLineSeparator();
            msg = msg + "Please confirm the existence of your property on your arguments." + getLineSeparator();
            msg = msg + getLineSeparator();
            msg = msg + "[SQL Comment Expression]" + getLineSeparator() + expression + getLineSeparator();
            msg = msg + getLineSeparator();
            msg = msg + "[NotFound Property]" + getLineSeparator() + (targetType != null ? targetType.getName() + "#" : "") + notFoundProperty + getLineSeparator();
            msg = msg + getLineSeparator();
            msg = msg + "[Specified SQL]" + getLineSeparator() + specifiedSql + getLineSeparator();
            msg = msg + "* * * * * * * * * */" + getLineSeparator();
            if (bind) {
                throw new ${glBindVariableCommentNotFoundPropertyException}(msg);
            } else {
                throw new ${glEmbeddedValueCommentNotFoundPropertyException}(msg);
            }
        }

        protected String getLineSeparator() {
            return System.getProperty("line.separator");
        }
    }

    // -----------------------------------------------------
    //                                                IfNode
    //                                                ------
    protected static class InternalIfNode extends ContainerNode {
        private String _expression;
        private Object _parsedExpression;
        private InternalElseNode _elseNode;
        private String _specifiedSql;

        public InternalIfNode(String expression, String specifiedSql) {
            this._expression = expression;
            this._parsedExpression = OgnlUtil.parseExpression(expression);
            this._specifiedSql = specifiedSql;
        }

        public String getExpression() {
            return _expression;
        }

        public InternalElseNode getElseNode() {
            return _elseNode;
        }

        public void setElseNode(InternalElseNode elseNode) {
            this._elseNode = elseNode;
        }

        public void accept(CommandContext ctx) {
            Object result = null;
            try {
                result = OgnlUtil.getValue(_parsedExpression, ctx);
            } catch (RuntimeException e) {
                if (!_expression.contains("pmb.")) {
                    throwIfCommentWrongExpressionException(_expression, e, _specifiedSql);
                }
                final String replaced = InternalStringUtil.replace(_expression, "pmb.", "pmb.parameterMap.");
                final Object secondParsedExpression = OgnlUtil.parseExpression(replaced);
                try {
                    result = OgnlUtil.getValue(secondParsedExpression, ctx);
                } catch (RuntimeException ignored) {
                    throwIfCommentWrongExpressionException(_expression, e, _specifiedSql);
                }
                if (result == null) {
                    throwIfCommentWrongExpressionException(_expression, e, _specifiedSql);
                }
                _parsedExpression = secondParsedExpression;
            }
            if (result != null && result instanceof Boolean) {
                if (((Boolean) result).booleanValue()) {
                    super.accept(ctx);
                    ctx.setEnabled(true);
                } else if (_elseNode != null) {
                    _elseNode.accept(ctx);
                    ctx.setEnabled(true);
                }
            } else {
                throwIfCommentNotBooleanResultException(_expression, result, _specifiedSql);
            }
        }

        protected void throwIfCommentWrongExpressionException(String expression, RuntimeException cause, String specifiedSql) {
            String msg = "Look! Read the message below." + getLineSeparator();
            msg = msg + "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *" + getLineSeparator();
            msg = msg + "The IF comment of your specified SQL was Wrong!" + getLineSeparator();
            msg = msg + getLineSeparator();
            msg = msg + "[Advice]" + getLineSeparator();
            msg = msg + "Please confirm the existence of your property on your arguments." + getLineSeparator();
            msg = msg + "And confirm the IF comment of your specified SQL." + getLineSeparator();
            msg = msg + getLineSeparator();
            msg = msg + "[IF Comment Expression]" + getLineSeparator() + expression + getLineSeparator();
            msg = msg + getLineSeparator();
            msg = msg + "[Cause Message]" + getLineSeparator() + cause.getMessage() + getLineSeparator();
            msg = msg + getLineSeparator();
            msg = msg + "[Specified SQL]" + getLineSeparator() + specifiedSql + getLineSeparator();
            msg = msg + "* * * * * * * * * */" + getLineSeparator();
            throw new ${glIfCommentWrongExpressionException}(msg, cause);
        }

        protected void throwIfCommentNotBooleanResultException(String expression, Object result, String specifiedSql) {
            String msg = "Look! Read the message below." + getLineSeparator();
            msg = msg + "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *" + getLineSeparator();
            msg = msg + "The boolean expression on IF comment of your specified SQL was Wrong!" + getLineSeparator();
            msg = msg + getLineSeparator();
            msg = msg + "[Advice]" + getLineSeparator();
            msg = msg + "Please confirm the grammar of your IF comment. Does it really express boolean?" + getLineSeparator();
            msg = msg + "And confirm the existence of your property on your arguments if you use parameterMap." + getLineSeparator();
            msg = msg + getLineSeparator();
            msg = msg + "[IF Comment Expression]" + getLineSeparator() + expression + getLineSeparator();
            msg = msg + getLineSeparator();
            msg = msg + "[IF Comment Result Value]" + getLineSeparator() + result + getLineSeparator();
            msg = msg + getLineSeparator();
            msg = msg + "[Specified SQL]" + getLineSeparator() + specifiedSql + getLineSeparator();
            msg = msg + "* * * * * * * * * */" + getLineSeparator();
            throw new ${glIfCommentNotBooleanResultException}(msg);
        }

        protected String getLineSeparator() {
            return System.getProperty("line.separator");
        }
    }

    // -----------------------------------------------------
    //                                              ElseNode
    //                                              --------
    protected static class InternalElseNode extends ContainerNode {
        public void accept(CommandContext ctx) {
            super.accept(ctx);
            ctx.setEnabled(true);
        }
    }

    // -----------------------------------------------------
    //                                            StringUtil
    //                                            ----------
    protected static class InternalStringUtil {

        public static final String[] EMPTY_STRINGS = new String[0];
        private InternalStringUtil() {
        }

        public static final boolean isEmpty(String text) {
            return text == null || text.length() == 0;
        }

        public static final String replace(String text, String fromText,  String toText) {
            if (text == null || fromText == null || toText == null) {
                return null;
            }
            StringBuffer buf = new StringBuffer(100);
            int pos = 0;
            int pos2 = 0;
            while (true) {
                pos = text.indexOf(fromText, pos2);
                if (pos == 0) {
                    buf.append(toText);
                    pos2 = fromText.length();
                } else if (pos > 0) {
                    buf.append(text.substring(pos2, pos));
                    buf.append(toText);
                    pos2 = pos + fromText.length();
                } else {
                    buf.append(text.substring(pos2));
                    break;
                }
            }
            return buf.toString();
        }

        public static String[] split(String str, String delim) {
            if (str == null) {
                return EMPTY_STRINGS;
            }
            java.util.List${database.filterGenericsString('String')} list = new java.util.ArrayList${database.filterGenericsString('String')}();
            java.util.StringTokenizer st = new java.util.StringTokenizer(str, delim);
            while (st.hasMoreElements()) {
                list.add(st.nextToken());
            }
            return (String[]) list.toArray(new String[list.size()]);
        }
    }
}