#set ($myClassName = "${glAbstractSqlClause}")

using System;
using ${glPackageBaseCommon};
using ${glPackageBaseCommonCKey};
using ${glPackageBaseCommonCOption};
using ${glPackageBaseCommonCValue};
using ${glPackageBaseCommonDBMeta};
using ${glPackageBaseCommonDBMetaInfo};
using ${glPackageBaseCommonJavaLike};
using ${glPackageBaseCommonUtil};

namespace ${glPackageBaseCommonSqlClause} {

// JavaLike
[System.Serializable]
public abstract class ${myClassName} : ${glSqlClause} {

    // ===================================================================================
    //                                                                          Definition
    //                                                                          ==========
    protected static readonly SelectClauseType DEFAULT_SELECT_CLAUSE_TYPE = SelectClauseType.COLUMNS;
    protected static readonly String SELECT_HINT = "/*$pmb.SelectHint*/ ";

    // ===================================================================================
    //                                                                           Attribute
    //                                                                           =========
    // -----------------------------------------------------
    //                                                 Basic
    //                                                 -----
    /** The name of table. */
    protected readonly String _tableName;

    // -----------------------------------------------------
    //                                       Clause Resource
    //                                       ---------------
    // /- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // The resources that are not often used to are lazy-loaded for performance.
    // - - - - - - - - - -/
    /** Selected select column map. map:{tableAliasName : map:{columnName : selectColumnInfo}} */
    protected Map<String, Map<String, SelectedSelectColumnInfo>> _selectedSelectColumnMap = new LinkedHashMap<String, Map<String, SelectedSelectColumnInfo>>();

    /** Specified select column map. map:{ tableAliasName = map:{ columnName : null } } (Nullable: This is lazy-loaded) */
    protected Map<String, Map<String, String>> _specifiedSelectColumnMap;

    /** Specified derive sub-query map. (Nullable: This is lazy-loaded) */
    protected Map<String, String> _specifiedDeriveSubQueryMap;

    /** The map of real column and alias of select clause. map:{realColumnName : aliasName} */
    protected Map<String, String> _selectClauseRealColumnAliasMap = new HashMap<String, String>();// Without linked!

    /** The type of select clause. (NotNull) */
    protected SelectClauseType _selectClauseType = DEFAULT_SELECT_CLAUSE_TYPE;

    /** The previous type of select clause. (Nullable: The default is null) */
    protected SelectClauseType _previousSelectClauseType;

    /** Outer join map. */
    protected Map<String, LeftOuterJoinInfo> _outerJoinMap = new LinkedHashMap<String, LeftOuterJoinInfo>();

    /** The list of where clause. */
    protected List<String> _whereList = new ArrayList<String>();

    /** Inline where list for BaseTable. */
    protected List<String> _baseTableInlineWhereList = new ArrayList<String>();

    /** The clause of order-by. (NotNull) */
    protected ${glOrderByClause} _orderByClause = new ${glOrderByClause}();

    /** The list of union clause. (Nullable: This is lazy-loaded) */
    protected List<UnionQueryInfo> _unionQueryInfoList;

    /** Is order-by effective? Default value is false. */
    protected bool _orderByEffective = false;

    // -----------------------------------------------------
    //                                        Fetch Property
    //                                        --------------
    /** Fetch start index. (for fetchXxx()) */
    protected int _fetchStartIndex = 0;

    /** Fetch size. (for fetchXxx()) */
    protected int _fetchSize = 0;

    /** Fetch page number. (for fetchXxx()) This value should be plus. */
    protected int _fetchPageNumber = 1;

    /** Is fetch-narrowing effective? Default value is false. */
    protected bool _fetchScopeEffective = false;

    // -----------------------------------------------------
    //                                               OrQuery
    //                                               -------
    /** Is or-query effective?*/
    protected bool _orQueryEffective = false;

    // -----------------------------------------------------
    //                               WhereClauseSimpleFilter
    //                               -----------------------
    // /** The filter for where clause. */
    // protected List<${glWhereClauseSimpleFilter}> _whereClauseSimpleFilterList;

    // -----------------------------------------------------
    //                                 Selected Foreign Info
    //                                 ---------------------
    /** The information of selected foreign table. */
    protected Map<String, String> _selectedForeignInfo;
    
    // -----------------------------------------------------
    //                                         Optional Info
    //                                         -------------
    protected bool _formatClause;

    // ===================================================================================
    //                                                                         Constructor
    //                                                                         ===========
    public ${myClassName}(String tableName) {
        if (tableName == null) {
            String msg = "Argument[tableName] must not be null.";
            throw new IllegalArgumentException(msg);
        }
        _tableName = tableName;
    }

    // ===================================================================================
    //                                                                         Main Clause
    //                                                                         ===========
    // -----------------------------------------------------
    //                                       Complete Clause
    //                                       ---------------
    public String getClause() {
        StringBuilder sb = new StringBuilder(512);
        String selectClause = getSelectClause();
        sb.append(selectClause);
        sb.append(" ");
        buildClauseWithoutMainSelect(sb, selectClause);
        String sql = sb.toString();
        sql = filterEnclosingClause(sql);
        sql = filterSubQueryIndent(sql);
        return sql;
    }

    protected void buildClauseWithoutMainSelect(StringBuilder sb, String selectClause) {
        buildFromClause(sb);
        sb.append(getFromHint());
        sb.append(" ");
        buildWhereClause(sb);
        String unionClause = prepareUnionClause(selectClause);
        unionClause = deleteUnionWhereTemplateMark(unionClause); // required
        sb.append(unionClause);
        if (!needsUnionNormalSelectEnclosing()) {
            sb.append(prepareClauseOrderBy());
            sb.append(prepareClauseSqlSuffix());
        }
    }

    protected virtual String deleteUnionWhereTemplateMark(String unionClause) {
        if (unionClause != null && unionClause.Trim().Length > 0) {
            unionClause = replaceString(unionClause, getUnionWhereClauseMark(), "");
            unionClause = replaceString(unionClause, getUnionWhereFirstConditionMark(), "");
        }
        return unionClause;
    }

    // -----------------------------------------------------
    //                                       Fragment Clause
    //                                       ---------------
    public String getClauseFromWhereWithUnionTemplate() {
        return buildClauseFromWhereAsTemplate(false);
    }

    public String getClauseFromWhereWithWhereUnionTemplate() {
        return buildClauseFromWhereAsTemplate(true);
    }

    protected virtual String buildClauseFromWhereAsTemplate(bool template) {
        StringBuilder sb = new StringBuilder(256);
        buildFromClause(sb);
        sb.append(getFromHint());
        sb.append(" ");
        sb.append(buildWhereClause(sb, template));
        sb.append(prepareUnionClause(getUnionSelectClauseMark()));
        return sb.toString();
    }

    protected virtual String prepareUnionClause(String selectClause) {
        if (!hasUnionQuery()) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        for (Iterator<UnionQueryInfo> ite = _unionQueryInfoList.iterator(); ite.hasNext(); ) {
            UnionQueryInfo unionQueryInfo = (UnionQueryInfo)ite.next();
            String unionQueryClause = unionQueryInfo.getUnionQueryClause();
            bool unionAll = unionQueryInfo.isUnionAll();
            sb.append(ln());
            if (needsUnionNormalSelectEnclosing()) {
                sb.append("        ");
            }
            sb.append(unionAll ? " union all " : " union ");
            sb.append(ln());
            sb.append(selectClause).append(" ").append(unionQueryClause);
        }
        return sb.toString();
    }

    protected String prepareClauseOrderBy() {
        if (!_orderByEffective || _orderByClause.isEmpty()) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        sb.append(" ");
        sb.append(getOrderByClause());
        return sb.toString();
    }

    protected String prepareClauseSqlSuffix() {
        String sqlSuffix = getSqlSuffix();
        if (sqlSuffix == null || sqlSuffix.trim().length() == 0) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        sb.append(" ");
        sb.append(sqlSuffix);
        return sb.toString();
    }

    protected String filterEnclosingClause(String sql) {
        sql = filterUnionNormalSelectEnclosing(sql);
        sql = filterUnionCountOrScalarEnclosing(sql);
        return sql;
    }

    protected virtual String filterUnionNormalSelectEnclosing(String sql) {
        if (!needsUnionNormalSelectEnclosing()) {
            return sql;
        }
        String selectClause = "select" + SELECT_HINT + " *";
        String ln = ln();
        String beginMark = resolveSubQueryBeginMark("dfmain") + ln;
        String endMark = resolveSubQueryEndMark("dfmain");
        String clause = selectClause + ln + "  from (" + beginMark + sql + ln + "       ) dfmain" + endMark;
        clause = clause + prepareClauseOrderBy() + prepareClauseSqlSuffix();
        return clause;
    }

    protected virtual String filterUnionCountOrScalarEnclosing(String sql) {
        if (!needsUnionCountOrScalarEnclosing()) {
            return sql;
        }
        String selectClause = buildSelectClauseCountOrScalar("dfmain");
        String ln = ln();
        String beginMark = resolveSubQueryBeginMark("dfmain") + ln;
        String endMark = resolveSubQueryEndMark("dfmain");
        return selectClause + ln + "  from (" + beginMark + sql + ln + "       ) dfmain" + endMark;
    }

    protected virtual bool needsUnionNormalSelectEnclosing() {
        if (!isUnionNormalSelectEnclosingRequired()) {
            return false;
        }
        return hasUnionQuery() && !isSelectClauseTypeCountOrScalar();
    }

    protected virtual bool isUnionNormalSelectEnclosingRequired() { // for extension
        return false; // false as default
    }

    protected virtual bool needsUnionCountOrScalarEnclosing() {
        return hasUnionQuery() && isSelectClauseTypeCountOrScalar();
    }

    // ===================================================================================
    //                                                                        Clause Parts
    //                                                                        ============
    // -----------------------------------------------------
    //                                         Select Clause
    //                                         -------------
    public String getSelectClause() {
        // [DBFlute-0.8.6]
        if (isSelectClauseTypeCountOrScalar() && !hasUnionQuery()) {
            return buildSelectClauseCountOrScalar("dflocal");
        }
        // /- - - - - - - - - - - - - - - - - - - - - - - - 
        // The type of select clause is COLUMNS since here.
        // - - - - - - - - - -/
        StringBuilder sb = new StringBuilder();
        ${glDBMeta} dbmeta = ${glDBMetaInstanceHandler}.FindDBMeta(_tableName);
        List<${glColumnInfo}> columnInfoList = dbmeta.ColumnInfoList;

        // [DBFlute-0.7.4]
        Map<String, String> localSpecifiedMap = null;
        if (_specifiedSelectColumnMap != null) {
            localSpecifiedMap = _specifiedSelectColumnMap.get(getLocalTableAliasName());
        }
        bool existsSpecifiedLocal = localSpecifiedMap != null && !localSpecifiedMap.isEmpty();

        // Columns of local table.
        foreach (${glColumnInfo} columnInfo in columnInfoList) {
            String columnName = columnInfo.ColumnDbName;
            
            // [DBFlute-0.7.4]
            if (existsSpecifiedLocal && !localSpecifiedMap.containsKey(columnName)) {
                if (isSelectClauseTypeCountOrScalar() && hasUnionQuery()) {
                    // Here it must be with union query.
                    // So the primary Key is target for saving unique.
                    // But if it does not have primary keys, all column is target.
                    if (dbmeta.HasPrimaryKey) {
                        if (!columnInfo.IsPrimary) {
                            continue;
                        }
                    }
                } else {
                    continue;
                }
            }

            if (sb.length() > 0) {
                sb.append(", ");
            } else {
                sb.append("select");
                appendSelectHint(sb);
                sb.append(" ");
            }
            String realColumnName = getLocalTableAliasName() + "." + columnName;
            sb.append(realColumnName).append(" as ").append(columnName);
            _selectClauseRealColumnAliasMap.put(realColumnName, columnName);
        }
        
        // Columns of foreign tables.
        Set<String> tableAliasNameSet = _selectedSelectColumnMap.keySet();
        foreach (String tableAliasName in tableAliasNameSet) {
            Map<String, SelectedSelectColumnInfo> map = _selectedSelectColumnMap.get(tableAliasName);
            Collection<SelectedSelectColumnInfo> selectColumnInfoList = map.values();
            Map<String, String> foreginSpecifiedMap = null;
            if (_specifiedSelectColumnMap != null) {
                foreginSpecifiedMap = _specifiedSelectColumnMap.get(tableAliasName);
            }
            bool existsSpecifiedForeign = foreginSpecifiedMap != null && !foreginSpecifiedMap.isEmpty();
            bool finishedForeignIndent = false;
            foreach (SelectedSelectColumnInfo selectColumnInfo in selectColumnInfoList) {
                if (existsSpecifiedForeign && !foreginSpecifiedMap.containsKey(selectColumnInfo.getColumnName())) {
                    continue;
                }

                String realColumnName = selectColumnInfo.buildRealColumnName();
                if (!finishedForeignIndent) {
                    sb.append(ln()).append("     ");
                    finishedForeignIndent = true;
                }
                sb.append(", ").append(realColumnName).append(" as ").append(selectColumnInfo.getColumnAliasName());
                _selectClauseRealColumnAliasMap.put(realColumnName, selectColumnInfo.getColumnAliasName());
            }
        }

        // [DBFlute-0.7.4]
        if (_specifiedDeriveSubQueryMap != null && !_specifiedDeriveSubQueryMap.isEmpty()) {
            Collection<String> deriveSubQuerySet = _specifiedDeriveSubQueryMap.values();
            foreach (String deriveSubQuery in deriveSubQuerySet) {
                sb.append(ln()).append("     ");
                sb.append(", ").append(deriveSubQuery);
                
                // [DBFlute-0.8.3]
                int beginIndex = deriveSubQuery.LastIndexOf(" as ");
                if (beginIndex >= 0) { // basically true
                    String aliasName = deriveSubQuery.Substring(beginIndex + " as ".Length);
                    int endIndex = aliasName.IndexOf("--df:");
                    if (endIndex >= 0) { // basically true
                        aliasName = aliasName.Substring(0, endIndex);
                    }
                    // for SpecifiedDerivedOrderBy
                    _selectClauseRealColumnAliasMap.put(aliasName, aliasName);
                }
            }
        }

        return sb.toString();
    }

    // -----------------------------------------------------
    //                                       Count or Scalar
    //                                       ---------------
    protected bool isSelectClauseTypeCountOrScalar() {
        if (_selectClauseType.equals(SelectClauseType.COUNT)) {
            return true;
        } else if (_selectClauseType.equals(SelectClauseType.MAX)) {
            return true;
        } else if (_selectClauseType.equals(SelectClauseType.MIN)) {
            return true;
        } else if (_selectClauseType.equals(SelectClauseType.SUM)) {
            return true;
        } else if (_selectClauseType.equals(SelectClauseType.AVG)) {
            return true;
        }
        return false;
    }

    protected String buildSelectClauseCountOrScalar(String aliasName) {
        if (_selectClauseType.equals(SelectClauseType.COUNT)) {
            return buildSelectClauseCount();
        } else if (_selectClauseType.equals(SelectClauseType.MAX)) {
            return buildSelectClauseMax(aliasName);
        } else if (_selectClauseType.equals(SelectClauseType.MIN)) {
            return buildSelectClauseMin(aliasName);
        } else if (_selectClauseType.equals(SelectClauseType.SUM)) {
            return buildSelectClauseSum(aliasName);
        } else if (_selectClauseType.equals(SelectClauseType.AVG)) {
            return buildSelectClauseAvg(aliasName);
        }
        String msg = "The type of select clause is not for scalar:";
        msg = msg + " type=" + _selectClauseType;
        throw new IllegalStateException(msg);
    }

    protected String buildSelectClauseCount() {
        return "select count(*)";
    }

    protected String buildSelectClauseMax(String aliasName) {
        String columnName = getSpecifiedColumnNameAsOne();
        assertScalarSelectSpecifiedColumnOnlyOne(columnName);
        return "select max(" + aliasName + "." + columnName  + ")";
    }

    protected String buildSelectClauseMin(String aliasName) {
        String columnName = getSpecifiedColumnNameAsOne();
        assertScalarSelectSpecifiedColumnOnlyOne(columnName);
        return "select min(" + aliasName + "." + columnName  + ")";
    }

    protected String buildSelectClauseSum(String aliasName) {
        String columnName = getSpecifiedColumnNameAsOne();
        assertScalarSelectSpecifiedColumnOnlyOne(columnName);
        return "select sum(" + aliasName + "." + columnName  + ")";
    }

    protected String buildSelectClauseAvg(String aliasName) {
        String columnName = getSpecifiedColumnNameAsOne();
        assertScalarSelectSpecifiedColumnOnlyOne(columnName);
        return "select avg(" + aliasName + "." + columnName  + ")";
    }

    protected void assertScalarSelectSpecifiedColumnOnlyOne(String columnName) {
        if (columnName != null) {
            return;
        }
        String msg = "The specified column exists one";
        msg = msg + " when the type of select clause is for scalar:";
        msg = msg + " specifiedSelectColumnMap=" + _specifiedSelectColumnMap;
        throw new IllegalStateException(msg);
    }

    // -----------------------------------------------------
    //                                           Select Hint
    //                                           -----------
    public String getSelectHint() {
        return createSelectHint();
    }

    protected virtual void appendSelectHint(StringBuilder sb) { // for extension
        sb.append(SELECT_HINT);
    }

    // -----------------------------------------------------
    //                                           From Clause
    //                                           -----------
    public String getFromClause() {
        StringBuilder sb = new StringBuilder();
        buildFromClause(sb);
        return sb.toString();
    }

    public void buildFromClause(StringBuilder sb) {
        sb.append(ln()).append("  ");
        sb.append("from ");
        if (_baseTableInlineWhereList.isEmpty()) {
            sb.append(_tableName).append(" dflocal");
        } else {
            sb.append(getInlineViewClause(_tableName, _baseTableInlineWhereList)).append(" dflocal");
        }
        sb.append(getFromBaseTableHint());
        sb.append(getLeftOuterJoinClause());
    }

    protected String getLeftOuterJoinClause() {
        String fixedConditionKey = getFixedConditionKey();
        StringBuilder sb = new StringBuilder();
        for (Iterator<String> ite = _outerJoinMap.keySet().iterator(); ite.hasNext(); ) {
            String aliasName = ite.next();
            LeftOuterJoinInfo joinInfo = (LeftOuterJoinInfo)_outerJoinMap.get(aliasName);
            String joinTableName = joinInfo.getJoinTableName();
            List<String> inlineWhereClauseList = joinInfo.getInlineWhereClauseList();
            List<String> additionalOnClauseList = joinInfo.getAdditionalOnClauseList();
            Map<String, String> joinOnMap = joinInfo.getJoinOnMap();
            assertJoinOnMapNotEmpty(joinOnMap, aliasName);

            sb.append(ln()).append("   ");
            if (joinInfo.isInnerJoin()) {
                sb.append(" inner join ");
            } else {
                sb.append(" left outer join "); // is main!
            }
            if (inlineWhereClauseList.isEmpty()) {
                sb.append(joinTableName);
            } else {
                sb.append(getInlineViewClause(joinTableName, inlineWhereClauseList));
            }
            sb.append(" ").append(aliasName).append(" on ");
            int count = 0;
            Set<String> localColumnNameSet = joinOnMap.keySet();
            foreach (String localColumnName in localColumnNameSet) {
                String foreignColumnName = (String)joinOnMap.get(localColumnName);
                if (count > 0) {
                    sb.append(" and ");
                }
                if (localColumnName.Equals(fixedConditionKey)) {
                    sb.append(foreignColumnName);
                } else {
                    sb.append(localColumnName).append(" = ").append(foreignColumnName);
                }
                ++count;
            }
            foreach (String additionalOnClause in additionalOnClauseList) {
                sb.append(" and ").append(additionalOnClause);
            }
        }
        return sb.toString();
    }

    protected String getInlineViewClause(String joinTableName, List<String> inlineWhereClauseList) {
        StringBuilder sb = new StringBuilder();
        sb.append("(select * from ").append(joinTableName).append(" where ");
        int count = 0;
        for (Iterator<String> ite = inlineWhereClauseList.iterator(); ite.hasNext(); ) {
            String clauseElement = ite.next();
            // clauseElement = filterWhereClauseSimply(clauseElement); *Non Support on C#
            if (count > 0) {
                sb.append(" and ");
            }
            sb.append(clauseElement);
            ++count;
        }
        sb.append(")");
        return sb.toString();
    }

    public String getFromBaseTableHint() {
        return createFromBaseTableHint();
    }

    // -----------------------------------------------------
    //                                             From Hint
    //                                             ---------
    public String getFromHint() {
        return createFromHint();
    }

    // -----------------------------------------------------
    //                                          Where Clause
    //                                          ------------
    public String getWhereClause() {
        StringBuilder sb = new StringBuilder();
        buildWhereClause(sb);
        return sb.toString();
    }

    protected void buildWhereClause(StringBuilder sb) {
        buildWhereClause(sb, false);
    }

    protected void buildWhereClause(StringBuilder sb, bool template) {
        int count = 0;
        for (Iterator<String> ite = _whereList.iterator(); ite.hasNext(); count++) {
            String clauseElement = (String)ite.next();
            // clauseElement = filterWhereClauseSimply(clauseElement); *Non Support on C#
            if (count == 0) {
                sb.append(ln()).append(" ");
                sb.append("where ").append(template  ? getWhereFirstConditionMark() : "").append(clauseElement);
            } else {
                sb.append(ln()).append("  ");
                sb.append(" and ").append(clauseElement);
            }
        }
        if (template && sb.length() == 0) {
            sb.append(getWhereClauseMark());
        }
    }

    // -----------------------------------------------------
    //                                        OrderBy Clause
    //                                        --------------
    public String getOrderByClause() {
        String orderByClause = null;
        if (hasUnionQuery()) {
            if (_selectClauseRealColumnAliasMap == null || _selectClauseRealColumnAliasMap.isEmpty()) {
                String msg = "The selectClauseColumnAliasMap should not be null or empty when union query exists: " + toString();
                throw new IllegalStateException(msg);
            }
            orderByClause = _orderByClause.getOrderByClause(_selectClauseRealColumnAliasMap);
        } else {
            orderByClause = _orderByClause.getOrderByClause();
        }
        if (orderByClause != null && orderByClause.Trim().Length > 0) {
            return ln() + " " + orderByClause;
        } else {
            return orderByClause;
        }
    }

    // -----------------------------------------------------
    //                                            SQL Suffix
    //                                            ----------
    public String getSqlSuffix() {
        String sqlSuffix = createSqlSuffix();
        if (sqlSuffix != null && sqlSuffix.Trim().Length > 0) {
            return ln() + sqlSuffix;
        } else {
            return sqlSuffix;
        }
    }

    // ===================================================================================
    //                                                                SelectedSelectColumn
    //                                                                ====================
    public void registerSelectedSelectColumn(String foreignTableAliasName
                                           , String localTableName
                                           , String foreignPropertyName
                                           , String localRelationPath) {
        _selectedSelectColumnMap.put(foreignTableAliasName, createSelectedSelectColumnInfo(foreignTableAliasName, localTableName, foreignPropertyName, localRelationPath));
    }
    
    protected Map<String, SelectedSelectColumnInfo> createSelectedSelectColumnInfo(String foreignTableAliasName
                                                                                 , String localTableName
                                                                                 , String foreignPropertyName
                                                                                 , String localRelationPath) {
        ${glDBMeta} dbmeta = ${glDBMetaInstanceHandler}.FindDBMeta(localTableName);
        ${glForeignInfo} foreignInfo = dbmeta.FindForeignInfo(foreignPropertyName);
        int relationNo = foreignInfo.RelationNo;
        String nextRelationPath = "_" + relationNo;
        if (localRelationPath != null) {
            nextRelationPath = localRelationPath + nextRelationPath;
        }
        Map<String, SelectedSelectColumnInfo> resultMap = new LinkedHashMap<String, SelectedSelectColumnInfo>();
        ${glDBMeta} foreignDBMeta = foreignInfo.ForeignDBMeta;
        foreach (${glColumnInfo} columnInfo in foreignDBMeta.ColumnInfoList) {
            String columnDbName = columnInfo.ColumnDbName;
            SelectedSelectColumnInfo selectColumnInfo = new SelectedSelectColumnInfo();
            selectColumnInfo.setTableAliasName(foreignTableAliasName);
            selectColumnInfo.setColumnName(columnDbName);
            selectColumnInfo.setColumnAliasName(columnDbName + nextRelationPath);
            resultMap.put(columnDbName, selectColumnInfo);
        }
        return resultMap;
    }

    public class SelectedSelectColumnInfo {
        protected String tableAliasName;
        protected String columnName;
        protected String columnAliasName;
        public String buildRealColumnName() {
            if (tableAliasName != null) {
                return tableAliasName + "." + columnName;
            } else {
                return columnName;
            }
        }
        public String getTableAliasName() {
            return tableAliasName;
        }
        public void setTableAliasName(String tableAliasName) {
            this.tableAliasName = tableAliasName;
        }
        public String getColumnName() {
            return columnName;
        }
        public void setColumnName(String columnName) {
            this.columnName = columnName;
        }
        public String getColumnAliasName() {
            return columnAliasName;
        }
        public void setColumnAliasName(String columnAliasName) {
            this.columnAliasName = columnAliasName;
        }
    }

    // ===================================================================================
    //                                                                           OuterJoin
    //                                                                           =========
    public void registerOuterJoin(String joinTableName, String aliasName, Map<String, String> joinOnMap) {
        assertAlreadyOuterJoin(aliasName);
        assertJoinOnMapNotEmpty(joinOnMap, aliasName);
        LeftOuterJoinInfo joinInfo = new LeftOuterJoinInfo();
        joinInfo.setAliasName(aliasName);
        joinInfo.setJoinTableName(joinTableName);
        joinInfo.setJoinOnMap(joinOnMap);
        _outerJoinMap.put(aliasName, joinInfo);
    }

    public void changeToInnerJoin(String aliasName) {
        LeftOuterJoinInfo joinInfo = _outerJoinMap.get(aliasName);
        if (joinInfo == null) {
            String msg = "The aliasName should be registered:";
            msg = msg + " aliasName=" + aliasName + " outerJoinMap=" + _outerJoinMap.keySet();
            throw new IllegalStateException(msg);
        }
        joinInfo.setInnerJoin(true);
    }

    public String getFixedConditionKey() {
        return "$$fixedCondition$$";
    }

    protected class LeftOuterJoinInfo {
        protected String _aliasName;
        protected String _joinTableName;
        protected List<String> _inlineWhereClauseList = new ArrayList<String>();
        protected List<String> _additionalOnClauseList = new ArrayList<String>();
        protected Map<String, String> _joinOnMap;
        protected bool _innerJoin;
        public String getAliasName() {
            return _aliasName;
        }
        public void setAliasName(String value) {
            _aliasName = value;
        }
        public String getJoinTableName() {
            return _joinTableName;
        }
        public void setJoinTableName(String value) {
            _joinTableName = value;
        }
        public List<String> getInlineWhereClauseList() {
            return _inlineWhereClauseList;
        }
        public void addInlineWhereClause(String value) {
            _inlineWhereClauseList.add(value);
        }
        public List<String> getAdditionalOnClauseList() {
            return _additionalOnClauseList;
        }
        public void addAdditionalOnClause(String value) {
            _additionalOnClauseList.add(value);
        }
        public Map<String, String> getJoinOnMap() {
            return _joinOnMap;
        }
        public void setJoinOnMap(Map<String, String> value) {
            _joinOnMap = value;
        }
        public bool isInnerJoin() {
            return _innerJoin;
        }
        public void setInnerJoin(bool value) {
            _innerJoin = value;
        }
    }

    protected void assertAlreadyOuterJoin(String aliasName) {
        if (_outerJoinMap.containsKey(aliasName)) {
            String msg = "The alias name have already registered in outer join: " + aliasName;
            throw new IllegalStateException(msg);
        }
    }

    protected void assertJoinOnMapNotEmpty(Map<String, String> joinOnMap, String aliasName) {
        if (joinOnMap.isEmpty()) {
            String msg = "The joinOnMap should not be empty: aliasName=" + aliasName;
            throw new IllegalStateException(msg);
        }
    }

    // ===================================================================================
    //                                                                               Where
    //                                                                               =====
    public void registerWhereClause(String columnFullName, ${glConditionKey} key, ${glConditionValue} value) {
        assertStringNotNullAndNotTrimmedEmpty("columnFullName", columnFullName);
        key.addWhereClause(_whereList, columnFullName, value);
        arrangeWhereListAsOrQuery(_whereList);
    }

    public void registerWhereClause(String columnFullName, ${glConditionKey} key, ${glConditionValue} value, ${glConditionOption} option) {
        assertStringNotNullAndNotTrimmedEmpty("columnFullName", columnFullName);
        assertObjectNotNull("option of " + columnFullName, option);
        key.addWhereClause(_whereList, columnFullName, value, option);
        arrangeWhereListAsOrQuery(_whereList);
    }

    public void registerWhereClause(String clause) {
        assertStringNotNullAndNotTrimmedEmpty("clause", clause);
        _whereList.add(clause);
        arrangeWhereListAsOrQuery(_whereList);
    }

    public void exchangeFirstWhereClauseForLastOne() {
        if (_whereList.size() > 1) {
             String first = (String)_whereList.get(0);
             String last = (String)_whereList.get(_whereList.size() - 1);
            _whereList.set(0, last);
            _whereList.set(_whereList.size() - 1, first);
        }
    }

    public bool hasWhereClause() {
        return _whereList != null && _whereList.size() > 0;
    }

    // ===================================================================================
    //                                                                         InlineWhere
    //                                                                         ===========
    public void registerBaseTableInlineWhereClause(String columnName, ${glConditionKey} key, ${glConditionValue} value) {
        assertStringNotNullAndNotTrimmedEmpty("columnName", columnName);
        key.addWhereClause(_baseTableInlineWhereList, columnName, value);
        arrangeWhereListAsOrQuery(_baseTableInlineWhereList);
    }

    public void registerBaseTableInlineWhereClause(String columnName, ${glConditionKey} key, ${glConditionValue} value, ${glConditionOption} option) {
        assertStringNotNullAndNotTrimmedEmpty("columnName", columnName);
        assertObjectNotNull("option of " + columnName, option);
        key.addWhereClause(_baseTableInlineWhereList, columnName, value, option);
        arrangeWhereListAsOrQuery(_baseTableInlineWhereList);
    }

    public void registerBaseTableInlineWhereClause(String value) {
        _baseTableInlineWhereList.add(value);
    }

    public void registerOuterJoinInlineWhereClause(String aliasName, String columnName, ${glConditionKey} key, ${glConditionValue} value, bool onClauseInline) {
        assertNotYetOuterJoin(aliasName);
        assertStringNotNullAndNotTrimmedEmpty("columnName", columnName);
         LeftOuterJoinInfo joinInfo = (LeftOuterJoinInfo)_outerJoinMap.get(aliasName);
        if (onClauseInline) {
            key.addWhereClause(joinInfo.getAdditionalOnClauseList(), aliasName + "." + columnName, value);
        } else {
            key.addWhereClause(joinInfo.getInlineWhereClauseList(), columnName, value);
        }
        arrangeWhereListAsOrQuery(joinInfo.getInlineWhereClauseList());
    }

    public void registerOuterJoinInlineWhereClause(String aliasName, String columnName, ${glConditionKey} key, ${glConditionValue} value, ${glConditionOption} option, bool onClauseInline) {
        assertNotYetOuterJoin(aliasName);
        assertStringNotNullAndNotTrimmedEmpty("columnName", columnName);
         LeftOuterJoinInfo joinInfo = (LeftOuterJoinInfo)_outerJoinMap.get(aliasName);
        if (onClauseInline) {
            key.addWhereClause(joinInfo.getAdditionalOnClauseList(), aliasName + "." + columnName, value, option);
            arrangeWhereListAsOrQuery(joinInfo.getAdditionalOnClauseList());
        } else {
            key.addWhereClause(joinInfo.getInlineWhereClauseList(), columnName, value, option);
            arrangeWhereListAsOrQuery(joinInfo.getInlineWhereClauseList());
        }
    }

    public void registerOuterJoinInlineWhereClause(String aliasName, String value, bool onClauseInline) {
        assertNotYetOuterJoin(aliasName);
         LeftOuterJoinInfo joinInfo = (LeftOuterJoinInfo)_outerJoinMap.get(aliasName);
        if (onClauseInline) {
            joinInfo.addAdditionalOnClause(value);
            arrangeWhereListAsOrQuery(joinInfo.getAdditionalOnClauseList());
        } else {
            joinInfo.addInlineWhereClause(value);
            arrangeWhereListAsOrQuery(joinInfo.getInlineWhereClauseList());
        }
    }

    protected void assertNotYetOuterJoin(String aliasName) {
        if (!_outerJoinMap.containsKey(aliasName)) {
            String msg = "The alias name have not registered in outer join yet: " + aliasName;
            throw new IllegalStateException(msg);
        }
    }

    // ===================================================================================
    //                                                                             OrQuery
    //                                                                             =======
    public void makeOrQueryEffective() {
        _orQueryEffective = true;
    }

    public void ignoreOrQuery() {
        _orQueryEffective = false;
    }

    public bool isOrQueryEffective() {
        return _orQueryEffective;
    }

    protected void arrangeWhereListAsOrQuery(List<String> whereList) {
        if (!_orQueryEffective) {
            return;
        }
        if (whereList.size() < 2) {
            return;
        }
        String or = ln() + "    or ";
        String newClause = (String)whereList.remove(whereList.size() - 1);
        String preClause = (String)whereList.remove(whereList.size() - 1);
        if (preClause.StartsWith("(") && preClause.Contains(or) && preClause.EndsWith(")")) {
            // Since the second times
            int beginLen = "(".Length;
            int endLen = ")".Length;
            String plainClause = preClause.Substring(beginLen, preClause.Length - (beginLen + endLen));
            whereList.add("(" + plainClause + or + newClause + ")");
        } else {
            // At first
            whereList.add("(" + preClause + or + newClause + ")");
        }
    }

    // ===================================================================================
    //                                                                             OrderBy
    //                                                                             =======
    public ${glOrderByClause} getSqlComponentOfOrderByClause() {
        return _orderByClause;
    }

    public ${glSqlClause} clearOrderBy() {
        _orderByEffective = false;
        _orderByClause.clear();
        return this;
    }

    public ${glSqlClause} ignoreOrderBy() {
        _orderByEffective = false;
        return this;
    }

    public ${glSqlClause} makeOrderByEffective() {
        if (!_orderByClause.isEmpty()) {
            _orderByEffective = true;
        }
        return this;
    }

    public void reverseOrderBy_Or_OverrideOrderBy(String orderByProperty, String registeredOrderByProperty, bool ascOrDesc) {
        _orderByEffective = true;
        if (!_orderByClause.isSameOrderByColumn(orderByProperty)) {
            clearOrderBy();
            registerOrderBy(orderByProperty, registeredOrderByProperty, ascOrDesc);
        } else {
            _orderByClause.reverseAll();
        }
    }

    public void registerOrderBy(String orderByProperty, String registeredOrderByProperty, bool ascOrDesc) {
        try {
            _orderByEffective = true;
            List<String> orderByList = new ArrayList<String>();
            {
                String[] splitArray = orderByProperty.Split('/');
                foreach (String element in splitArray) {
                    orderByList.add(element);
                }
            }

            if (registeredOrderByProperty == null || registeredOrderByProperty.Trim().Length ==0) {
                registeredOrderByProperty = orderByProperty;
            }

            List<String> registeredOrderByList = new ArrayList<String>();
            {
                String[] splitArray = registeredOrderByProperty.Split('/');
                foreach (String element in splitArray) {
                    registeredOrderByList.add(element);
                }
            }

            int count = 0;
            for (Iterator<String> ite = orderByList.iterator(); ite.hasNext(); ) {
                String orderBy = ite.next();
                String registeredOrderBy = (String)registeredOrderByList.get(count);

                _orderByEffective = true;
                String aliasName = null;
                String columnName = null;
                String registeredAliasName = null;
                String registeredColumnName = null;

                if (orderBy.IndexOf(".") < 0) {
                    columnName = orderBy;
                } else {
                    aliasName = orderBy.Substring(0, orderBy.LastIndexOf("."));
                    columnName = orderBy.Substring(orderBy.LastIndexOf(".") + 1);
                }

                if (registeredOrderBy.IndexOf(".") < 0) {
                    registeredColumnName = registeredOrderBy;
                } else {
                    registeredAliasName = registeredOrderBy.Substring(0, registeredOrderBy.LastIndexOf("."));
                    registeredColumnName = registeredOrderBy.Substring(registeredOrderBy.LastIndexOf(".") + 1);
                }

                ${glOrderByElement} element = new ${glOrderByElement}();
                element.setAliasName(aliasName);
                element.setColumnName(columnName);
                element.setRegisteredAliasName(registeredAliasName);
                element.setRegisteredColumnName(registeredColumnName);
                if (ascOrDesc) {
                    element.setupAsc();
                } else {
                    element.setupDesc();
                }
                _orderByClause.addOrderByElement(element);

                count++;
            }
        } catch (RuntimeException e) {
            String msg = "registerOrderBy() threw the exception: orderByProperty=" + orderByProperty;
            msg = msg + " registeredColumnFullName=" + registeredOrderByProperty;
            msg = msg + " ascOrDesc=" + ascOrDesc;
            msg = msg + " sqlClause=" + this.ToString();
            throw new RuntimeException(msg, e);
        }
    }
    
    public virtual void addNullsFirstToPreviousOrderBy() {
        _orderByClause.addNullsFirstToPreviousOrderByElement(createOrderByNullsSetupper());
    }
    
    public virtual void addNullsLastToPreviousOrderBy() {
        _orderByClause.addNullsLastToPreviousOrderByElement(createOrderByNullsSetupper());
    }
    
    protected virtual OrderByNullsSetupper createOrderByNullsSetupper() {// As Default
        return new OrderByNullsSetupperBySupported();
    }
    
    protected class OrderByNullsSetupperBySupported : OrderByNullsSetupper {
        public String setup(String columnName, String orderByElementClause, bool nullsFirst) {
            return orderByElementClause + " nulls " + (nullsFirst ? "first" : "last");
        }
    }
    
    protected virtual OrderByNullsSetupper createOrderByNullsSetupperByCaseWhen() {// Helper For Nulls Unsupported Database
        return new OrderByNullsSetupperByCaseWhen();
    }

    protected class OrderByNullsSetupperByCaseWhen : OrderByNullsSetupper {
        public String setup(String columnName, String orderByElementClause, bool nullsFirst) {
            String thenNumber = nullsFirst ? "1" : "0";
            String elseNumber = nullsFirst ? "0" : "1";
            String caseWhen = "case when " + columnName + " is not null then " + thenNumber + " else " + elseNumber + " end asc";
            return caseWhen + ", " + orderByElementClause;
        }
    }

    public bool hasOrderByClause() {
        return _orderByClause != null && !_orderByClause.isEmpty();
    }

    // ===================================================================================
    //                                                                          UnionQuery
    //                                                                          ==========
    public void registerUnionQuery(String unionQueryClause, bool unionAll) {
        assertStringNotNullAndNotTrimmedEmpty("unionQueryClause", unionQueryClause);
        UnionQueryInfo unionQueryInfo = new UnionQueryInfo();
        unionQueryInfo.setUnionQueryClause(unionQueryClause);
        unionQueryInfo.setUnionAll(unionAll);
        addUnionQueryInfo(unionQueryInfo);
    }

    protected void addUnionQueryInfo(UnionQueryInfo unionQueryInfo) {
        if (_unionQueryInfoList == null) {
            _unionQueryInfoList = new ArrayList<UnionQueryInfo>(); 
        }
        _unionQueryInfoList.add(unionQueryInfo);
    }

    public bool hasUnionQuery() {
        return _unionQueryInfoList != null && !_unionQueryInfoList.isEmpty();
    }

    protected class UnionQueryInfo {
        protected String _unionQueryClause;
        protected bool _unionAll;
        public String getUnionQueryClause() {
            return _unionQueryClause;
        }
        public void setUnionQueryClause(String unionQueryClause) {
            _unionQueryClause = unionQueryClause;
        }
        public bool isUnionAll() {
            return _unionAll;
        }
        public void setUnionAll(bool unionAll) {
            _unionAll = unionAll;
        }
    }

    // ===================================================================================
    //                                                                             Advance
    //                                                                             =======
    /**
     * @param fetchSize Fetch-size. (NotMinus & NotZero)
     * @return this. (NotNull)
     */
    public ${glSqlClause} fetchFirst(int fetchSize) {
        _fetchScopeEffective = true;
        if (fetchSize <= 0) {
            String msg = "Argument[fetchSize] must be plus: " + fetchSize;
            throw new IllegalArgumentException(msg);
        }
        _fetchStartIndex = 0;
        _fetchSize = fetchSize;
        _fetchPageNumber = 1;
        doClearFetchPageClause();
        doFetchFirst();
        return this;
    }

    /**
     * @param fetchStartIndex Fetch-start-index. 0 origin. (NotMinus)
     * @param fetchSize Fetch size. (NotMinus)
     * @return this. (NotNull)
     */
    public ${glSqlClause} fetchScope(int fetchStartIndex, int fetchSize) {
        _fetchScopeEffective = true;
        if (fetchStartIndex < 0) {
            String msg = "Argument[fetchStartIndex] must be plus or zero: " + fetchStartIndex;
            throw new IllegalArgumentException(msg);
        }
        if (fetchSize <= 0) {
            String msg = "Argument[fetchSize] must be plus: " + fetchSize;
            throw new IllegalArgumentException(msg);
        }
        _fetchStartIndex = fetchStartIndex;
        _fetchSize = fetchSize;
        return fetchPage(1);
    }

    /**
     * @param fetchPageNumber Page-number. 1 origin. (NotMinus & NotZero: If minus or zero, set one.)
     * @return this. (NotNull)
     */
    public ${glSqlClause} fetchPage(int fetchPageNumber) {
        _fetchScopeEffective = true;
        if (fetchPageNumber <= 0) {
            fetchPageNumber = 1;
        }
        if (_fetchSize <= 0) {
            String msg = "Fetch size should not be minus or zero!" + ln();
            msg = msg + "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *" + ln();
            msg = msg + "Look! Read the message below." + ln();
            msg = msg + ln();
            msg = msg + "[Advice]" + ln();
            msg = msg + "When you invoke this method, it is necessary to invoke 'FetchFirst()' or 'FetchScope()' ahead of that. " + ln();
            msg = msg + "Please confirm your program. Does it really invoke 'FetchPage()' with 'FetchFirst()' or 'FetchScope()'?" + ln();
            msg = msg + "  For example:" + ln();
            msg = msg + "    before (x):" + ln();
            msg = msg + "      XxxCB cb = new XxxCB();" + ln();
            msg = msg + "      cb.FetchPage(3);" + ln();
            msg = msg + "    after  (o):" + ln();
            msg = msg + "      XxxCB cb = new XxxCB();" + ln();
            msg = msg + "      cb.FetchFirst(20); // The size of page" + ln();
            msg = msg + "      cb.FetchPage(3);   // The number of target page" + ln();
            msg = msg + ln();
            msg = msg + "[Actual Parameter Value]" + ln();
            msg = msg + "fetchSize=" + _fetchSize + ln();
            msg = msg + "fetchPageNumber=" + fetchPageNumber + ln();
            msg = msg + "* * * * * * * * * */" + ln();
            throw new IllegalStateException(msg);
        }
        _fetchPageNumber = fetchPageNumber;
        if (_fetchPageNumber == 1 && _fetchStartIndex == 0) {
            return fetchFirst(_fetchSize);
        }
        doClearFetchPageClause();
        doFetchPage();
        return this;
    }

    abstract protected void doFetchFirst();
    abstract protected void doFetchPage();
    abstract protected void doClearFetchPageClause();

    public virtual int getFetchStartIndex() {
        return _fetchStartIndex;
    }

    public virtual int getFetchSize() {
        return _fetchSize;
    }

    public virtual int getFetchPageNumber() {
        return _fetchPageNumber;
    }

    /**
     * @return Page start index. 0 origin. (NotMinus)
     */
    public virtual int getPageStartIndex() {
        if (_fetchPageNumber <= 0) {
            String msg = "_fetchPageNumber must be plus: " + _fetchPageNumber;
            throw new IllegalStateException(msg);
        }
        return _fetchStartIndex + (_fetchSize * (_fetchPageNumber - 1));
    }

    /**
     * @return Page end index. 0 origin. (NotMinus)
     */
    public virtual int getPageEndIndex() {
        if (_fetchPageNumber <= 0) {
            String msg = "_fetchPageNumber must be plus: " + _fetchPageNumber;
            throw new IllegalStateException(msg);
        }
        return _fetchStartIndex + (_fetchSize * _fetchPageNumber);
    }

    public virtual bool isFetchScopeEffective() {
        return _fetchScopeEffective;
    }

    public virtual ${glSqlClause} ignoreFetchScope() {
        _fetchScopeEffective = false;
        doClearFetchPageClause();
        return this;
    }

    public virtual ${glSqlClause} makeFetchScopeEffective() {
        if (getFetchSize() > 0 && getFetchPageNumber() > 0) {
            fetchPage(getFetchPageNumber());
        }
        return this;
    }
    
    public virtual bool isFetchStartIndexSupported() {
        return true; // Default
    }

    public virtual bool isFetchSizeSupported() {
        return true; // Default
    }

    abstract protected String createSelectHint();
    abstract protected String createFromBaseTableHint();
    abstract protected String createFromHint();
    abstract protected String createSqlSuffix();

    // ===================================================================================
    //                                                                     Fetch Narrowing
    //                                                                     ===============
    public virtual int getFetchNarrowingSkipStartIndex() {
        return getPageStartIndex();
    }

    public virtual int getFetchNarrowingLoopCount() {
        return getFetchSize();
    }

    public virtual bool isFetchNarrowingEffective() {
        return _fetchScopeEffective;
    }

    // ===================================================================================
    //                                                                                Lock
    //                                                                                ====
    public abstract ${glSqlClause} lockForUpdate();
    
    // ===================================================================================
    //                                                                            Resolver
    //                                                                            ========
    public String resolveJoinAliasName(String relationPath, int cqNestNo) {
        return resolveNestLevelExpression("dfrelation" + relationPath, cqNestNo);
    }

    public String resolveNestLevelExpression(String name, int cqNestNo) {
        // if (cqNestNo > 1) {
        //     return name + "_n" + cqNestNo;
        // } else {
        //     return name;
        // }
        return name;
    }

    public int resolveRelationNo(String localTableName, String foreignPropertyName) {
         ${glDBMeta} dbmeta = ${glDBMetaInstanceHandler}.FindDBMeta(localTableName);
         ${glForeignInfo} foreignInfo = dbmeta.FindForeignInfo(foreignPropertyName);
        return foreignInfo.RelationNo;
    }

    // ===================================================================================
    //                                                                    Table Alias Info
    //                                                                    ================
    public String getLocalTableAliasName() {
        return "dflocal";
    }
    
    public String getForeignTableAliasPrefix() {
        return "dfrelation";
    }

    // ===================================================================================
    //                                                                       Template Mark
    //                                                                       =============
    public String getWhereClauseMark() {
        return "#df:whereClause#";
    }
    
    public String getWhereFirstConditionMark() {
        return "#df:whereFirstCondition#";
    }
    
    public String getUnionSelectClauseMark() {
        return "#df:unionSelectClause#";
    }
    
    public String getUnionWhereClauseMark() {
        return "#df:unionWhereClause#";
    }
    
    public String getUnionWhereFirstConditionMark() {
        return "#df:unionWhereFirstCondition#";
    }
    
//    // =====================================================================================
//    //                                                            Where Clause Simple Filter
//    //                                                            ==========================
//    public void addWhereClauseSimpleFilter(${glWhereClauseSimpleFilter} whereClauseSimpleFilter) {
//        if (_whereClauseSimpleFilterList == null) {
//            _whereClauseSimpleFilterList = new ArrayList<${glWhereClauseSimpleFilter}>();
//        }
//        _whereClauseSimpleFilterList.add(whereClauseSimpleFilter);
//    }
//
//    protected String filterWhereClauseSimply(String clauseElement) {
//        if (_whereClauseSimpleFilterList == null || _whereClauseSimpleFilterList.isEmpty()) {
//            return clauseElement;
//        }
//        for (Iterator<${glWhereClauseSimpleFilter}> ite = _whereClauseSimpleFilterList.iterator(); ite.hasNext(); ) {
//             ${glWhereClauseSimpleFilter} filter = ite.next();
//            if (filter == null) {
//                String msg = "The list of filter should not have null: _whereClauseSimpleFilterList=" + _whereClauseSimpleFilterList;
//                throw new IllegalStateException(msg);
//            }
//            clauseElement = filter.filterClauseElement(clauseElement);
//        }
//        return clauseElement;
//    }
    
    // =====================================================================================
    //                                                                 Selected Foreign Info
    //                                                                 =====================
    public bool isSelectedForeignInfoEmpty() {
        if (_selectedForeignInfo == null) {
            return true;
        }
        return _selectedForeignInfo.isEmpty();
    }

    public bool hasSelectedForeignInfo(String relationPath) {
        if (_selectedForeignInfo == null) {
            return false;
        }
        return _selectedForeignInfo.containsKey(relationPath);
    }

    public void registerSelectedForeignInfo(String relationPath, String foreignPropertyName) {
        if (_selectedForeignInfo == null) {
            _selectedForeignInfo = new HashMap<String, String>();
        }
        _selectedForeignInfo.put(relationPath, foreignPropertyName);
    }

    // ===================================================================================
    //                                                                    Sub Query Indent
    //                                                                    ================
    public String resolveSubQueryBeginMark(String subQueryIdentity) {
        return getSubQueryBeginMarkPrefix() + subQueryIdentity + getSubQueryIdentityTerminal();
    }

    public String resolveSubQueryEndMark(String subQueryIdentity) {
        return getSubQueryEndMarkPrefix() + subQueryIdentity + getSubQueryIdentityTerminal();
    }

    protected String getSubQueryBeginMarkPrefix() {
        return "--df:SubQueryBegin#";
    }

    protected String getSubQueryEndMarkPrefix() {
        return "--df:SubQueryEnd#";
    }
    
    protected String getSubQueryIdentityTerminal() {
        return "#IdentityTerminal#";
    }

    public String filterSubQueryIndent(String sql) {
        return filterSubQueryIndent(sql, "", sql);
    }

    protected String filterSubQueryIndent(String sql, String preIndent, String originalSql) {
        String lineSeparator = ln();
        if (!sql.Contains(getSubQueryBeginMarkPrefix())) {
            return sql;
        }
        String[] lines = sql.Split(lineSeparator.ToCharArray());// *Attension about difference between Language!
        String beginMarkPrefix = getSubQueryBeginMarkPrefix();
        String endMarkPrefix = getSubQueryEndMarkPrefix();
        String identityTerminal = getSubQueryIdentityTerminal();
        int terminalLength = identityTerminal.Length;
        StringBuilder mainSb = new StringBuilder();
        StringBuilder subSb = null;
        bool throughBegin = false;
        bool throughBeginFirst = false;
        String subQueryIdentity = null;
        String indent = null;
        foreach (String line in lines) {
            if (!throughBegin) {
                if (line.Contains(beginMarkPrefix)) {
                    throughBegin = true;
                    subSb = new StringBuilder();
                    int markIndex = line.IndexOf(beginMarkPrefix);
                    int terminalIndex = line.IndexOf(identityTerminal);
                    if (terminalIndex < 0) {
                        String msg = "Identity terminal was Not Found at the begin line: [" + line + "]";
                        throw new SubQueryIndentFailureException(msg);
                    }
                    String clause = line.Substring(0, markIndex) + line.Substring(terminalIndex + terminalLength);
                    subQueryIdentity = line.Substring(markIndex + beginMarkPrefix.Length, terminalIndex - (markIndex + beginMarkPrefix.Length));// *Attension about difference between Language!
                    subSb.append(clause);
                    indent = buildSpaceBar(markIndex - preIndent.Length);
                } else {
                    mainSb.append(line).append(ln());
                }
            } else {
                // - - - - - - - -
                // In begin to end
                // - - - - - - - -
                if (line.Contains(endMarkPrefix + subQueryIdentity)) {// The end
                    int markIndex = line.IndexOf(endMarkPrefix);
                    int terminalIndex = line.IndexOf(identityTerminal);
                    if (terminalIndex < 0) {
                        String msg = "Identity terminal was Not Found at the begin line: [" + line + "]";
                        throw new SubQueryIndentFailureException(msg);
                    }
                    String clause = line.Substring(0, markIndex) + line.Substring(terminalIndex + terminalLength);
                    subSb.append(clause).append(ln());
                    String currentSql = filterSubQueryIndent(subSb.toString(), preIndent + indent, originalSql);
                    mainSb.append(currentSql);
                    throughBegin = false;
                    throughBeginFirst = false;
                } else {
                    if (!throughBeginFirst) {
                        subSb.append(line.Trim()).append(ln());
                        throughBeginFirst = true;
                    } else {
                        subSb.append(indent).append(line).append(ln());
                    }
                }
            }
        }
        String filteredSql = mainSb.toString();
        
        if (throughBegin) {
            String msg = "End Mark Not Found!";
            msg = msg + ln() + "[Current SubQueryIdentity]" + ln();
            msg = msg + subQueryIdentity + ln();
            msg = msg + ln() + "[Before Filter]" + ln();
            msg = msg + ln() + "[After Filter]" + ln() + filteredSql;
            msg = msg + ln() + "[Original SQL]" + ln() + originalSql;
            throw new SubQueryIndentFailureException(msg);
        }
        if (filteredSql.Contains(beginMarkPrefix)) {
            String msg = "Any begin marks are not filtered!";
            msg = msg + ln() + "[Current SubQueryIdentity]" + ln();
            msg = msg + subQueryIdentity + ln();
            msg = msg + ln() + "[Before Filter]" + ln();
            msg = msg + ln() + "[After Filter]" + ln() + filteredSql;
            msg = msg + ln() + "[Original SQL]" + ln() + originalSql;
            throw new SubQueryIndentFailureException(msg);
        }
        return filteredSql;
    }
    
    protected String buildSpaceBar(int size) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < size; i++) {
            sb.append(" ");
        }
        return sb.toString();
    }
    
    public class SubQueryIndentFailureException : RuntimeException {
        public SubQueryIndentFailureException(String msg) : base(msg) {
        }
    }

    // ===================================================================================
    //                                                                       Specification
    //                                                                       =============
    public void specifySelectColumn(String tableAliasName, String columnName) {
        if (_specifiedSelectColumnMap == null) {
            _specifiedSelectColumnMap = new HashMap<String, Map<String, String>>();
        }
        if (!_specifiedSelectColumnMap.containsKey(tableAliasName)) {
            _specifiedSelectColumnMap.put(tableAliasName, new LinkedHashMap<String, String>());
        }
        Map<String, String> elementMap = _specifiedSelectColumnMap.get(tableAliasName);
        elementMap.put(columnName, null); // The value is dummy for extension at the future.
        _specifiedSelectColumnMap.put(tableAliasName, elementMap);
    }

    public void specifyDeriveSubQuery(String aliasName, String deriveSubQuery) {
        if (_specifiedDeriveSubQueryMap == null) {
            _specifiedDeriveSubQueryMap = new LinkedHashMap<String, String>();
        }
        _specifiedDeriveSubQueryMap.put(aliasName, deriveSubQuery);
    }

    public bool hasSpecifiedDeriveSubQuery(String aliasName) {
        if (_specifiedDeriveSubQueryMap == null) { return false; }
        return _specifiedDeriveSubQueryMap.containsKey(aliasName);
    }

    public String getSpecifiedColumnNameAsOne() {
        if (_specifiedSelectColumnMap != null && _specifiedSelectColumnMap.size() == 1) {
            Map<String, String> elementMap = _specifiedSelectColumnMap.get(_specifiedSelectColumnMap.keySet().iterator().next());
            if (elementMap != null && elementMap.size() == 1) {
                return elementMap.keySet().iterator().next();
            }
        }
        return null;
    }

    public void clearSpecifiedSelectColumn() {
        if (_specifiedSelectColumnMap != null) { _specifiedSelectColumnMap.clear(); _specifiedSelectColumnMap = null; }
    }

    // [DBFlute-0.7.9]
    // ===================================================================================
    //                                                                        Query Update
    //                                                                        ============
    public String getClauseQueryUpdate(Map<String, String> columnParameterMap) {
        if (columnParameterMap.isEmpty()) {
            return null;
        }
        String aliasName = getLocalTableAliasName();
        ${glDBMeta} dbmeta = findDBMeta();
        if (dbmeta.HasTwoOrMorePrimaryKeys) {
            String msg = "The target table of queryUpdate() should have only one primary key:";
            msg = msg + " primaryKeys=" + toStringView(dbmeta.PrimaryUniqueInfo.UniqueColumnList);
            throw new IllegalStateException(msg);
        }
        String primaryKeyName = dbmeta.PrimaryUniqueInfo.FirstColumn.ColumnDbName;
        String selectClause = "select " + aliasName + "." + primaryKeyName;
        String fromWhereClause = getClauseFromWhereWithUnionTemplate();

        // Replace template marks. These are very important!
        fromWhereClause = replaceString(fromWhereClause, getUnionSelectClauseMark(), selectClause);
        fromWhereClause = replaceString(fromWhereClause, getUnionWhereClauseMark(), "");
        fromWhereClause = replaceString(fromWhereClause, getUnionWhereFirstConditionMark(), "");

        StringBuilder sb = new StringBuilder();
        String ln = ln();
        sb.append("update ").append(_tableName).append(ln);
        int index = 0;
        // It is guaranteed that the map has one or more elements.
        foreach (String columnName in columnParameterMap.keySet()) {
            String parameter = columnParameterMap.get(columnName); 
            if (index == 0) {
                sb.append("   set ").append(columnName).append(" = ").append(parameter).append(ln);
            } else {
                sb.append("     , ").append(columnName).append(" = ").append(parameter).append(ln);
            }
            ++index;
        }
        if (isUpdateSubQueryUseLocalTableSupported()) {
            String subQuery = filterSubQueryIndent(selectClause + " " + fromWhereClause);
            sb.append(" where ").append(primaryKeyName);
            sb.append(" in (").append(ln).append(subQuery).append(ln).append(")");
            return sb.toString();
        } else {
            String subQuery = filterSubQueryIndent(fromWhereClause);
            subQuery = replaceString(subQuery, aliasName + ".", "");
            subQuery = replaceString(subQuery, " " + aliasName + " ", " ");
            int whereIndex = subQuery.IndexOf("where ");
            if (whereIndex < 0) {
                return sb.toString();
            }
            subQuery = subQuery.Substring(whereIndex);
            sb.append(" ").append(subQuery);
            return sb.toString();
        }
    }

    public String getClauseQueryDelete() {
        String aliasName = getLocalTableAliasName();
        ${glDBMeta} dbmeta = findDBMeta();
        if (dbmeta.HasTwoOrMorePrimaryKeys) {
            String msg = "The target table of queryDelete() should have only one primary key:";
            msg = msg + " primaryKeys=" + toStringView(dbmeta.PrimaryUniqueInfo.UniqueColumnList);
            throw new IllegalStateException(msg);
        }
        String primaryKeyName = dbmeta.PrimaryUniqueInfo.FirstColumn.ColumnDbName;
        String selectClause = "select " + aliasName + "." + primaryKeyName;
        String fromWhereClause = getClauseFromWhereWithUnionTemplate();
        
        // Replace template marks. These are very important!
        fromWhereClause = replaceString(fromWhereClause, getUnionSelectClauseMark(), selectClause);
        fromWhereClause = replaceString(fromWhereClause, getUnionWhereClauseMark(), "");
        fromWhereClause = replaceString(fromWhereClause, getUnionWhereFirstConditionMark(), "");
        
        if (isUpdateSubQueryUseLocalTableSupported()) {
            String subQuery = filterSubQueryIndent(selectClause + " " + fromWhereClause);
            StringBuilder sb = new StringBuilder();
            String ln = ln();
            sb.append("delete from ").append(_tableName).append(ln);
            sb.append(" where ").append(primaryKeyName);
            sb.append(" in (").append(ln).append(subQuery).append(ln).append(")");
            return sb.toString();
        } else {
            String subQuery = filterSubQueryIndent(fromWhereClause);
            subQuery = replaceString(subQuery, aliasName + ".", "");
            subQuery = replaceString(subQuery, " " + aliasName + " ", " ");
            subQuery = subQuery.Substring(subQuery.IndexOf("from "));
            return "delete " + subQuery;
        }
    }

    protected virtual bool isUpdateSubQueryUseLocalTableSupported() {
        return true;
    }

    // [DBFlute-0.8.6]
    // ===================================================================================
    //                                                                  Select Clause Type
    //                                                                  ==================
    public void classifySelectClauseType(SelectClauseType selectClauseType) {
        changeSelectClauseType(selectClauseType);
    }

    protected void changeSelectClauseType(SelectClauseType selectClauseType) {
        savePreviousSelectClauseType();
        _selectClauseType = selectClauseType;
    }

    protected void savePreviousSelectClauseType() {
        _previousSelectClauseType = _selectClauseType;
    }

    public void rollbackSelectClauseType() {
        _selectClauseType = _previousSelectClauseType != null ? _previousSelectClauseType : DEFAULT_SELECT_CLAUSE_TYPE;
    }

    // [DBFlute-0.7.9]
    // ===================================================================================
    //                                                                       Assist Helper
    //                                                                       =============
    protected ${glDBMeta} findDBMeta() {
        return ${glDBMetaInstanceHandler}.FindDBMeta(_tableName); 
    }

    // ===================================================================================
    //                                                                      General Helper
    //                                                                      ==============
    protected String replaceString(String text, String fromText, String toText) {
        return ${glSimpleStringUtil}.Replace(text, fromText, toText);
    }
    
    protected String ln() {
        return ${glSimpleSystemUtil}.GetLineSeparator();
    }

    protected String toStringView(Object obj) {
        return ${glTraceViewUtil}.ToStringView(obj);
    }
    
    // -----------------------------------------------------
    //                                         Assert Object
    //                                         -------------
    protected void assertObjectNotNull(String variableName, Object value) {
        ${glSimpleAssertUtil}.AssertObjectNotNull(variableName, value);
    }

    // -----------------------------------------------------
    //                                         Assert String
    //                                         -------------
    protected void assertStringNotNullAndNotTrimmedEmpty(String variableName, String value) {
        ${glSimpleAssertUtil}.AssertStringNotNullAndNotTrimmedEmpty(variableName, value);
    }
    
    // ===================================================================================
    //                                                                      Basic Override
    //                                                                      ==============
    public String toString() {
        return ToString();
    }
}

}
